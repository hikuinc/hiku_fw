
hiku free rtos bringup.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b38c  00400000  00400000  00008000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0040b38c  0040b38c  0001338c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000a70  20000000  0040b394  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000047a8  20000a70  0040be08  00018a70  2**3
                  ALLOC
  4 .stack        00003000  20005218  004105b0  00018a70  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00018a70  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00018a9e  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001359d  00000000  00000000  00018af9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003ace  00000000  00000000  0002c096  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00009a37  00000000  00000000  0002fb64  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000dd8  00000000  00000000  0003959b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000cf8  00000000  00000000  0003a373  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000ada3  00000000  00000000  0003b06b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00013462  00000000  00000000  00045e0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000584ce  00000000  00000000  00059270  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002bf8  00000000  00000000  000b1740  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20008218 	.word	0x20008218
  400004:	0040170d 	.word	0x0040170d
  400008:	00401709 	.word	0x00401709
  40000c:	00401709 	.word	0x00401709
  400010:	00401709 	.word	0x00401709
  400014:	00401709 	.word	0x00401709
  400018:	00401709 	.word	0x00401709
	...
  40002c:	004022e9 	.word	0x004022e9
  400030:	00401709 	.word	0x00401709
  400034:	00000000 	.word	0x00000000
  400038:	00402361 	.word	0x00402361
  40003c:	004023b1 	.word	0x004023b1
  400040:	00401709 	.word	0x00401709
  400044:	00401709 	.word	0x00401709
  400048:	00401709 	.word	0x00401709
  40004c:	00401709 	.word	0x00401709
  400050:	00401709 	.word	0x00401709
  400054:	00401709 	.word	0x00401709
  400058:	00401709 	.word	0x00401709
  40005c:	004011a5 	.word	0x004011a5
  400060:	00401195 	.word	0x00401195
  400064:	00401709 	.word	0x00401709
  400068:	00000000 	.word	0x00000000
  40006c:	00401709 	.word	0x00401709
  400070:	00401709 	.word	0x00401709
  400074:	00401709 	.word	0x00401709
  400078:	00401709 	.word	0x00401709
  40007c:	00401709 	.word	0x00401709
  400080:	00401709 	.word	0x00401709
  400084:	00401709 	.word	0x00401709
  400088:	00401709 	.word	0x00401709
  40008c:	00401709 	.word	0x00401709
  400090:	004004b1 	.word	0x004004b1
  400094:	00401709 	.word	0x00401709
  400098:	00401709 	.word	0x00401709
  40009c:	00401709 	.word	0x00401709
  4000a0:	00401709 	.word	0x00401709
  4000a4:	00401709 	.word	0x00401709
  4000a8:	00401709 	.word	0x00401709
  4000ac:	00401709 	.word	0x00401709
  4000b0:	00401709 	.word	0x00401709
  4000b4:	00401709 	.word	0x00401709
  4000b8:	00401709 	.word	0x00401709
	...
  4000fc:	00401709 	.word	0x00401709
  400100:	00401709 	.word	0x00401709
  400104:	00401709 	.word	0x00401709
	...

00400148 <__do_global_dtors_aux>:
  400148:	b510      	push	{r4, lr}
  40014a:	4c05      	ldr	r4, [pc, #20]	; (400160 <__do_global_dtors_aux+0x18>)
  40014c:	7823      	ldrb	r3, [r4, #0]
  40014e:	b933      	cbnz	r3, 40015e <__do_global_dtors_aux+0x16>
  400150:	4b04      	ldr	r3, [pc, #16]	; (400164 <__do_global_dtors_aux+0x1c>)
  400152:	b113      	cbz	r3, 40015a <__do_global_dtors_aux+0x12>
  400154:	4804      	ldr	r0, [pc, #16]	; (400168 <__do_global_dtors_aux+0x20>)
  400156:	f3af 8000 	nop.w
  40015a:	2301      	movs	r3, #1
  40015c:	7023      	strb	r3, [r4, #0]
  40015e:	bd10      	pop	{r4, pc}
  400160:	20000a70 	.word	0x20000a70
  400164:	00000000 	.word	0x00000000
  400168:	0040b394 	.word	0x0040b394

0040016c <frame_dummy>:
  40016c:	4b08      	ldr	r3, [pc, #32]	; (400190 <frame_dummy+0x24>)
  40016e:	b510      	push	{r4, lr}
  400170:	b11b      	cbz	r3, 40017a <frame_dummy+0xe>
  400172:	4808      	ldr	r0, [pc, #32]	; (400194 <frame_dummy+0x28>)
  400174:	4908      	ldr	r1, [pc, #32]	; (400198 <frame_dummy+0x2c>)
  400176:	f3af 8000 	nop.w
  40017a:	4808      	ldr	r0, [pc, #32]	; (40019c <frame_dummy+0x30>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b903      	cbnz	r3, 400182 <frame_dummy+0x16>
  400180:	bd10      	pop	{r4, pc}
  400182:	4b07      	ldr	r3, [pc, #28]	; (4001a0 <frame_dummy+0x34>)
  400184:	2b00      	cmp	r3, #0
  400186:	d0fb      	beq.n	400180 <frame_dummy+0x14>
  400188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40018c:	4718      	bx	r3
  40018e:	bf00      	nop
  400190:	00000000 	.word	0x00000000
  400194:	0040b394 	.word	0x0040b394
  400198:	20000a74 	.word	0x20000a74
  40019c:	0040b394 	.word	0x0040b394
  4001a0:	00000000 	.word	0x00000000

004001a4 <freertos_twi_master_init>:
 *     be used with FreeRTOS TWI read and write functions is returned.  If
 *     the initialisation fails then NULL is returned.
 */
freertos_twi_if freertos_twi_master_init(Twi *p_twi,
		const freertos_peripheral_options_t *const freertos_driver_parameters)
{
  4001a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4001a8:	b083      	sub	sp, #12
  4001aa:	4681      	mov	r9, r0
  4001ac:	460d      	mov	r5, r1
	portBASE_TYPE twi_index;
	bool is_valid_operating_mode;
	freertos_twi_if return_value;
	const enum peripheral_operation_mode valid_operating_modes[] = {TWI_I2C_MASTER};
  4001ae:	ae02      	add	r6, sp, #8
  4001b0:	2303      	movs	r3, #3
  4001b2:	f806 3d04 	strb.w	r3, [r6, #-4]!

	/* Find the index into the all_twi_definitions array that holds details of
	the p_twi peripheral. */
	twi_index = get_pdc_peripheral_details(all_twi_definitions, MAX_TWIS,
  4001b6:	4834      	ldr	r0, [pc, #208]	; (400288 <freertos_twi_master_init+0xe4>)
  4001b8:	2108      	movs	r1, #8
  4001ba:	464a      	mov	r2, r9
  4001bc:	4b33      	ldr	r3, [pc, #204]	; (40028c <freertos_twi_master_init+0xe8>)
  4001be:	4798      	blx	r3
  4001c0:	4604      	mov	r4, r0
			(void *) p_twi);

	/* Check the requested operating mode is valid for the peripheral. */
	is_valid_operating_mode = check_requested_operating_mode(
  4001c2:	7b28      	ldrb	r0, [r5, #12]
  4001c4:	4631      	mov	r1, r6
  4001c6:	2201      	movs	r2, #1
  4001c8:	4b31      	ldr	r3, [pc, #196]	; (400290 <freertos_twi_master_init+0xec>)
  4001ca:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_twi pointer was used, and a valid
	operating mode was requested. */
	if ((twi_index < MAX_TWIS) && (is_valid_operating_mode == true)) {
  4001cc:	2c07      	cmp	r4, #7
  4001ce:	dc52      	bgt.n	400276 <freertos_twi_master_init+0xd2>
  4001d0:	2800      	cmp	r0, #0
  4001d2:	d053      	beq.n	40027c <freertos_twi_master_init+0xd8>
		/* This function must be called exactly once per supported twi.  Check
		it has not been called	before. */
		configASSERT(memcmp((void *)&(tx_dma_control[twi_index]),
  4001d4:	4b2f      	ldr	r3, [pc, #188]	; (400294 <freertos_twi_master_init+0xf0>)
  4001d6:	eb03 08c4 	add.w	r8, r3, r4, lsl #3
  4001da:	4640      	mov	r0, r8
  4001dc:	492e      	ldr	r1, [pc, #184]	; (400298 <freertos_twi_master_init+0xf4>)
  4001de:	2208      	movs	r2, #8
  4001e0:	4b2e      	ldr	r3, [pc, #184]	; (40029c <freertos_twi_master_init+0xf8>)
  4001e2:	4798      	blx	r3
  4001e4:	b120      	cbz	r0, 4001f0 <freertos_twi_master_init+0x4c>
  4001e6:	482e      	ldr	r0, [pc, #184]	; (4002a0 <freertos_twi_master_init+0xfc>)
  4001e8:	f44f 7181 	mov.w	r1, #258	; 0x102
  4001ec:	4b2d      	ldr	r3, [pc, #180]	; (4002a4 <freertos_twi_master_init+0x100>)
  4001ee:	4798      	blx	r3
				&null_dma_control,
				sizeof(null_dma_control)) == 0);
		configASSERT(memcmp((void *)&(rx_dma_control[twi_index]),
  4001f0:	4f2d      	ldr	r7, [pc, #180]	; (4002a8 <freertos_twi_master_init+0x104>)
  4001f2:	eb07 07c4 	add.w	r7, r7, r4, lsl #3
  4001f6:	4638      	mov	r0, r7
  4001f8:	4927      	ldr	r1, [pc, #156]	; (400298 <freertos_twi_master_init+0xf4>)
  4001fa:	2208      	movs	r2, #8
  4001fc:	4b27      	ldr	r3, [pc, #156]	; (40029c <freertos_twi_master_init+0xf8>)
  4001fe:	4798      	blx	r3
  400200:	b120      	cbz	r0, 40020c <freertos_twi_master_init+0x68>
  400202:	4827      	ldr	r0, [pc, #156]	; (4002a0 <freertos_twi_master_init+0xfc>)
  400204:	f240 1105 	movw	r1, #261	; 0x105
  400208:	4b26      	ldr	r3, [pc, #152]	; (4002a4 <freertos_twi_master_init+0x100>)
  40020a:	4798      	blx	r3
				sizeof(null_dma_control)) == 0);

		/* Enable the peripheral's clock. */
#if (SAMG55)
		/* Enable the peripheral and set TWI mode. */
		uint32_t temp = (uint32_t)(all_twi_definitions[twi_index].peripheral_base_address - 0x600);
  40020c:	4a1e      	ldr	r2, [pc, #120]	; (400288 <freertos_twi_master_init+0xe4>)
  40020e:	0123      	lsls	r3, r4, #4
  400210:	eb02 0b03 	add.w	fp, r2, r3
  400214:	58d6      	ldr	r6, [r2, r3]
		Flexcom *p_flexcom = (Flexcom *)temp;
  400216:	f5a6 6ac0 	sub.w	sl, r6, #1536	; 0x600
		flexcom_enable(p_flexcom);
  40021a:	4650      	mov	r0, sl
  40021c:	4b23      	ldr	r3, [pc, #140]	; (4002ac <freertos_twi_master_init+0x108>)
  40021e:	4798      	blx	r3
		flexcom_set_opmode(p_flexcom, FLEXCOM_TWI);
  400220:	4650      	mov	r0, sl
  400222:	2103      	movs	r1, #3
  400224:	4b22      	ldr	r3, [pc, #136]	; (4002b0 <freertos_twi_master_init+0x10c>)
  400226:	4798      	blx	r3
#else
		pmc_enable_periph_clk(
				all_twi_definitions[twi_index].peripheral_id);
#endif
		/* Ensure everything is disabled before configuration. */
		pdc_disable_transfer(
  400228:	f8db 0004 	ldr.w	r0, [fp, #4]
  40022c:	f240 2102 	movw	r1, #514	; 0x202
  400230:	4b20      	ldr	r3, [pc, #128]	; (4002b4 <freertos_twi_master_init+0x110>)
  400232:	4798      	blx	r3
				all_twi_definitions[twi_index].pdc_base_address,
				(PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS));
		twi_disable_interrupt(
  400234:	4630      	mov	r0, r6
  400236:	f04f 31ff 	mov.w	r1, #4294967295
  40023a:	4b1f      	ldr	r3, [pc, #124]	; (4002b8 <freertos_twi_master_init+0x114>)
  40023c:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address,
				MASK_ALL_INTERRUPTS);
		twi_reset(
  40023e:	4630      	mov	r0, r6
  400240:	4b1e      	ldr	r3, [pc, #120]	; (4002bc <freertos_twi_master_init+0x118>)
  400242:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address);

		switch (freertos_driver_parameters->operation_mode) {
  400244:	7b2b      	ldrb	r3, [r5, #12]
  400246:	2b03      	cmp	r3, #3
  400248:	d102      	bne.n	400250 <freertos_twi_master_init+0xac>
		case TWI_I2C_MASTER:
			/* Call the standard ASF init function. */
			twi_enable_master_mode(
  40024a:	4630      	mov	r0, r6
  40024c:	4b1c      	ldr	r3, [pc, #112]	; (4002c0 <freertos_twi_master_init+0x11c>)
  40024e:	4798      	blx	r3
		}

		/* Create any required peripheral access mutexes and transaction complete
		semaphores.  This peripheral is half duplex so only a single access
		mutex is required. */
		create_peripheral_control_semaphores(
  400250:	7b68      	ldrb	r0, [r5, #13]
  400252:	4641      	mov	r1, r8
  400254:	463a      	mov	r2, r7
  400256:	4b1b      	ldr	r3, [pc, #108]	; (4002c4 <freertos_twi_master_init+0x120>)
  400258:	4798      	blx	r3
				freertos_driver_parameters->options_flags,
				&(tx_dma_control[twi_index]),
				&(rx_dma_control[twi_index]));

		/* Error interrupts are always enabled. */
		twi_enable_interrupt(
  40025a:	4630      	mov	r0, r6
  40025c:	f44f 7150 	mov.w	r1, #832	; 0x340
  400260:	4b19      	ldr	r3, [pc, #100]	; (4002c8 <freertos_twi_master_init+0x124>)
  400262:	4798      	blx	r3
				all_twi_definitions[twi_index].peripheral_base_address,
				IER_ERROR_INTERRUPTS);

		/* Configure and enable the TWI interrupt in the interrupt controller. */
		configure_interrupt_controller(
  400264:	4b08      	ldr	r3, [pc, #32]	; (400288 <freertos_twi_master_init+0xe4>)
  400266:	eb03 1404 	add.w	r4, r3, r4, lsl #4
  40026a:	f994 000c 	ldrsb.w	r0, [r4, #12]
  40026e:	68a9      	ldr	r1, [r5, #8]
  400270:	4b16      	ldr	r3, [pc, #88]	; (4002cc <freertos_twi_master_init+0x128>)
  400272:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_twi pointer was used, and a valid
	operating mode was requested. */
	if ((twi_index < MAX_TWIS) && (is_valid_operating_mode == true)) {
  400274:	e004      	b.n	400280 <freertos_twi_master_init+0xdc>
				all_twi_definitions[twi_index].peripheral_irq,
				freertos_driver_parameters->interrupt_priority);

		return_value = (freertos_twi_if) p_twi;
	} else {
		return_value = NULL;
  400276:	f04f 0900 	mov.w	r9, #0
  40027a:	e001      	b.n	400280 <freertos_twi_master_init+0xdc>
  40027c:	f04f 0900 	mov.w	r9, #0
	}

	return return_value;
}
  400280:	4648      	mov	r0, r9
  400282:	b003      	add	sp, #12
  400284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400288:	0040964c 	.word	0x0040964c
  40028c:	00400845 	.word	0x00400845
  400290:	00400875 	.word	0x00400875
  400294:	20000b0c 	.word	0x20000b0c
  400298:	004096cc 	.word	0x004096cc
  40029c:	00404489 	.word	0x00404489
  4002a0:	004096d4 	.word	0x004096d4
  4002a4:	004041a5 	.word	0x004041a5
  4002a8:	20000a8c 	.word	0x20000a8c
  4002ac:	00401299 	.word	0x00401299
  4002b0:	00401415 	.word	0x00401415
  4002b4:	00401455 	.word	0x00401455
  4002b8:	004007bd 	.word	0x004007bd
  4002bc:	004007d5 	.word	0x004007d5
  4002c0:	00400699 	.word	0x00400699
  4002c4:	004008a9 	.word	0x004008a9
  4002c8:	004007b9 	.word	0x004007b9
  4002cc:	0040095d 	.word	0x0040095d

004002d0 <freertos_twi_read_packet_async>:
 *     the PDC was successfully configured to perform the TWI read operation.
 */
status_code_t freertos_twi_read_packet_async(freertos_twi_if p_twi,
		twi_packet_t *p_packet, portTickType block_time_ticks,
		xSemaphoreHandle notification_semaphore)
{
  4002d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4002d4:	b085      	sub	sp, #20
  4002d6:	4604      	mov	r4, r0
  4002d8:	460f      	mov	r7, r1
  4002da:	9203      	str	r2, [sp, #12]
  4002dc:	4698      	mov	r8, r3
	portBASE_TYPE twi_index;
	Twi *twi_base;
	uint32_t internal_address = 0;

	twi_base = (Twi *) p_twi;
	twi_index = get_pdc_peripheral_details(all_twi_definitions, MAX_TWIS,
  4002de:	4868      	ldr	r0, [pc, #416]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  4002e0:	2108      	movs	r1, #8
  4002e2:	4622      	mov	r2, r4
  4002e4:	4b67      	ldr	r3, [pc, #412]	; (400484 <freertos_twi_read_packet_async+0x1b4>)
  4002e6:	4798      	blx	r3
  4002e8:	4606      	mov	r6, r0
			(void *) twi_base);

	/* Don't do anything unless a valid TWI pointer was used. */
	if ((twi_index < MAX_TWIS) && (p_packet->length > 0)) {
  4002ea:	2807      	cmp	r0, #7
  4002ec:	f300 80c0 	bgt.w	400470 <freertos_twi_read_packet_async+0x1a0>
  4002f0:	68fb      	ldr	r3, [r7, #12]
  4002f2:	2b00      	cmp	r3, #0
  4002f4:	f000 80be 	beq.w	400474 <freertos_twi_read_packet_async+0x1a4>
		/* Because the peripheral is half duplex, there is only one access mutex
		and the rx uses the tx mutex. */
		return_value = freertos_obtain_peripheral_access_mutex(
  4002f8:	4863      	ldr	r0, [pc, #396]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  4002fa:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
  4002fe:	a903      	add	r1, sp, #12
  400300:	4b62      	ldr	r3, [pc, #392]	; (40048c <freertos_twi_read_packet_async+0x1bc>)
  400302:	4798      	blx	r3
				&(tx_dma_control[twi_index]), &block_time_ticks);

		if (return_value == STATUS_OK) {
  400304:	4605      	mov	r5, r0
  400306:	2800      	cmp	r0, #0
  400308:	f040 80b6 	bne.w	400478 <freertos_twi_read_packet_async+0x1a8>
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);
  40030c:	4620      	mov	r0, r4
  40030e:	4b60      	ldr	r3, [pc, #384]	; (400490 <freertos_twi_read_packet_async+0x1c0>)
  400310:	4798      	blx	r3

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
  400312:	2300      	movs	r3, #0
  400314:	6063      	str	r3, [r4, #4]
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
					p_packet->chip) |
					((p_packet->addr_length <<
  400316:	687b      	ldr	r3, [r7, #4]
  400318:	021b      	lsls	r3, r3, #8
					TWI_MMR_IADRSZ_Pos) &
  40031a:	f403 7340 	and.w	r3, r3, #768	; 0x300
  40031e:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
  400322:	7c3b      	ldrb	r3, [r7, #16]
  400324:	041b      	lsls	r3, r3, #16
					p_packet->chip) |
  400326:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  40032a:	4313      	orrs	r3, r2
			/* Ensure Rx is already empty. */
			twi_read_byte(twi_base);

			/* Set read mode and slave address. */
			twi_base->TWI_MMR = 0;
			twi_base->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(
  40032c:	6063      	str	r3, [r4, #4]
					((p_packet->addr_length <<
					TWI_MMR_IADRSZ_Pos) &
					TWI_MMR_IADRSZ_Msk);

			/* Set internal address if any. */
			if (p_packet->addr_length) {
  40032e:	687a      	ldr	r2, [r7, #4]
  400330:	b15a      	cbz	r2, 40034a <freertos_twi_read_packet_async+0x7a>
				internal_address = p_packet->addr [0];
  400332:	783b      	ldrb	r3, [r7, #0]
				if (p_packet->addr_length > 1) {
  400334:	2a01      	cmp	r2, #1
					internal_address <<= 8;
					internal_address |= p_packet->addr[1];
  400336:	bf84      	itt	hi
  400338:	7879      	ldrbhi	r1, [r7, #1]
  40033a:	ea41 2303 	orrhi.w	r3, r1, r3, lsl #8
				}

				if (p_packet->addr_length > 2) {
  40033e:	2a02      	cmp	r2, #2
  400340:	d904      	bls.n	40034c <freertos_twi_read_packet_async+0x7c>
					internal_address <<= 8;
					internal_address |= p_packet->addr[2];
  400342:	78ba      	ldrb	r2, [r7, #2]
  400344:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  400348:	e000      	b.n	40034c <freertos_twi_read_packet_async+0x7c>
		xSemaphoreHandle notification_semaphore)
{
	status_code_t return_value;
	portBASE_TYPE twi_index;
	Twi *twi_base;
	uint32_t internal_address = 0;
  40034a:	2300      	movs	r3, #0
				if (p_packet->addr_length > 2) {
					internal_address <<= 8;
					internal_address |= p_packet->addr[2];
				}
			}
			twi_base->TWI_IADR = internal_address;
  40034c:	60e3      	str	r3, [r4, #12]

			if (p_packet->length <= 2) {
  40034e:	68fa      	ldr	r2, [r7, #12]
  400350:	2a02      	cmp	r2, #2
  400352:	d86b      	bhi.n	40042c <freertos_twi_read_packet_async+0x15c>
				/* Do not handle errors for short packets in interrupt handler */
				twi_disable_interrupt(
						all_twi_definitions[twi_index].peripheral_base_address,
  400354:	0133      	lsls	r3, r6, #4
  400356:	4a4a      	ldr	r2, [pc, #296]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  400358:	f852 8003 	ldr.w	r8, [r2, r3]
			}
			twi_base->TWI_IADR = internal_address;

			if (p_packet->length <= 2) {
				/* Do not handle errors for short packets in interrupt handler */
				twi_disable_interrupt(
  40035c:	4640      	mov	r0, r8
  40035e:	f44f 7150 	mov.w	r1, #832	; 0x340
  400362:	4b4c      	ldr	r3, [pc, #304]	; (400494 <freertos_twi_read_packet_async+0x1c4>)
  400364:	4798      	blx	r3
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);

				/* Cannot use PDC transfer, use normal transfer */
				uint8_t stop_sent = 0;
				uint32_t cnt = p_packet->length;
  400366:	68fb      	ldr	r3, [r7, #12]
				uint32_t status;
				uint8_t *buffer = p_packet->buffer;
  400368:	68b8      	ldr	r0, [r7, #8]
				uint32_t timeout_counter = 0;

				/* Start the transfer. */
				if (cnt == 1) {
  40036a:	2b01      	cmp	r3, #1
  40036c:	d10f      	bne.n	40038e <freertos_twi_read_packet_async+0xbe>
					twi_base->TWI_CR = TWI_CR_START | TWI_CR_STOP;
  40036e:	2203      	movs	r2, #3
  400370:	6022      	str	r2, [r4, #0]
					stop_sent = 1;
  400372:	f04f 0e01 	mov.w	lr, #1
  400376:	e7ff      	b.n	400378 <freertos_twi_read_packet_async+0xa8>
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
					status = twi_base->TWI_SR;
  400378:	6a22      	ldr	r2, [r4, #32]
					if (status & TWI_SR_NACK) {
  40037a:	f412 7f80 	tst.w	r2, #256	; 0x100
  40037e:	d111      	bne.n	4003a4 <freertos_twi_read_packet_async+0xd4>
  400380:	2100      	movs	r1, #0
						xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
						return ERR_BUSY;
					}
					/* Last byte ? */
					if (cnt == 1 && !stop_sent) {
						twi_base->TWI_CR = TWI_CR_STOP;
  400382:	f04f 0902 	mov.w	r9, #2
						stop_sent = 1;
  400386:	f04f 0c01 	mov.w	ip, #1
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
					cnt--;
					timeout_counter = 0;
  40038a:	460f      	mov	r7, r1
  40038c:	e01a      	b.n	4003c4 <freertos_twi_read_packet_async+0xf4>
				/* Start the transfer. */
				if (cnt == 1) {
					twi_base->TWI_CR = TWI_CR_START | TWI_CR_STOP;
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
  40038e:	2201      	movs	r2, #1
  400390:	6022      	str	r2, [r4, #0]
				twi_disable_interrupt(
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);

				/* Cannot use PDC transfer, use normal transfer */
				uint8_t stop_sent = 0;
  400392:	f04f 0e00 	mov.w	lr, #0
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
  400396:	2b00      	cmp	r3, #0
  400398:	d1ee      	bne.n	400378 <freertos_twi_read_packet_async+0xa8>
  40039a:	e02c      	b.n	4003f6 <freertos_twi_read_packet_async+0x126>
					status = twi_base->TWI_SR;
  40039c:	6a22      	ldr	r2, [r4, #32]
					if (status & TWI_SR_NACK) {
  40039e:	f412 7f80 	tst.w	r2, #256	; 0x100
  4003a2:	d00f      	beq.n	4003c4 <freertos_twi_read_packet_async+0xf4>
						/* Re-enable interrupts */
						twi_enable_interrupt(
  4003a4:	4640      	mov	r0, r8
  4003a6:	f44f 7150 	mov.w	r1, #832	; 0x340
  4003aa:	4b3b      	ldr	r3, [pc, #236]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  4003ac:	4798      	blx	r3
								all_twi_definitions[twi_index].peripheral_base_address,
								IER_ERROR_INTERRUPTS);
						/* Release semaphore */
						xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
  4003ae:	4b36      	ldr	r3, [pc, #216]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  4003b0:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  4003b4:	6870      	ldr	r0, [r6, #4]
  4003b6:	2100      	movs	r1, #0
  4003b8:	460a      	mov	r2, r1
  4003ba:	460b      	mov	r3, r1
  4003bc:	4c37      	ldr	r4, [pc, #220]	; (40049c <freertos_twi_read_packet_async+0x1cc>)
  4003be:	47a0      	blx	r4
						return ERR_BUSY;
  4003c0:	20f6      	movs	r0, #246	; 0xf6
  4003c2:	e059      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
					}
					/* Last byte ? */
					if (cnt == 1 && !stop_sent) {
  4003c4:	2b01      	cmp	r3, #1
  4003c6:	d105      	bne.n	4003d4 <freertos_twi_read_packet_async+0x104>
  4003c8:	f1be 0f00 	cmp.w	lr, #0
  4003cc:	d102      	bne.n	4003d4 <freertos_twi_read_packet_async+0x104>
						twi_base->TWI_CR = TWI_CR_STOP;
  4003ce:	f8c4 9000 	str.w	r9, [r4]
						stop_sent = 1;
  4003d2:	46e6      	mov	lr, ip
					}
					if (!(status & TWI_SR_RXRDY)) {
  4003d4:	f012 0f02 	tst.w	r2, #2
  4003d8:	d104      	bne.n	4003e4 <freertos_twi_read_packet_async+0x114>
						if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4003da:	3101      	adds	r1, #1
  4003dc:	f1b1 3fff 	cmp.w	r1, #4294967295
  4003e0:	d105      	bne.n	4003ee <freertos_twi_read_packet_async+0x11e>
  4003e2:	e007      	b.n	4003f4 <freertos_twi_read_packet_async+0x124>
							return_value = ERR_TIMEOUT;
							break;
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
  4003e4:	6b22      	ldr	r2, [r4, #48]	; 0x30
  4003e6:	7002      	strb	r2, [r0, #0]
					cnt--;
  4003e8:	3b01      	subs	r3, #1
							return_value = ERR_TIMEOUT;
							break;
						}
						continue;
					}
					*buffer++ = twi_base->TWI_RHR;
  4003ea:	3001      	adds	r0, #1
					cnt--;
					timeout_counter = 0;
  4003ec:	4639      	mov	r1, r7
					stop_sent = 1;
				} else {
					twi_base->TWI_CR = TWI_CR_START;
				}

				while (cnt > 0) {
  4003ee:	2b00      	cmp	r3, #0
  4003f0:	d1d4      	bne.n	40039c <freertos_twi_read_packet_async+0xcc>
  4003f2:	e000      	b.n	4003f6 <freertos_twi_read_packet_async+0x126>
						twi_base->TWI_CR = TWI_CR_STOP;
						stop_sent = 1;
					}
					if (!(status & TWI_SR_RXRDY)) {
						if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
							return_value = ERR_TIMEOUT;
  4003f4:	25fd      	movs	r5, #253	; 0xfd
					timeout_counter = 0;
				}

				timeout_counter = 0;
				/* Wait for stop to be sent */
				while (!(twi_base->TWI_SR & TWI_SR_TXCOMP)) {
  4003f6:	f04f 33ff 	mov.w	r3, #4294967295
  4003fa:	e001      	b.n	400400 <freertos_twi_read_packet_async+0x130>
					/* Check timeout condition. */
					if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4003fc:	3b01      	subs	r3, #1
  4003fe:	d004      	beq.n	40040a <freertos_twi_read_packet_async+0x13a>
					timeout_counter = 0;
				}

				timeout_counter = 0;
				/* Wait for stop to be sent */
				while (!(twi_base->TWI_SR & TWI_SR_TXCOMP)) {
  400400:	6a22      	ldr	r2, [r4, #32]
  400402:	f012 0f01 	tst.w	r2, #1
  400406:	d0f9      	beq.n	4003fc <freertos_twi_read_packet_async+0x12c>
  400408:	e000      	b.n	40040c <freertos_twi_read_packet_async+0x13c>
					/* Check timeout condition. */
					if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
						return_value = ERR_TIMEOUT;
  40040a:	25fd      	movs	r5, #253	; 0xfd
						break;
					}
				}
				/* Re-enable interrupts */
				twi_enable_interrupt(
  40040c:	4640      	mov	r0, r8
  40040e:	f44f 7150 	mov.w	r1, #832	; 0x340
  400412:	4b21      	ldr	r3, [pc, #132]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  400414:	4798      	blx	r3
						all_twi_definitions[twi_index].peripheral_base_address,
						IER_ERROR_INTERRUPTS);
				/* Release semaphores */
				xSemaphoreGive(tx_dma_control[twi_index].peripheral_access_mutex);
  400416:	4b1c      	ldr	r3, [pc, #112]	; (400488 <freertos_twi_read_packet_async+0x1b8>)
  400418:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  40041c:	6870      	ldr	r0, [r6, #4]
  40041e:	2100      	movs	r1, #0
  400420:	460a      	mov	r2, r1
  400422:	460b      	mov	r3, r1
  400424:	4c1d      	ldr	r4, [pc, #116]	; (40049c <freertos_twi_read_packet_async+0x1cc>)
  400426:	47a0      	blx	r4
  400428:	4628      	mov	r0, r5
  40042a:	e025      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
			} else {
				/* Start the PDC reception. */
				twis[twi_index].buffer = p_packet->buffer;
  40042c:	68b9      	ldr	r1, [r7, #8]
  40042e:	4b1c      	ldr	r3, [pc, #112]	; (4004a0 <freertos_twi_read_packet_async+0x1d0>)
  400430:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
				twis[twi_index].length = p_packet->length;
  400434:	00f0      	lsls	r0, r6, #3
  400436:	4403      	add	r3, r0
  400438:	605a      	str	r2, [r3, #4]
				freertos_start_pdc_rx(&(rx_dma_control[twi_index]),
  40043a:	4d1a      	ldr	r5, [pc, #104]	; (4004a4 <freertos_twi_read_packet_async+0x1d4>)
  40043c:	4405      	add	r5, r0
  40043e:	4b10      	ldr	r3, [pc, #64]	; (400480 <freertos_twi_read_packet_async+0x1b0>)
  400440:	eb03 1606 	add.w	r6, r3, r6, lsl #4
  400444:	6873      	ldr	r3, [r6, #4]
  400446:	f8cd 8000 	str.w	r8, [sp]
  40044a:	2000      	movs	r0, #0
  40044c:	9001      	str	r0, [sp, #4]
  40044e:	4628      	mov	r0, r5
  400450:	3a02      	subs	r2, #2
  400452:	4e15      	ldr	r6, [pc, #84]	; (4004a8 <freertos_twi_read_packet_async+0x1d8>)
  400454:	47b0      	blx	r6
						p_packet->buffer, (p_packet->length)-2,
						all_twi_definitions[twi_index].pdc_base_address,
						notification_semaphore);

				/* Start the transfer. */
				twi_base->TWI_CR = TWI_CR_START;
  400456:	2301      	movs	r3, #1
  400458:	6023      	str	r3, [r4, #0]
				/* Catch the end of reception so the access mutex can be returned,
				and the task notified (if it supplied a notification semaphore).
				The interrupt can be enabled here because the ENDRX	signal from the
				PDC to the peripheral will have been de-asserted when the next
				transfer was configured. */
				twi_enable_interrupt(twi_base, TWI_IER_ENDRX);
  40045a:	4620      	mov	r0, r4
  40045c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400460:	4b0d      	ldr	r3, [pc, #52]	; (400498 <freertos_twi_read_packet_async+0x1c8>)
  400462:	4798      	blx	r3

				return_value = freertos_optionally_wait_transfer_completion(
  400464:	4628      	mov	r0, r5
  400466:	4641      	mov	r1, r8
  400468:	9a03      	ldr	r2, [sp, #12]
  40046a:	4b10      	ldr	r3, [pc, #64]	; (4004ac <freertos_twi_read_packet_async+0x1dc>)
  40046c:	4798      	blx	r3
  40046e:	e003      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
						notification_semaphore,
						block_time_ticks);
			}
		}
	} else {
		return_value = ERR_INVALID_ARG;
  400470:	20f8      	movs	r0, #248	; 0xf8
  400472:	e001      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
  400474:	20f8      	movs	r0, #248	; 0xf8
  400476:	e7ff      	b.n	400478 <freertos_twi_read_packet_async+0x1a8>
	}

	return return_value;
}
  400478:	b240      	sxtb	r0, r0
  40047a:	b005      	add	sp, #20
  40047c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  400480:	0040964c 	.word	0x0040964c
  400484:	00400845 	.word	0x00400845
  400488:	20000b0c 	.word	0x20000b0c
  40048c:	00400a4d 	.word	0x00400a4d
  400490:	004007cd 	.word	0x004007cd
  400494:	004007bd 	.word	0x004007bd
  400498:	004007b9 	.word	0x004007b9
  40049c:	004027d5 	.word	0x004027d5
  4004a0:	20000acc 	.word	0x20000acc
  4004a4:	20000a8c 	.word	0x20000a8c
  4004a8:	00400a9d 	.word	0x00400a9d
  4004ac:	00400b1d 	.word	0x00400b1d

004004b0 <FLEXCOM4_Handler>:
	local_twi_handler(3);
}
#endif
#ifdef CONF_FREERTOS_USE_TWI4
void FLEXCOM4_Handler(void)
{
  4004b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4004b2:	b083      	sub	sp, #12
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  4004b4:	2300      	movs	r3, #0
  4004b6:	9301      	str	r3, [sp, #4]
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  4004b8:	4c6c      	ldr	r4, [pc, #432]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  4004ba:	4620      	mov	r0, r4
  4004bc:	4b6c      	ldr	r3, [pc, #432]	; (400670 <FLEXCOM4_Handler+0x1c0>)
  4004be:	4798      	blx	r3
  4004c0:	4605      	mov	r5, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
  4004c2:	4620      	mov	r0, r4
  4004c4:	4b6b      	ldr	r3, [pc, #428]	; (400674 <FLEXCOM4_Handler+0x1c4>)
  4004c6:	4798      	blx	r3
  4004c8:	4005      	ands	r5, r0

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  4004ca:	f415 5f00 	tst.w	r5, #8192	; 0x2000
  4004ce:	d03f      	beq.n	400550 <FLEXCOM4_Handler+0xa0>
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
  4004d0:	4869      	ldr	r0, [pc, #420]	; (400678 <FLEXCOM4_Handler+0x1c8>)
  4004d2:	f44f 7100 	mov.w	r1, #512	; 0x200
  4004d6:	4b69      	ldr	r3, [pc, #420]	; (40067c <FLEXCOM4_Handler+0x1cc>)
  4004d8:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  4004da:	4620      	mov	r0, r4
  4004dc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  4004e0:	4b67      	ldr	r3, [pc, #412]	; (400680 <FLEXCOM4_Handler+0x1d0>)
  4004e2:	4798      	blx	r3

		uint8_t status;
		uint32_t timeout_counter = 0;
  4004e4:	2400      	movs	r4, #0

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4004e6:	4a61      	ldr	r2, [pc, #388]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  4004e8:	6a13      	ldr	r3, [r2, #32]
			if (status & TWI_SR_TXRDY) {
  4004ea:	f013 0f04 	tst.w	r3, #4
  4004ee:	d105      	bne.n	4004fc <FLEXCOM4_Handler+0x4c>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4004f0:	3401      	adds	r4, #1
  4004f2:	f1b4 3fff 	cmp.w	r4, #4294967295
  4004f6:	d1f7      	bne.n	4004e8 <FLEXCOM4_Handler+0x38>
				transfer_timeout = true;
  4004f8:	2601      	movs	r6, #1
  4004fa:	e000      	b.n	4004fe <FLEXCOM4_Handler+0x4e>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  4004fc:	2600      	movs	r6, #0
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  4004fe:	4a5b      	ldr	r2, [pc, #364]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400500:	2302      	movs	r3, #2
  400502:	6013      	str	r3, [r2, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  400504:	495f      	ldr	r1, [pc, #380]	; (400684 <FLEXCOM4_Handler+0x1d4>)
  400506:	6a08      	ldr	r0, [r1, #32]
  400508:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  40050a:	4403      	add	r3, r0
  40050c:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  400510:	6353      	str	r3, [r2, #52]	; 0x34

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
  400512:	6a13      	ldr	r3, [r2, #32]
			if (status & TWI_SR_TXCOMP) {
  400514:	f013 0f01 	tst.w	r3, #1
  400518:	d104      	bne.n	400524 <FLEXCOM4_Handler+0x74>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40051a:	3401      	adds	r4, #1
  40051c:	f1b4 3fff 	cmp.w	r4, #4294967295
  400520:	d1f7      	bne.n	400512 <FLEXCOM4_Handler+0x62>
  400522:	e08f      	b.n	400644 <FLEXCOM4_Handler+0x194>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400524:	4b58      	ldr	r3, [pc, #352]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  400526:	6a58      	ldr	r0, [r3, #36]	; 0x24
  400528:	b908      	cbnz	r0, 40052e <FLEXCOM4_Handler+0x7e>
  40052a:	e005      	b.n	400538 <FLEXCOM4_Handler+0x88>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  40052c:	2601      	movs	r6, #1
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
			xSemaphoreGiveFromISR(
  40052e:	2100      	movs	r1, #0
  400530:	aa01      	add	r2, sp, #4
  400532:	460b      	mov	r3, r1
  400534:	4f55      	ldr	r7, [pc, #340]	; (40068c <FLEXCOM4_Handler+0x1dc>)
  400536:	47b8      	blx	r7
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  400538:	f1b4 3fff 	cmp.w	r4, #4294967295
  40053c:	d009      	beq.n	400552 <FLEXCOM4_Handler+0xa2>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
  40053e:	4b52      	ldr	r3, [pc, #328]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  400540:	6a18      	ldr	r0, [r3, #32]
  400542:	b130      	cbz	r0, 400552 <FLEXCOM4_Handler+0xa2>
				xSemaphoreGiveFromISR(
  400544:	2100      	movs	r1, #0
  400546:	aa01      	add	r2, sp, #4
  400548:	460b      	mov	r3, r1
  40054a:	4c50      	ldr	r4, [pc, #320]	; (40068c <FLEXCOM4_Handler+0x1dc>)
  40054c:	47a0      	blx	r4
  40054e:	e000      	b.n	400552 <FLEXCOM4_Handler+0xa2>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  400550:	2600      	movs	r6, #0
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
  400552:	f415 5f80 	tst.w	r5, #4096	; 0x1000
  400556:	d04f      	beq.n	4005f8 <FLEXCOM4_Handler+0x148>
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
  400558:	4847      	ldr	r0, [pc, #284]	; (400678 <FLEXCOM4_Handler+0x1c8>)
  40055a:	2102      	movs	r1, #2
  40055c:	4b47      	ldr	r3, [pc, #284]	; (40067c <FLEXCOM4_Handler+0x1cc>)
  40055e:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  400560:	4842      	ldr	r0, [pc, #264]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400562:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400566:	4b46      	ldr	r3, [pc, #280]	; (400680 <FLEXCOM4_Handler+0x1d0>)
  400568:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
  40056a:	2400      	movs	r4, #0

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  40056c:	4a3f      	ldr	r2, [pc, #252]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  40056e:	6a13      	ldr	r3, [r2, #32]
			if (status & TWI_SR_RXRDY) {
  400570:	f013 0f02 	tst.w	r3, #2
  400574:	d103      	bne.n	40057e <FLEXCOM4_Handler+0xce>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400576:	3401      	adds	r4, #1
  400578:	f1b4 3fff 	cmp.w	r4, #4294967295
  40057c:	d1f7      	bne.n	40056e <FLEXCOM4_Handler+0xbe>
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
  40057e:	4b3b      	ldr	r3, [pc, #236]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400580:	2202      	movs	r2, #2
  400582:	601a      	str	r2, [r3, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  400584:	4a3f      	ldr	r2, [pc, #252]	; (400684 <FLEXCOM4_Handler+0x1d4>)
  400586:	6a10      	ldr	r0, [r2, #32]
  400588:	6a51      	ldr	r1, [r2, #36]	; 0x24
  40058a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40058c:	1843      	adds	r3, r0, r1
  40058e:	f803 2c02 	strb.w	r2, [r3, #-2]

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  400592:	4a36      	ldr	r2, [pc, #216]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400594:	6a13      	ldr	r3, [r2, #32]
			if (status & TWI_SR_RXRDY) {
  400596:	f013 0f02 	tst.w	r3, #2
  40059a:	d104      	bne.n	4005a6 <FLEXCOM4_Handler+0xf6>
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40059c:	3401      	adds	r4, #1
  40059e:	f1b4 3fff 	cmp.w	r4, #4294967295
  4005a2:	d1f7      	bne.n	400594 <FLEXCOM4_Handler+0xe4>
  4005a4:	e05b      	b.n	40065e <FLEXCOM4_Handler+0x1ae>
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4005a6:	f1b4 3fff 	cmp.w	r4, #4294967295
  4005aa:	d053      	beq.n	400654 <FLEXCOM4_Handler+0x1a4>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
  4005ac:	4b2f      	ldr	r3, [pc, #188]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  4005ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4005b0:	4401      	add	r1, r0
  4005b2:	f801 3c01 	strb.w	r3, [r1, #-1]
			timeout_counter = 0;
  4005b6:	2400      	movs	r4, #0
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
  4005b8:	4a2c      	ldr	r2, [pc, #176]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  4005ba:	6a13      	ldr	r3, [r2, #32]
				if (status & TWI_SR_TXCOMP) {
  4005bc:	f013 0f01 	tst.w	r3, #1
  4005c0:	d104      	bne.n	4005cc <FLEXCOM4_Handler+0x11c>
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4005c2:	3401      	adds	r4, #1
  4005c4:	f1b4 3fff 	cmp.w	r4, #4294967295
  4005c8:	d1f7      	bne.n	4005ba <FLEXCOM4_Handler+0x10a>
  4005ca:	e042      	b.n	400652 <FLEXCOM4_Handler+0x1a2>
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  4005cc:	4b2e      	ldr	r3, [pc, #184]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  4005ce:	6a58      	ldr	r0, [r3, #36]	; 0x24
  4005d0:	b910      	cbnz	r0, 4005d8 <FLEXCOM4_Handler+0x128>
  4005d2:	e006      	b.n	4005e2 <FLEXCOM4_Handler+0x132>
  4005d4:	f04f 34ff 	mov.w	r4, #4294967295
			xSemaphoreGiveFromISR(
  4005d8:	2100      	movs	r1, #0
  4005da:	aa01      	add	r2, sp, #4
  4005dc:	460b      	mov	r3, r1
  4005de:	4f2b      	ldr	r7, [pc, #172]	; (40068c <FLEXCOM4_Handler+0x1dc>)
  4005e0:	47b8      	blx	r7
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4005e2:	f1b4 3fff 	cmp.w	r4, #4294967295
  4005e6:	d007      	beq.n	4005f8 <FLEXCOM4_Handler+0x148>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
  4005e8:	4b29      	ldr	r3, [pc, #164]	; (400690 <FLEXCOM4_Handler+0x1e0>)
  4005ea:	6a18      	ldr	r0, [r3, #32]
  4005ec:	b120      	cbz	r0, 4005f8 <FLEXCOM4_Handler+0x148>
				xSemaphoreGiveFromISR(
  4005ee:	2100      	movs	r1, #0
  4005f0:	aa01      	add	r2, sp, #4
  4005f2:	460b      	mov	r3, r1
  4005f4:	4c25      	ldr	r4, [pc, #148]	; (40068c <FLEXCOM4_Handler+0x1dc>)
  4005f6:	47a0      	blx	r4
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
  4005f8:	f415 7f50 	tst.w	r5, #832	; 0x340
  4005fc:	d100      	bne.n	400600 <FLEXCOM4_Handler+0x150>
  4005fe:	b1e6      	cbz	r6, 40063a <FLEXCOM4_Handler+0x18a>
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  400600:	481d      	ldr	r0, [pc, #116]	; (400678 <FLEXCOM4_Handler+0x1c8>)
  400602:	f240 2102 	movw	r1, #514	; 0x202
  400606:	4b1d      	ldr	r3, [pc, #116]	; (40067c <FLEXCOM4_Handler+0x1cc>)
  400608:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
  40060a:	f415 7f80 	tst.w	r5, #256	; 0x100
  40060e:	d102      	bne.n	400616 <FLEXCOM4_Handler+0x166>
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
  400610:	2202      	movs	r2, #2
  400612:	4b16      	ldr	r3, [pc, #88]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400614:	601a      	str	r2, [r3, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400616:	4d15      	ldr	r5, [pc, #84]	; (40066c <FLEXCOM4_Handler+0x1bc>)
  400618:	4628      	mov	r0, r5
  40061a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  40061e:	4c18      	ldr	r4, [pc, #96]	; (400680 <FLEXCOM4_Handler+0x1d0>)
  400620:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  400622:	4628      	mov	r0, r5
  400624:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400628:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  40062a:	4b17      	ldr	r3, [pc, #92]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  40062c:	6a58      	ldr	r0, [r3, #36]	; 0x24
  40062e:	b120      	cbz	r0, 40063a <FLEXCOM4_Handler+0x18a>
			xSemaphoreGiveFromISR(
  400630:	2100      	movs	r1, #0
  400632:	aa01      	add	r2, sp, #4
  400634:	460b      	mov	r3, r1
  400636:	4c15      	ldr	r4, [pc, #84]	; (40068c <FLEXCOM4_Handler+0x1dc>)
  400638:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  40063a:	9b01      	ldr	r3, [sp, #4]
  40063c:	b1a3      	cbz	r3, 400668 <FLEXCOM4_Handler+0x1b8>
  40063e:	4b15      	ldr	r3, [pc, #84]	; (400694 <FLEXCOM4_Handler+0x1e4>)
  400640:	4798      	blx	r3
  400642:	e011      	b.n	400668 <FLEXCOM4_Handler+0x1b8>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400644:	4b10      	ldr	r3, [pc, #64]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  400646:	6a58      	ldr	r0, [r3, #36]	; 0x24
  400648:	2800      	cmp	r0, #0
  40064a:	f47f af6f 	bne.w	40052c <FLEXCOM4_Handler+0x7c>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  40064e:	2601      	movs	r6, #1
  400650:	e77f      	b.n	400552 <FLEXCOM4_Handler+0xa2>
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
					transfer_timeout = true;
  400652:	2601      	movs	r6, #1
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400654:	4b0c      	ldr	r3, [pc, #48]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  400656:	6a58      	ldr	r0, [r3, #36]	; 0x24
  400658:	2800      	cmp	r0, #0
  40065a:	d1bb      	bne.n	4005d4 <FLEXCOM4_Handler+0x124>
  40065c:	e7cc      	b.n	4005f8 <FLEXCOM4_Handler+0x148>
  40065e:	4b0a      	ldr	r3, [pc, #40]	; (400688 <FLEXCOM4_Handler+0x1d8>)
  400660:	6a58      	ldr	r0, [r3, #36]	; 0x24
  400662:	2800      	cmp	r0, #0
  400664:	d1b8      	bne.n	4005d8 <FLEXCOM4_Handler+0x128>
  400666:	e7c7      	b.n	4005f8 <FLEXCOM4_Handler+0x148>
#endif
#ifdef CONF_FREERTOS_USE_TWI4
void FLEXCOM4_Handler(void)
{
	local_twi_handler(4);
}
  400668:	b003      	add	sp, #12
  40066a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40066c:	4001c600 	.word	0x4001c600
  400670:	004007c5 	.word	0x004007c5
  400674:	004007c9 	.word	0x004007c9
  400678:	4001c700 	.word	0x4001c700
  40067c:	00401455 	.word	0x00401455
  400680:	004007bd 	.word	0x004007bd
  400684:	20000acc 	.word	0x20000acc
  400688:	20000b0c 	.word	0x20000b0c
  40068c:	0040296d 	.word	0x0040296d
  400690:	20000a8c 	.word	0x20000a8c
  400694:	00402305 	.word	0x00402305

00400698 <twi_enable_master_mode>:
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  400698:	2308      	movs	r3, #8
  40069a:	6003      	str	r3, [r0, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  40069c:	2320      	movs	r3, #32
  40069e:	6003      	str	r3, [r0, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4006a0:	2304      	movs	r3, #4
  4006a2:	6003      	str	r3, [r0, #0]
  4006a4:	4770      	bx	lr
  4006a6:	bf00      	nop

004006a8 <twi_set_speed>:
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  4006a8:	4b0f      	ldr	r3, [pc, #60]	; (4006e8 <twi_set_speed+0x40>)
  4006aa:	4299      	cmp	r1, r3
  4006ac:	d819      	bhi.n	4006e2 <twi_set_speed+0x3a>
		return FAIL;
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  4006ae:	0049      	lsls	r1, r1, #1
  4006b0:	fbb2 f2f1 	udiv	r2, r2, r1
  4006b4:	3a04      	subs	r2, #4

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4006b6:	2aff      	cmp	r2, #255	; 0xff
  4006b8:	d907      	bls.n	4006ca <twi_set_speed+0x22>
  4006ba:	2300      	movs	r3, #0
		/* Increase clock divider */
		ckdiv++;
  4006bc:	3301      	adds	r3, #1
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
  4006be:	0852      	lsrs	r2, r2, #1
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4006c0:	2aff      	cmp	r2, #255	; 0xff
  4006c2:	d903      	bls.n	4006cc <twi_set_speed+0x24>
  4006c4:	2b07      	cmp	r3, #7
  4006c6:	d1f9      	bne.n	4006bc <twi_set_speed+0x14>
  4006c8:	e000      	b.n	4006cc <twi_set_speed+0x24>
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
	uint32_t ckdiv = 0;
  4006ca:	2300      	movs	r3, #0
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4006cc:	0211      	lsls	r1, r2, #8
  4006ce:	b289      	uxth	r1, r1
			TWI_CWGR_CKDIV(ckdiv);
  4006d0:	041b      	lsls	r3, r3, #16
  4006d2:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
  4006d6:	430b      	orrs	r3, r1
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4006d8:	b2d2      	uxtb	r2, r2
  4006da:	431a      	orrs	r2, r3
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
  4006dc:	6102      	str	r2, [r0, #16]
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
			TWI_CWGR_CKDIV(ckdiv);

	return PASS;
  4006de:	2000      	movs	r0, #0
  4006e0:	4770      	bx	lr
{
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
		return FAIL;
  4006e2:	2001      	movs	r0, #1
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
			TWI_CWGR_CKDIV(ckdiv);

	return PASS;
}
  4006e4:	4770      	bx	lr
  4006e6:	bf00      	nop
  4006e8:	00061a80 	.word	0x00061a80

004006ec <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  4006ec:	4603      	mov	r3, r0
	uint32_t status;
	uint32_t cnt = p_packet->length;
  4006ee:	68ca      	ldr	r2, [r1, #12]
	uint8_t *buffer = p_packet->buffer;
  4006f0:	6888      	ldr	r0, [r1, #8]

	/* Check argument */
	if (cnt == 0) {
  4006f2:	2a00      	cmp	r2, #0
  4006f4:	d040      	beq.n	400778 <twi_master_write+0x8c>
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  4006f6:	b470      	push	{r4, r5, r6}
	if (cnt == 0) {
		return TWI_INVALID_ARGUMENT;
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  4006f8:	2600      	movs	r6, #0
  4006fa:	605e      	str	r6, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  4006fc:	7c0c      	ldrb	r4, [r1, #16]
  4006fe:	0424      	lsls	r4, r4, #16
  400700:	f404 05fe 	and.w	r5, r4, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  400704:	684c      	ldr	r4, [r1, #4]
  400706:	0224      	lsls	r4, r4, #8
  400708:	f404 7440 	and.w	r4, r4, #768	; 0x300
		return TWI_INVALID_ARGUMENT;
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  40070c:	432c      	orrs	r4, r5
  40070e:	605c      	str	r4, [r3, #4]
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400710:	60de      	str	r6, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400712:	684d      	ldr	r5, [r1, #4]
 */
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
	uint32_t val;

	if (len == 0)
  400714:	b15d      	cbz	r5, 40072e <twi_master_write+0x42>
		return 0;

	val = addr[0];
  400716:	780c      	ldrb	r4, [r1, #0]
	if (len > 1) {
  400718:	2d01      	cmp	r5, #1
		val <<= 8;
		val |= addr[1];
  40071a:	bfc4      	itt	gt
  40071c:	784e      	ldrbgt	r6, [r1, #1]
  40071e:	ea46 2404 	orrgt.w	r4, r6, r4, lsl #8
	}
	if (len > 2) {
  400722:	2d02      	cmp	r5, #2
  400724:	dd04      	ble.n	400730 <twi_master_write+0x44>
		val <<= 8;
		val |= addr[2];
  400726:	7889      	ldrb	r1, [r1, #2]
  400728:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
  40072c:	e000      	b.n	400730 <twi_master_write+0x44>
static uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
	uint32_t val;

	if (len == 0)
		return 0;
  40072e:	2400      	movs	r4, #0
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400730:	60dc      	str	r4, [r3, #12]
  400732:	e00b      	b.n	40074c <twi_master_write+0x60>

	/* Send all bytes */
	while (cnt > 0) {
		status = p_twi->TWI_SR;
  400734:	6a19      	ldr	r1, [r3, #32]
		if (status & TWI_SR_NACK) {
  400736:	f411 7f80 	tst.w	r1, #256	; 0x100
  40073a:	d11f      	bne.n	40077c <twi_master_write+0x90>
			return TWI_RECEIVE_NACK;
		}

		if (!(status & TWI_SR_TXRDY)) {
  40073c:	f011 0f04 	tst.w	r1, #4
  400740:	d0f8      	beq.n	400734 <twi_master_write+0x48>
			continue;
		}
		p_twi->TWI_THR = *buffer++;
  400742:	f810 1b01 	ldrb.w	r1, [r0], #1
  400746:	6359      	str	r1, [r3, #52]	; 0x34
	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);

	/* Send all bytes */
	while (cnt > 0) {
  400748:	3a01      	subs	r2, #1
  40074a:	d007      	beq.n	40075c <twi_master_write+0x70>
		status = p_twi->TWI_SR;
  40074c:	6a19      	ldr	r1, [r3, #32]
		if (status & TWI_SR_NACK) {
  40074e:	f411 7f80 	tst.w	r1, #256	; 0x100
  400752:	d115      	bne.n	400780 <twi_master_write+0x94>
			return TWI_RECEIVE_NACK;
		}

		if (!(status & TWI_SR_TXRDY)) {
  400754:	f011 0f04 	tst.w	r1, #4
  400758:	d0ec      	beq.n	400734 <twi_master_write+0x48>
  40075a:	e7f2      	b.n	400742 <twi_master_write+0x56>

		cnt--;
	}

	while (1) {
		status = p_twi->TWI_SR;
  40075c:	6a1a      	ldr	r2, [r3, #32]
		if (status & TWI_SR_NACK) {
  40075e:	f412 7080 	ands.w	r0, r2, #256	; 0x100
  400762:	d10f      	bne.n	400784 <twi_master_write+0x98>
			return TWI_RECEIVE_NACK;
		}

		if (status & TWI_SR_TXRDY) {
  400764:	f012 0f04 	tst.w	r2, #4
  400768:	d0f8      	beq.n	40075c <twi_master_write+0x70>
			break;
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  40076a:	2202      	movs	r2, #2
  40076c:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  40076e:	6a1a      	ldr	r2, [r3, #32]
  400770:	f012 0f01 	tst.w	r2, #1
  400774:	d0fb      	beq.n	40076e <twi_master_write+0x82>
  400776:	e006      	b.n	400786 <twi_master_write+0x9a>
	uint32_t cnt = p_packet->length;
	uint8_t *buffer = p_packet->buffer;

	/* Check argument */
	if (cnt == 0) {
		return TWI_INVALID_ARGUMENT;
  400778:	2001      	movs	r0, #1

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
	}

	return TWI_SUCCESS;
}
  40077a:	4770      	bx	lr

	/* Send all bytes */
	while (cnt > 0) {
		status = p_twi->TWI_SR;
		if (status & TWI_SR_NACK) {
			return TWI_RECEIVE_NACK;
  40077c:	2005      	movs	r0, #5
  40077e:	e002      	b.n	400786 <twi_master_write+0x9a>
  400780:	2005      	movs	r0, #5
  400782:	e000      	b.n	400786 <twi_master_write+0x9a>
	}

	while (1) {
		status = p_twi->TWI_SR;
		if (status & TWI_SR_NACK) {
			return TWI_RECEIVE_NACK;
  400784:	2005      	movs	r0, #5

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
	}

	return TWI_SUCCESS;
}
  400786:	bc70      	pop	{r4, r5, r6}
  400788:	4770      	bx	lr
  40078a:	bf00      	nop

0040078c <twi_probe>:
 * \param uc_slave_addr Address of the remote chip to search for.
 *
 * \return TWI_SUCCESS if a chip was found, error code otherwise.
 */
uint32_t twi_probe(Twi *p_twi, uint8_t uc_slave_addr)
{
  40078c:	b500      	push	{lr}
  40078e:	b087      	sub	sp, #28
	twi_packet_t packet;
	uint8_t data = 0;
  400790:	2300      	movs	r3, #0
  400792:	aa06      	add	r2, sp, #24
  400794:	f802 3d15 	strb.w	r3, [r2, #-21]!

	/* Data to send */
	packet.buffer = &data;
  400798:	9203      	str	r2, [sp, #12]
	/* Data length */
	packet.length = 1;
  40079a:	2201      	movs	r2, #1
  40079c:	9204      	str	r2, [sp, #16]
	/* Slave chip address */
	packet.chip = (uint32_t) uc_slave_addr;
  40079e:	f88d 1014 	strb.w	r1, [sp, #20]
	/* Internal chip address */
	packet.addr[0] = 0;
  4007a2:	f88d 3004 	strb.w	r3, [sp, #4]
	/* Address length */
	packet.addr_length = 0;
  4007a6:	9302      	str	r3, [sp, #8]

	/* Perform a master write access */
	return (twi_master_write(p_twi, &packet));
  4007a8:	a901      	add	r1, sp, #4
  4007aa:	4b02      	ldr	r3, [pc, #8]	; (4007b4 <twi_probe+0x28>)
  4007ac:	4798      	blx	r3
}
  4007ae:	b007      	add	sp, #28
  4007b0:	f85d fb04 	ldr.w	pc, [sp], #4
  4007b4:	004006ed 	.word	0x004006ed

004007b8 <twi_enable_interrupt>:
 * \param ul_sources Interrupts to be enabled.
 */
void twi_enable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Enable the specified interrupts */
	p_twi->TWI_IER = ul_sources;
  4007b8:	6241      	str	r1, [r0, #36]	; 0x24
  4007ba:	4770      	bx	lr

004007bc <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4007bc:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4007be:	6a03      	ldr	r3, [r0, #32]
  4007c0:	4770      	bx	lr
  4007c2:	bf00      	nop

004007c4 <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
  4007c4:	6a00      	ldr	r0, [r0, #32]
}
  4007c6:	4770      	bx	lr

004007c8 <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
  4007c8:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  4007ca:	4770      	bx	lr

004007cc <twi_read_byte>:
 *
 * \return The byte read.
 */
uint8_t twi_read_byte(Twi *p_twi)
{
	return p_twi->TWI_RHR;
  4007cc:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
  4007ce:	b2c0      	uxtb	r0, r0
  4007d0:	4770      	bx	lr
  4007d2:	bf00      	nop

004007d4 <twi_reset>:
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  4007d4:	2380      	movs	r3, #128	; 0x80
  4007d6:	6003      	str	r3, [r0, #0]
	p_twi->TWI_RHR;
  4007d8:	6b03      	ldr	r3, [r0, #48]	; 0x30
  4007da:	4770      	bx	lr

004007dc <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE
#endif

void sysclk_init(void)
{
  4007dc:	b510      	push	{r4, lr}
	uint32_t unique_id[32];
	uint32_t trim_value;
#endif

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  4007de:	480e      	ldr	r0, [pc, #56]	; (400818 <sysclk_init+0x3c>)
  4007e0:	4b0e      	ldr	r3, [pc, #56]	; (40081c <sysclk_init+0x40>)
  4007e2:	4798      	blx	r3
	switch (ul_id) {
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  4007e4:	2000      	movs	r0, #0
  4007e6:	4b0e      	ldr	r3, [pc, #56]	; (400820 <sysclk_init+0x44>)
  4007e8:	4798      	blx	r3
	case OSC_SLCK_32K_RC:
		return 1;

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
  4007ea:	4c0e      	ldr	r4, [pc, #56]	; (400824 <sysclk_init+0x48>)
  4007ec:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4007ee:	2800      	cmp	r0, #0
  4007f0:	d0fc      	beq.n	4007ec <sysclk_init+0x10>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4007f2:	4b0d      	ldr	r3, [pc, #52]	; (400828 <sysclk_init+0x4c>)
  4007f4:	4798      	blx	r3
		PMC->CKGR_PLLAR = p_cfg->ctrl;
  4007f6:	4a0d      	ldr	r2, [pc, #52]	; (40082c <sysclk_init+0x50>)
  4007f8:	4b0d      	ldr	r3, [pc, #52]	; (400830 <sysclk_init+0x54>)
  4007fa:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4007fc:	4c0d      	ldr	r4, [pc, #52]	; (400834 <sysclk_init+0x58>)
  4007fe:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  400800:	2800      	cmp	r0, #0
  400802:	d0fc      	beq.n	4007fe <sysclk_init+0x22>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  400804:	2000      	movs	r0, #0
  400806:	4b0c      	ldr	r3, [pc, #48]	; (400838 <sysclk_init+0x5c>)
  400808:	4798      	blx	r3
	}
#endif
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  40080a:	4b0c      	ldr	r3, [pc, #48]	; (40083c <sysclk_init+0x60>)
  40080c:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40080e:	480c      	ldr	r0, [pc, #48]	; (400840 <sysclk_init+0x64>)
  400810:	4b02      	ldr	r3, [pc, #8]	; (40081c <sysclk_init+0x40>)
  400812:	4798      	blx	r3
  400814:	bd10      	pop	{r4, pc}
  400816:	bf00      	nop
  400818:	07270e00 	.word	0x07270e00
  40081c:	004018d9 	.word	0x004018d9
  400820:	004014cd 	.word	0x004014cd
  400824:	004014f1 	.word	0x004014f1
  400828:	00401511 	.word	0x00401511
  40082c:	0e4d3f01 	.word	0x0e4d3f01
  400830:	400e0400 	.word	0x400e0400
  400834:	0040151d 	.word	0x0040151d
  400838:	00401465 	.word	0x00401465
  40083c:	004017f1 	.word	0x004017f1
  400840:	07270000 	.word	0x07270000

00400844 <get_pdc_peripheral_details>:
 * peripheral that has the start address specified by peripheral_to_find.
 */
portBASE_TYPE get_pdc_peripheral_details(
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
  400844:	b430      	push	{r4, r5}
	size_t x;

	for (x = 0; x < array_size; x++) {
  400846:	460d      	mov	r5, r1
  400848:	b181      	cbz	r1, 40086c <get_pdc_peripheral_details+0x28>
		if (peripheral_array[x].peripheral_base_address ==
  40084a:	6803      	ldr	r3, [r0, #0]
  40084c:	4293      	cmp	r3, r2
  40084e:	d00a      	beq.n	400866 <get_pdc_peripheral_details+0x22>
  400850:	4601      	mov	r1, r0
  400852:	2300      	movs	r3, #0
  400854:	e003      	b.n	40085e <get_pdc_peripheral_details+0x1a>
  400856:	f851 4f10 	ldr.w	r4, [r1, #16]!
  40085a:	4294      	cmp	r4, r2
  40085c:	d005      	beq.n	40086a <get_pdc_peripheral_details+0x26>
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
	size_t x;

	for (x = 0; x < array_size; x++) {
  40085e:	3301      	adds	r3, #1
  400860:	42ab      	cmp	r3, r5
  400862:	d1f8      	bne.n	400856 <get_pdc_peripheral_details+0x12>
  400864:	e002      	b.n	40086c <get_pdc_peripheral_details+0x28>
  400866:	2500      	movs	r5, #0
  400868:	e000      	b.n	40086c <get_pdc_peripheral_details+0x28>
  40086a:	461d      	mov	r5, r3
			break;
		}
	}

	return x;
}
  40086c:	4628      	mov	r0, r5
  40086e:	bc30      	pop	{r4, r5}
  400870:	4770      	bx	lr
  400872:	bf00      	nop

00400874 <check_requested_operating_mode>:
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
  400874:	2a00      	cmp	r2, #0
  400876:	dd0e      	ble.n	400896 <check_requested_operating_mode+0x22>
			index_position++) {
		if (requested_operation_mode ==
  400878:	780b      	ldrb	r3, [r1, #0]
  40087a:	4283      	cmp	r3, r0
  40087c:	d00d      	beq.n	40089a <check_requested_operating_mode+0x26>
 */
bool check_requested_operating_mode(
		const enum peripheral_operation_mode requested_operation_mode,
		const enum peripheral_operation_mode valid_operating_modes[],
		portBASE_TYPE num_valid_operating_modes)
{
  40087e:	b410      	push	{r4}
  400880:	1c4b      	adds	r3, r1, #1
  400882:	4411      	add	r1, r2
  400884:	e003      	b.n	40088e <check_requested_operating_mode+0x1a>
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
			index_position++) {
		if (requested_operation_mode ==
  400886:	f813 4b01 	ldrb.w	r4, [r3], #1
  40088a:	4284      	cmp	r4, r0
  40088c:	d007      	beq.n	40089e <check_requested_operating_mode+0x2a>
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
  40088e:	428b      	cmp	r3, r1
  400890:	d1f9      	bne.n	400886 <check_requested_operating_mode+0x12>
bool check_requested_operating_mode(
		const enum peripheral_operation_mode requested_operation_mode,
		const enum peripheral_operation_mode valid_operating_modes[],
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
  400892:	2000      	movs	r0, #0
  400894:	e004      	b.n	4008a0 <check_requested_operating_mode+0x2c>
  400896:	2000      	movs	r0, #0
			break;
		}
	}

	return return_value;
}
  400898:	4770      	bx	lr

	for (index_position = 0; index_position < num_valid_operating_modes;
			index_position++) {
		if (requested_operation_mode ==
				valid_operating_modes[index_position]) {
			return_value = true;
  40089a:	2001      	movs	r0, #1
  40089c:	4770      	bx	lr
  40089e:	2001      	movs	r0, #1
			break;
		}
	}

	return return_value;
}
  4008a0:	f85d 4b04 	ldr.w	r4, [sp], #4
  4008a4:	4770      	bx	lr
  4008a6:	bf00      	nop

004008a8 <create_peripheral_control_semaphores>:
 * with the bits set in the options_flags value.
 */
void create_peripheral_control_semaphores(const uint8_t options_flags,
		freertos_dma_event_control_t *tx_dma_control,
		freertos_dma_event_control_t *rx_dma_control)
{
  4008a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4008aa:	4604      	mov	r4, r0
  4008ac:	460e      	mov	r6, r1
  4008ae:	4615      	mov	r5, r2
	/* If the tx driver is to be thread aware then create an access control
	mutex.  An Rx access mutex is not created in this function as half duplex
	peripherals need only use a single access mutex, and the Tx mutex is used
	for the purpose.  Full duplex peripherals have extra configuration steps
	that are performed separately. */
	if ((options_flags & USE_TX_ACCESS_MUTEX) != 0) {
  4008b0:	f010 0f01 	tst.w	r0, #1
  4008b4:	d008      	beq.n	4008c8 <create_peripheral_control_semaphores+0x20>
		tx_dma_control->peripheral_access_mutex = xSemaphoreCreateMutex();
  4008b6:	2001      	movs	r0, #1
  4008b8:	4b22      	ldr	r3, [pc, #136]	; (400944 <create_peripheral_control_semaphores+0x9c>)
  4008ba:	4798      	blx	r3
  4008bc:	6070      	str	r0, [r6, #4]
		configASSERT(tx_dma_control->peripheral_access_mutex);
  4008be:	b918      	cbnz	r0, 4008c8 <create_peripheral_control_semaphores+0x20>
  4008c0:	4821      	ldr	r0, [pc, #132]	; (400948 <create_peripheral_control_semaphores+0xa0>)
  4008c2:	217a      	movs	r1, #122	; 0x7a
  4008c4:	4b21      	ldr	r3, [pc, #132]	; (40094c <create_peripheral_control_semaphores+0xa4>)
  4008c6:	4798      	blx	r3
	}

	/* If the transmit function is only going to return once the transmit is
	complete then create an internal notification semaphore. */
	if ((options_flags & WAIT_TX_COMPLETE) != 0) {
  4008c8:	f014 0f04 	tst.w	r4, #4
  4008cc:	d018      	beq.n	400900 <create_peripheral_control_semaphores+0x58>
		vSemaphoreCreateBinary(
  4008ce:	2001      	movs	r0, #1
  4008d0:	2100      	movs	r1, #0
  4008d2:	2203      	movs	r2, #3
  4008d4:	4b1e      	ldr	r3, [pc, #120]	; (400950 <create_peripheral_control_semaphores+0xa8>)
  4008d6:	4798      	blx	r3
  4008d8:	6030      	str	r0, [r6, #0]
  4008da:	b130      	cbz	r0, 4008ea <create_peripheral_control_semaphores+0x42>
  4008dc:	2100      	movs	r1, #0
  4008de:	460a      	mov	r2, r1
  4008e0:	460b      	mov	r3, r1
  4008e2:	4f1c      	ldr	r7, [pc, #112]	; (400954 <create_peripheral_control_semaphores+0xac>)
  4008e4:	47b8      	blx	r7
				tx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
  4008e6:	6833      	ldr	r3, [r6, #0]
  4008e8:	b91b      	cbnz	r3, 4008f2 <create_peripheral_control_semaphores+0x4a>
  4008ea:	4817      	ldr	r0, [pc, #92]	; (400948 <create_peripheral_control_semaphores+0xa0>)
  4008ec:	2183      	movs	r1, #131	; 0x83
  4008ee:	4b17      	ldr	r3, [pc, #92]	; (40094c <create_peripheral_control_semaphores+0xa4>)
  4008f0:	4798      	blx	r3
				tx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created). */
		xSemaphoreTake(
  4008f2:	6830      	ldr	r0, [r6, #0]
  4008f4:	2100      	movs	r1, #0
  4008f6:	460a      	mov	r2, r1
  4008f8:	460b      	mov	r3, r1
  4008fa:	4e17      	ldr	r6, [pc, #92]	; (400958 <create_peripheral_control_semaphores+0xb0>)
  4008fc:	47b0      	blx	r6
  4008fe:	e001      	b.n	400904 <create_peripheral_control_semaphores+0x5c>
				tx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		tx_dma_control->transaction_complete_notification_semaphore = NULL;
  400900:	2300      	movs	r3, #0
  400902:	6033      	str	r3, [r6, #0]
	}

	/* If the receive function is only going to return once the receive
	is complete then create an internal notification semaphore. */
	if (((options_flags & WAIT_RX_COMPLETE) != 0) &&
  400904:	f014 0f08 	tst.w	r4, #8
  400908:	d019      	beq.n	40093e <create_peripheral_control_semaphores+0x96>
  40090a:	b1c5      	cbz	r5, 40093e <create_peripheral_control_semaphores+0x96>
			(rx_dma_control != NULL)) {
		vSemaphoreCreateBinary(
  40090c:	2001      	movs	r0, #1
  40090e:	2100      	movs	r1, #0
  400910:	2203      	movs	r2, #3
  400912:	4b0f      	ldr	r3, [pc, #60]	; (400950 <create_peripheral_control_semaphores+0xa8>)
  400914:	4798      	blx	r3
  400916:	6028      	str	r0, [r5, #0]
  400918:	b130      	cbz	r0, 400928 <create_peripheral_control_semaphores+0x80>
  40091a:	2100      	movs	r1, #0
  40091c:	460a      	mov	r2, r1
  40091e:	460b      	mov	r3, r1
  400920:	4c0c      	ldr	r4, [pc, #48]	; (400954 <create_peripheral_control_semaphores+0xac>)
  400922:	47a0      	blx	r4
				rx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
  400924:	682b      	ldr	r3, [r5, #0]
  400926:	b91b      	cbnz	r3, 400930 <create_peripheral_control_semaphores+0x88>
  400928:	4807      	ldr	r0, [pc, #28]	; (400948 <create_peripheral_control_semaphores+0xa0>)
  40092a:	2196      	movs	r1, #150	; 0x96
  40092c:	4b07      	ldr	r3, [pc, #28]	; (40094c <create_peripheral_control_semaphores+0xa4>)
  40092e:	4798      	blx	r3
				rx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created. */
		xSemaphoreTake(
  400930:	6828      	ldr	r0, [r5, #0]
  400932:	2100      	movs	r1, #0
  400934:	460a      	mov	r2, r1
  400936:	460b      	mov	r3, r1
  400938:	4c07      	ldr	r4, [pc, #28]	; (400958 <create_peripheral_control_semaphores+0xb0>)
  40093a:	47a0      	blx	r4
  40093c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				rx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		rx_dma_control->transaction_complete_notification_semaphore = NULL;
  40093e:	2300      	movs	r3, #0
  400940:	602b      	str	r3, [r5, #0]
  400942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400944:	00402905 	.word	0x00402905
  400948:	00409714 	.word	0x00409714
  40094c:	004041a5 	.word	0x004041a5
  400950:	00402745 	.word	0x00402745
  400954:	004027d5 	.word	0x004027d5
  400958:	00402a09 	.word	0x00402a09

0040095c <configure_interrupt_controller>:
 * Configure the NVIC to enable, and set the priority of, the interrupt
 * specified by peripheral_irq.
 */
void configure_interrupt_controller(const enum IRQn peripheral_irq,
		uint32_t interrupt_priority)
{
  40095c:	b538      	push	{r3, r4, r5, lr}
  40095e:	4604      	mov	r4, r0
  400960:	460d      	mov	r5, r1
	configASSERT(interrupt_priority <=
  400962:	290f      	cmp	r1, #15
  400964:	d903      	bls.n	40096e <configure_interrupt_controller+0x12>
  400966:	4815      	ldr	r0, [pc, #84]	; (4009bc <configure_interrupt_controller+0x60>)
  400968:	21ac      	movs	r1, #172	; 0xac
  40096a:	4b15      	ldr	r3, [pc, #84]	; (4009c0 <configure_interrupt_controller+0x64>)
  40096c:	4798      	blx	r3
            configLIBRARY_LOWEST_INTERRUPT_PRIORITY);
	configASSERT(interrupt_priority >=
  40096e:	2d09      	cmp	r5, #9
  400970:	d803      	bhi.n	40097a <configure_interrupt_controller+0x1e>
  400972:	4812      	ldr	r0, [pc, #72]	; (4009bc <configure_interrupt_controller+0x60>)
  400974:	21ae      	movs	r1, #174	; 0xae
  400976:	4b12      	ldr	r3, [pc, #72]	; (4009c0 <configure_interrupt_controller+0x64>)
  400978:	4798      	blx	r3

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40097a:	b2e1      	uxtb	r1, r4
  40097c:	f001 031f 	and.w	r3, r1, #31
  400980:	2201      	movs	r2, #1
  400982:	409a      	lsls	r2, r3
  400984:	0963      	lsrs	r3, r4, #5
  400986:	009b      	lsls	r3, r3, #2
  400988:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  40098c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  400990:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
  400994:	2c00      	cmp	r4, #0
  400996:	da06      	bge.n	4009a6 <configure_interrupt_controller+0x4a>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  400998:	f001 010f 	and.w	r1, r1, #15
  40099c:	012d      	lsls	r5, r5, #4
  40099e:	b2ed      	uxtb	r5, r5
  4009a0:	4808      	ldr	r0, [pc, #32]	; (4009c4 <configure_interrupt_controller+0x68>)
  4009a2:	5445      	strb	r5, [r0, r1]
  4009a4:	e007      	b.n	4009b6 <configure_interrupt_controller+0x5a>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4009a6:	012d      	lsls	r5, r5, #4
  4009a8:	b2ed      	uxtb	r5, r5
  4009aa:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  4009ae:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
  4009b2:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4009b6:	601a      	str	r2, [r3, #0]
  4009b8:	bd38      	pop	{r3, r4, r5, pc}
  4009ba:	bf00      	nop
  4009bc:	00409714 	.word	0x00409714
  4009c0:	004041a5 	.word	0x004041a5
  4009c4:	e000ed14 	.word	0xe000ed14

004009c8 <freertos_copy_bytes_from_pdc_circular_buffer>:
 */
uint32_t freertos_copy_bytes_from_pdc_circular_buffer(
		freertos_pdc_rx_control_t *p_rx_buffer_details,
		uint32_t next_byte_to_be_written, uint8_t *buf,
		uint32_t bytes_to_read)
{
  4009c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4009cc:	4606      	mov	r6, r0
  4009ce:	4690      	mov	r8, r2
  4009d0:	461f      	mov	r7, r3
	uint32_t number_of_bytes_available, next_byte_to_read;

	/* Locate the position that data will be read from next. */
	next_byte_to_read = (uint32_t) p_rx_buffer_details->next_byte_to_read;
  4009d2:	6985      	ldr	r5, [r0, #24]

	if (next_byte_to_be_written == next_byte_to_read) {
  4009d4:	42a9      	cmp	r1, r5
  4009d6:	d104      	bne.n	4009e2 <freertos_copy_bytes_from_pdc_circular_buffer+0x1a>
		if (p_rx_buffer_details->rx_pdc_parameters.ul_size == 0) {
  4009d8:	68c3      	ldr	r3, [r0, #12]
  4009da:	b943      	cbnz	r3, 4009ee <freertos_copy_bytes_from_pdc_circular_buffer+0x26>
			/* The read and write pointers are equal, but as the Rx DMA has been
			stopped, the buffer must be full, not empty.  Data from the read
			pointer up to the end of the buffer is available. */
			number_of_bytes_available =
  4009dc:	6844      	ldr	r4, [r0, #4]
  4009de:	1a64      	subs	r4, r4, r1
  4009e0:	e006      	b.n	4009f0 <freertos_copy_bytes_from_pdc_circular_buffer+0x28>
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
		}
	} else if (next_byte_to_be_written > next_byte_to_read) {
  4009e2:	428d      	cmp	r5, r1
		/* The write pointer has not wrapped around from the read pointer, or
		the write and read pointer are the same indicating a buffer overflow.
		Calculate the bytes available between the write and read pointers. */
		number_of_bytes_available = next_byte_to_be_written -
  4009e4:	bf32      	itee	cc
  4009e6:	1b4c      	subcc	r4, r1, r5
				next_byte_to_read;
	} else {
		/* The write pointer has wrapped around from the read pointer.
		Calculate the bytes available between the end of the buffer and the
		read pointer. */
		number_of_bytes_available =
  4009e8:	6844      	ldrcs	r4, [r0, #4]
  4009ea:	1b64      	subcs	r4, r4, r5
  4009ec:	e000      	b.n	4009f0 <freertos_copy_bytes_from_pdc_circular_buffer+0x28>
					p_rx_buffer_details->past_rx_buffer_end_address
					- next_byte_to_read;
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
  4009ee:	2400      	movs	r4, #0
				p_rx_buffer_details->past_rx_buffer_end_address
				- next_byte_to_read;
	}

	/* Cap the number of requested bytes to those available. */
	if (bytes_to_read > number_of_bytes_available) {
  4009f0:	42bc      	cmp	r4, r7
  4009f2:	d30a      	bcc.n	400a0a <freertos_copy_bytes_from_pdc_circular_buffer+0x42>
		bytes_to_read = number_of_bytes_available;
	} else if (bytes_to_read != number_of_bytes_available) {
  4009f4:	42a7      	cmp	r7, r4
  4009f6:	d007      	beq.n	400a08 <freertos_copy_bytes_from_pdc_circular_buffer+0x40>
		/* There are more bytes available than being read now, so there is no
		need to wait for the interrupt to give the semaphore to indicate that
		new data is available. */
		xSemaphoreGive(p_rx_buffer_details->rx_event_semaphore);
  4009f8:	6930      	ldr	r0, [r6, #16]
  4009fa:	2100      	movs	r1, #0
  4009fc:	460a      	mov	r2, r1
  4009fe:	460b      	mov	r3, r1
  400a00:	4c0e      	ldr	r4, [pc, #56]	; (400a3c <freertos_copy_bytes_from_pdc_circular_buffer+0x74>)
  400a02:	47a0      	blx	r4
  400a04:	463c      	mov	r4, r7
  400a06:	e000      	b.n	400a0a <freertos_copy_bytes_from_pdc_circular_buffer+0x42>
  400a08:	463c      	mov	r4, r7
	}

	/* Copy the bytes into the user buffer. */
	memcpy(buf, (void *) p_rx_buffer_details->next_byte_to_read,
  400a0a:	4640      	mov	r0, r8
  400a0c:	69b1      	ldr	r1, [r6, #24]
  400a0e:	4622      	mov	r2, r4
  400a10:	4b0b      	ldr	r3, [pc, #44]	; (400a40 <freertos_copy_bytes_from_pdc_circular_buffer+0x78>)
  400a12:	4798      	blx	r3
			bytes_to_read);

	/* Move up the read buffer accordingly, wrapping around if it reaches the
	end of the buffer. */
	next_byte_to_read += bytes_to_read;
  400a14:	4425      	add	r5, r4

	if (next_byte_to_read >=
  400a16:	6873      	ldr	r3, [r6, #4]
  400a18:	429d      	cmp	r5, r3
  400a1a:	d306      	bcc.n	400a2a <freertos_copy_bytes_from_pdc_circular_buffer+0x62>
			p_rx_buffer_details->past_rx_buffer_end_address) {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
  400a1c:	4b09      	ldr	r3, [pc, #36]	; (400a44 <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
  400a1e:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
  400a20:	6833      	ldr	r3, [r6, #0]
  400a22:	61b3      	str	r3, [r6, #24]
					(uint8_t *) p_rx_buffer_details->rx_buffer_start_address;
		}
		taskEXIT_CRITICAL();
  400a24:	4b08      	ldr	r3, [pc, #32]	; (400a48 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
  400a26:	4798      	blx	r3
  400a28:	e004      	b.n	400a34 <freertos_copy_bytes_from_pdc_circular_buffer+0x6c>
	} else {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
  400a2a:	4b06      	ldr	r3, [pc, #24]	; (400a44 <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
  400a2c:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
  400a2e:	61b5      	str	r5, [r6, #24]
					(uint8_t *) next_byte_to_read;
		}
		taskEXIT_CRITICAL();
  400a30:	4b05      	ldr	r3, [pc, #20]	; (400a48 <freertos_copy_bytes_from_pdc_circular_buffer+0x80>)
  400a32:	4798      	blx	r3
	}

	/* Return the number of bytes actually read. */
	return bytes_to_read;
}
  400a34:	4620      	mov	r0, r4
  400a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400a3a:	bf00      	nop
  400a3c:	004027d5 	.word	0x004027d5
  400a40:	004044ed 	.word	0x004044ed
  400a44:	00402325 	.word	0x00402325
  400a48:	00402345 	.word	0x00402345

00400a4c <freertos_obtain_peripheral_access_mutex>:
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_mutex != NULL) {
  400a4c:	6843      	ldr	r3, [r0, #4]
  400a4e:	b1b3      	cbz	r3, 400a7e <freertos_obtain_peripheral_access_mutex+0x32>
 * did not become available within max_block_time_ticks tick periods.
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
  400a50:	b530      	push	{r4, r5, lr}
  400a52:	b083      	sub	sp, #12
  400a54:	460d      	mov	r5, r1
  400a56:	4604      	mov	r4, r0
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_mutex != NULL) {
		/* Remember the time on entry. */
		vTaskSetTimeOutState(&time_out_definition);
  400a58:	4668      	mov	r0, sp
  400a5a:	4b0d      	ldr	r3, [pc, #52]	; (400a90 <freertos_obtain_peripheral_access_mutex+0x44>)
  400a5c:	4798      	blx	r3

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
  400a5e:	6860      	ldr	r0, [r4, #4]
  400a60:	2100      	movs	r1, #0
  400a62:	682a      	ldr	r2, [r5, #0]
  400a64:	460b      	mov	r3, r1
  400a66:	4c0b      	ldr	r4, [pc, #44]	; (400a94 <freertos_obtain_peripheral_access_mutex+0x48>)
  400a68:	47a0      	blx	r4
  400a6a:	b158      	cbz	r0, 400a84 <freertos_obtain_peripheral_access_mutex+0x38>
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
		} else {
			/* Adjust the time out value in case the task had to block to
			wait for the semaphore. */
			if (xTaskCheckForTimeOut(&time_out_definition,
  400a6c:	4668      	mov	r0, sp
  400a6e:	4629      	mov	r1, r5
  400a70:	4b09      	ldr	r3, [pc, #36]	; (400a98 <freertos_obtain_peripheral_access_mutex+0x4c>)
  400a72:	4798      	blx	r3
  400a74:	2801      	cmp	r0, #1
  400a76:	d107      	bne.n	400a88 <freertos_obtain_peripheral_access_mutex+0x3c>
					max_block_time_ticks) == pdTRUE) {
				*max_block_time_ticks = 0;
  400a78:	2000      	movs	r0, #0
  400a7a:	6028      	str	r0, [r5, #0]
  400a7c:	e005      	b.n	400a8a <freertos_obtain_peripheral_access_mutex+0x3e>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400a7e:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400a80:	b240      	sxtb	r0, r0
  400a82:	4770      	bx	lr
		vTaskSetTimeOutState(&time_out_definition);

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_mutex,
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
  400a84:	20fd      	movs	r0, #253	; 0xfd
  400a86:	e000      	b.n	400a8a <freertos_obtain_peripheral_access_mutex+0x3e>
 */
status_code_t freertos_obtain_peripheral_access_mutex(
		freertos_dma_event_control_t *dma_event_control,
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400a88:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400a8a:	b240      	sxtb	r0, r0
  400a8c:	b003      	add	sp, #12
  400a8e:	bd30      	pop	{r4, r5, pc}
  400a90:	004037f9 	.word	0x004037f9
  400a94:	00402a09 	.word	0x00402a09
  400a98:	00403829 	.word	0x00403829

00400a9c <freertos_start_pdc_transfer>:
 */
void freertos_start_pdc_transfer(
		freertos_dma_event_control_t *dma_event_control,
		const uint8_t *data, size_t len, void *pdc_base_address,
		xSemaphoreHandle notification_semaphore, bool is_transmitting)
{
  400a9c:	b5f0      	push	{r4, r5, r6, r7, lr}
  400a9e:	b083      	sub	sp, #12
  400aa0:	460e      	mov	r6, r1
  400aa2:	4615      	mov	r5, r2
  400aa4:	461c      	mov	r4, r3
  400aa6:	9b08      	ldr	r3, [sp, #32]
	/* Remember which semaphore is to be used to indicate the end of
	transmission.  If notification_semaphore is NULL then either no
	semaphore is being used, or the driver is using an internal notification
	semaphore because it is configured to wait until the transmit has
	completed before returning. */
	if (notification_semaphore != NULL) {
  400aa8:	b113      	cbz	r3, 400ab0 <freertos_start_pdc_transfer+0x14>
		dma_event_control->transaction_complete_notification_semaphore =
  400aaa:	6003      	str	r3, [r0, #0]
				notification_semaphore;
	}

	/* Ensure the notification semaphore starts in the expected state in case
	the previous PDC transfer didn't complete for any reason. */
	if (dma_event_control->transaction_complete_notification_semaphore !=
  400aac:	4618      	mov	r0, r3
  400aae:	e001      	b.n	400ab4 <freertos_start_pdc_transfer+0x18>
  400ab0:	6800      	ldr	r0, [r0, #0]
  400ab2:	b120      	cbz	r0, 400abe <freertos_start_pdc_transfer+0x22>
			NULL) {
		xSemaphoreTake(
  400ab4:	2100      	movs	r1, #0
  400ab6:	460a      	mov	r2, r1
  400ab8:	460b      	mov	r3, r1
  400aba:	4f13      	ldr	r7, [pc, #76]	; (400b08 <freertos_start_pdc_transfer+0x6c>)
  400abc:	47b8      	blx	r7
				dma_event_control->transaction_complete_notification_semaphore,
				0);
	}

	/* Configure the PDC to transmit or receive parameters. */
	pdc_packet.ul_addr = (uint32_t) data;
  400abe:	9600      	str	r6, [sp, #0]
	pdc_packet.ul_size = (uint32_t) len;
  400ac0:	9501      	str	r5, [sp, #4]

	if (is_transmitting == true) {
  400ac2:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
  400ac6:	b17b      	cbz	r3, 400ae8 <freertos_start_pdc_transfer+0x4c>
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_TXTDIS);
  400ac8:	4620      	mov	r0, r4
  400aca:	f44f 7100 	mov.w	r1, #512	; 0x200
  400ace:	4b0f      	ldr	r3, [pc, #60]	; (400b0c <freertos_start_pdc_transfer+0x70>)
  400ad0:	4798      	blx	r3
		pdc_tx_init(pdc_base_address, &pdc_packet, NULL);
  400ad2:	4620      	mov	r0, r4
  400ad4:	4669      	mov	r1, sp
  400ad6:	2200      	movs	r2, #0
  400ad8:	4b0d      	ldr	r3, [pc, #52]	; (400b10 <freertos_start_pdc_transfer+0x74>)
  400ada:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_TXTEN);
  400adc:	4620      	mov	r0, r4
  400ade:	f44f 7180 	mov.w	r1, #256	; 0x100
  400ae2:	4b0c      	ldr	r3, [pc, #48]	; (400b14 <freertos_start_pdc_transfer+0x78>)
  400ae4:	4798      	blx	r3
  400ae6:	e00c      	b.n	400b02 <freertos_start_pdc_transfer+0x66>
	} else {
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_RXTDIS);
  400ae8:	4620      	mov	r0, r4
  400aea:	2102      	movs	r1, #2
  400aec:	4b07      	ldr	r3, [pc, #28]	; (400b0c <freertos_start_pdc_transfer+0x70>)
  400aee:	4798      	blx	r3
		pdc_rx_init(pdc_base_address, &pdc_packet, NULL);
  400af0:	4620      	mov	r0, r4
  400af2:	4669      	mov	r1, sp
  400af4:	2200      	movs	r2, #0
  400af6:	4b08      	ldr	r3, [pc, #32]	; (400b18 <freertos_start_pdc_transfer+0x7c>)
  400af8:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_RXTEN);
  400afa:	4620      	mov	r0, r4
  400afc:	2101      	movs	r1, #1
  400afe:	4b05      	ldr	r3, [pc, #20]	; (400b14 <freertos_start_pdc_transfer+0x78>)
  400b00:	4798      	blx	r3
	}
}
  400b02:	b003      	add	sp, #12
  400b04:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400b06:	bf00      	nop
  400b08:	00402a09 	.word	0x00402a09
  400b0c:	00401455 	.word	0x00401455
  400b10:	00401419 	.word	0x00401419
  400b14:	00401449 	.word	0x00401449
  400b18:	00401431 	.word	0x00401431

00400b1c <freertos_optionally_wait_transfer_completion>:
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;

	if (notification_semaphore == NULL) {
  400b1c:	b951      	cbnz	r1, 400b34 <freertos_optionally_wait_transfer_completion+0x18>
		if (dma_event_control->transaction_complete_notification_semaphore !=
  400b1e:	6800      	ldr	r0, [r0, #0]
  400b20:	b150      	cbz	r0, 400b38 <freertos_optionally_wait_transfer_completion+0x1c>
 */
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
  400b22:	b510      	push	{r4, lr}
	if (notification_semaphore == NULL) {
		if (dma_event_control->transaction_complete_notification_semaphore !=
				NULL) {
			/* Wait until notified by the ISR that transmission is
			complete. */
			if (xSemaphoreTake(dma_event_control->
  400b24:	460b      	mov	r3, r1
  400b26:	4c07      	ldr	r4, [pc, #28]	; (400b44 <freertos_optionally_wait_transfer_completion+0x28>)
  400b28:	47a0      	blx	r4
					transaction_complete_notification_semaphore,
					max_block_time_ticks) != pdPASS) {
				return_value = ERR_TIMEOUT;
  400b2a:	2801      	cmp	r0, #1
  400b2c:	bf0c      	ite	eq
  400b2e:	2000      	moveq	r0, #0
  400b30:	20fd      	movne	r0, #253	; 0xfd
  400b32:	e004      	b.n	400b3e <freertos_optionally_wait_transfer_completion+0x22>
status_code_t freertos_optionally_wait_transfer_completion(
		freertos_dma_event_control_t *dma_event_control,
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
  400b34:	2000      	movs	r0, #0
  400b36:	e000      	b.n	400b3a <freertos_optionally_wait_transfer_completion+0x1e>
  400b38:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
  400b3a:	b240      	sxtb	r0, r0
  400b3c:	4770      	bx	lr
  400b3e:	b240      	sxtb	r0, r0
  400b40:	bd10      	pop	{r4, pc}
  400b42:	bf00      	nop
  400b44:	00402a09 	.word	0x00402a09

00400b48 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t usart_index,
		enum buffer_operations operation_performed)
{
  400b48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400b4a:	4604      	mov	r4, r0
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400b4c:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
  400b50:	4b31      	ldr	r3, [pc, #196]	; (400c18 <configure_rx_dma+0xd0>)
  400b52:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  400b56:	699a      	ldr	r2, [r3, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
  400b58:	6898      	ldr	r0, [r3, #8]
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
  400b5a:	4282      	cmp	r2, r0
  400b5c:	d114      	bne.n	400b88 <configure_rx_dma+0x40>
		/* The read pointer and the write pointer are equal.  If this function
		was called because data was added to the buffer, then there is no free
		space in the buffer remaining.  If this function was called because data
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
  400b5e:	b951      	cbnz	r1, 400b76 <configure_rx_dma+0x2e>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
  400b60:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b64:	492c      	ldr	r1, [pc, #176]	; (400c18 <configure_rx_dma+0xd0>)
  400b66:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  400b6a:	2000      	movs	r0, #0
  400b6c:	60d8      	str	r0, [r3, #12]
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
  400b6e:	685b      	ldr	r3, [r3, #4]
  400b70:	429a      	cmp	r2, r3
  400b72:	d948      	bls.n	400c06 <configure_rx_dma+0xbe>
  400b74:	e024      	b.n	400bc0 <configure_rx_dma+0x78>
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b76:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b7a:	4927      	ldr	r1, [pc, #156]	; (400c18 <configure_rx_dma+0xd0>)
  400b7c:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400b80:	6859      	ldr	r1, [r3, #4]
  400b82:	1a8a      	subs	r2, r1, r2
		was removed from the buffer, then the space remaining is from the write
		pointer up to the end of the buffer. */
		if (operation_performed == data_added) {
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b84:	60da      	str	r2, [r3, #12]
  400b86:	e011      	b.n	400bac <configure_rx_dma+0x64>
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
  400b88:	4282      	cmp	r2, r0
  400b8a:	d907      	bls.n	400b9c <configure_rx_dma+0x54>
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b8c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400b90:	4921      	ldr	r1, [pc, #132]	; (400c18 <configure_rx_dma+0xd0>)
  400b92:	eb01 0383 	add.w	r3, r1, r3, lsl #2
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400b96:	1a12      	subs	r2, r2, r0
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b98:	60da      	str	r2, [r3, #12]
  400b9a:	e007      	b.n	400bac <configure_rx_dma+0x64>
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400b9c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400ba0:	4a1d      	ldr	r2, [pc, #116]	; (400c18 <configure_rx_dma+0xd0>)
  400ba2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
  400ba6:	685a      	ldr	r2, [r3, #4]
  400ba8:	1a12      	subs	r2, r2, r0
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	} else {
		/* The write pointer is ahead of the read pointer so the space
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
  400baa:	60da      	str	r2, [r3, #12]
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
  400bac:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400bb0:	4a19      	ldr	r2, [pc, #100]	; (400c18 <configure_rx_dma+0xd0>)
  400bb2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400bb6:	68da      	ldr	r2, [r3, #12]
  400bb8:	4410      	add	r0, r2
  400bba:	685b      	ldr	r3, [r3, #4]
  400bbc:	4298      	cmp	r0, r3
  400bbe:	d904      	bls.n	400bca <configure_rx_dma+0x82>
  400bc0:	4816      	ldr	r0, [pc, #88]	; (400c1c <configure_rx_dma+0xd4>)
  400bc2:	f240 219b 	movw	r1, #667	; 0x29b
  400bc6:	4b16      	ldr	r3, [pc, #88]	; (400c20 <configure_rx_dma+0xd8>)
  400bc8:	4798      	blx	r3
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
  400bca:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400bce:	4a12      	ldr	r2, [pc, #72]	; (400c18 <configure_rx_dma+0xd0>)
  400bd0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400bd4:	68db      	ldr	r3, [r3, #12]
  400bd6:	b1b3      	cbz	r3, 400c06 <configure_rx_dma+0xbe>
		/* Restart the DMA to receive into whichever space was calculated
		as remaining.  First clear any characters that might already be in the
		registers. */
		pdc_rx_init(
  400bd8:	4e12      	ldr	r6, [pc, #72]	; (400c24 <configure_rx_dma+0xdc>)
  400bda:	0125      	lsls	r5, r4, #4
  400bdc:	1973      	adds	r3, r6, r5
  400bde:	685f      	ldr	r7, [r3, #4]
  400be0:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  400be4:	eb02 0184 	add.w	r1, r2, r4, lsl #2
  400be8:	4638      	mov	r0, r7
  400bea:	3108      	adds	r1, #8
  400bec:	2200      	movs	r2, #0
  400bee:	4b0e      	ldr	r3, [pc, #56]	; (400c28 <configure_rx_dma+0xe0>)
  400bf0:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address, &rx_buffer_definition->rx_pdc_parameters,
				NULL);
		pdc_enable_transfer(
  400bf2:	4638      	mov	r0, r7
  400bf4:	2101      	movs	r1, #1
  400bf6:	4b0d      	ldr	r3, [pc, #52]	; (400c2c <configure_rx_dma+0xe4>)
  400bf8:	4798      	blx	r3
				all_usart_definitions[usart_index].pdc_base_address,
				PERIPH_PTCR_RXTEN);
		usart_enable_interrupt(
  400bfa:	5970      	ldr	r0, [r6, r5]
  400bfc:	f44f 7184 	mov.w	r1, #264	; 0x108
  400c00:	4b0b      	ldr	r3, [pc, #44]	; (400c30 <configure_rx_dma+0xe8>)
  400c02:	4798      	blx	r3
  400c04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
				all_usart_definitions[usart_index].peripheral_base_address, US_IER_ENDRX |
  400c06:	0124      	lsls	r4, r4, #4
				US_IER_TIMEOUT);
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
  400c08:	4b06      	ldr	r3, [pc, #24]	; (400c24 <configure_rx_dma+0xdc>)
  400c0a:	5918      	ldr	r0, [r3, r4]
  400c0c:	f44f 7184 	mov.w	r1, #264	; 0x108
  400c10:	4b08      	ldr	r3, [pc, #32]	; (400c34 <configure_rx_dma+0xec>)
  400c12:	4798      	blx	r3
  400c14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400c16:	bf00      	nop
  400c18:	20000b4c 	.word	0x20000b4c
  400c1c:	0040975c 	.word	0x0040975c
  400c20:	004041a5 	.word	0x004041a5
  400c24:	0040979c 	.word	0x0040979c
  400c28:	00401431 	.word	0x00401431
  400c2c:	00401449 	.word	0x00401449
  400c30:	004016e9 	.word	0x004016e9
  400c34:	004016ed 	.word	0x004016ed

00400c38 <local_usart_handler>:
/*
 * For internal use only.
 * A common USART interrupt handler that is called for all USART peripherals.
 */
static void local_usart_handler(const portBASE_TYPE usart_index)
{
  400c38:	b5f0      	push	{r4, r5, r6, r7, lr}
  400c3a:	b083      	sub	sp, #12
  400c3c:	4604      	mov	r4, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400c3e:	2300      	movs	r3, #0
  400c40:	9301      	str	r3, [sp, #4]
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
			all_usart_definitions[usart_index].peripheral_base_address);
  400c42:	0103      	lsls	r3, r0, #4
  400c44:	4a45      	ldr	r2, [pc, #276]	; (400d5c <local_usart_handler+0x124>)
  400c46:	58d6      	ldr	r6, [r2, r3]
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
  400c48:	4630      	mov	r0, r6
  400c4a:	4b45      	ldr	r3, [pc, #276]	; (400d60 <local_usart_handler+0x128>)
  400c4c:	4798      	blx	r3
  400c4e:	4605      	mov	r5, r0
			all_usart_definitions[usart_index].peripheral_base_address);
	usart_status &= usart_get_interrupt_mask(
  400c50:	4630      	mov	r0, r6
  400c52:	4b44      	ldr	r3, [pc, #272]	; (400d64 <local_usart_handler+0x12c>)
  400c54:	4798      	blx	r3
  400c56:	4005      	ands	r5, r0
			all_usart_definitions[usart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* Has the PDC completed a transmission? */
	if ((usart_status & US_CSR_ENDTX) != 0UL) {
  400c58:	f015 0f10 	tst.w	r5, #16
  400c5c:	d016      	beq.n	400c8c <local_usart_handler+0x54>
		usart_disable_interrupt(
  400c5e:	4630      	mov	r0, r6
  400c60:	2110      	movs	r1, #16
  400c62:	4b41      	ldr	r3, [pc, #260]	; (400d68 <local_usart_handler+0x130>)
  400c64:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				US_IER_ENDTX);

		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
  400c66:	4b41      	ldr	r3, [pc, #260]	; (400d6c <local_usart_handler+0x134>)
  400c68:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
  400c6c:	6858      	ldr	r0, [r3, #4]
  400c6e:	b120      	cbz	r0, 400c7a <local_usart_handler+0x42>
			xSemaphoreGiveFromISR(
  400c70:	2100      	movs	r1, #0
  400c72:	aa01      	add	r2, sp, #4
  400c74:	460b      	mov	r3, r1
  400c76:	4f3e      	ldr	r7, [pc, #248]	; (400d70 <local_usart_handler+0x138>)
  400c78:	47b8      	blx	r7
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (tx_dma_control[usart_index].transaction_complete_notification_semaphore != NULL) {
  400c7a:	4b3c      	ldr	r3, [pc, #240]	; (400d6c <local_usart_handler+0x134>)
  400c7c:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
  400c80:	b120      	cbz	r0, 400c8c <local_usart_handler+0x54>
			xSemaphoreGiveFromISR(
  400c82:	2100      	movs	r1, #0
  400c84:	aa01      	add	r2, sp, #4
  400c86:	460b      	mov	r3, r1
  400c88:	4f39      	ldr	r7, [pc, #228]	; (400d70 <local_usart_handler+0x138>)
  400c8a:	47b8      	blx	r7
					tx_dma_control[usart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_CSR_ENDRX) != 0UL) {
  400c8c:	f015 0f08 	tst.w	r5, #8
  400c90:	d03b      	beq.n	400d0a <local_usart_handler+0xd2>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
  400c92:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400c96:	4a37      	ldr	r2, [pc, #220]	; (400d74 <local_usart_handler+0x13c>)
  400c98:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400c9c:	699b      	ldr	r3, [r3, #24]
  400c9e:	b923      	cbnz	r3, 400caa <local_usart_handler+0x72>
  400ca0:	4835      	ldr	r0, [pc, #212]	; (400d78 <local_usart_handler+0x140>)
  400ca2:	f240 21df 	movw	r1, #735	; 0x2df
  400ca6:	4b35      	ldr	r3, [pc, #212]	; (400d7c <local_usart_handler+0x144>)
  400ca8:	4798      	blx	r3
		configASSERT(rx_buffer_definition->next_byte_to_read !=
  400caa:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400cae:	4a31      	ldr	r2, [pc, #196]	; (400d74 <local_usart_handler+0x13c>)
  400cb0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400cb4:	699b      	ldr	r3, [r3, #24]
  400cb6:	2b01      	cmp	r3, #1
  400cb8:	d104      	bne.n	400cc4 <local_usart_handler+0x8c>
  400cba:	482f      	ldr	r0, [pc, #188]	; (400d78 <local_usart_handler+0x140>)
  400cbc:	f240 21e1 	movw	r1, #737	; 0x2e1
  400cc0:	4b2e      	ldr	r3, [pc, #184]	; (400d7c <local_usart_handler+0x144>)
  400cc2:	4798      	blx	r3

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
				rx_buffer_definition->rx_pdc_parameters.ul_size;
  400cc4:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400cc8:	4a2a      	ldr	r2, [pc, #168]	; (400d74 <local_usart_handler+0x13c>)
  400cca:	eb02 0383 	add.w	r3, r2, r3, lsl #2
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
  400cce:	68d9      	ldr	r1, [r3, #12]
  400cd0:	689a      	ldr	r2, [r3, #8]
  400cd2:	440a      	add	r2, r1
  400cd4:	609a      	str	r2, [r3, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
  400cd6:	685b      	ldr	r3, [r3, #4]
  400cd8:	429a      	cmp	r2, r3
  400cda:	d306      	bcc.n	400cea <local_usart_handler+0xb2>
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
  400cdc:	4a25      	ldr	r2, [pc, #148]	; (400d74 <local_usart_handler+0x13c>)
  400cde:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400ce2:	009b      	lsls	r3, r3, #2
  400ce4:	18d1      	adds	r1, r2, r3
  400ce6:	58d3      	ldr	r3, [r2, r3]
  400ce8:	608b      	str	r3, [r1, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(usart_index, data_added);
  400cea:	4620      	mov	r0, r4
  400cec:	2100      	movs	r1, #0
  400cee:	4b24      	ldr	r3, [pc, #144]	; (400d80 <local_usart_handler+0x148>)
  400cf0:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  400cf2:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400cf6:	4a1f      	ldr	r2, [pc, #124]	; (400d74 <local_usart_handler+0x13c>)
  400cf8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400cfc:	6918      	ldr	r0, [r3, #16]
  400cfe:	b120      	cbz	r0, 400d0a <local_usart_handler+0xd2>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  400d00:	2100      	movs	r1, #0
  400d02:	aa01      	add	r2, sp, #4
  400d04:	460b      	mov	r3, r1
  400d06:	4f1a      	ldr	r7, [pc, #104]	; (400d70 <local_usart_handler+0x138>)
  400d08:	47b8      	blx	r7
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_IER_TIMEOUT) != 0UL) {
  400d0a:	f415 7f80 	tst.w	r5, #256	; 0x100
  400d0e:	d00e      	beq.n	400d2e <local_usart_handler+0xf6>
		/* More characters have been placed into the Rx buffer.

		Restart the timeout after more data has been received. */
		usart_start_rx_timeout(all_usart_definitions[usart_index].peripheral_base_address);
  400d10:	4630      	mov	r0, r6
  400d12:	4b1c      	ldr	r3, [pc, #112]	; (400d84 <local_usart_handler+0x14c>)
  400d14:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
  400d16:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400d1a:	4a16      	ldr	r2, [pc, #88]	; (400d74 <local_usart_handler+0x13c>)
  400d1c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400d20:	6918      	ldr	r0, [r3, #16]
  400d22:	b120      	cbz	r0, 400d2e <local_usart_handler+0xf6>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
  400d24:	2100      	movs	r1, #0
  400d26:	aa01      	add	r2, sp, #4
  400d28:	460b      	mov	r3, r1
  400d2a:	4f11      	ldr	r7, [pc, #68]	; (400d70 <local_usart_handler+0x138>)
  400d2c:	47b8      	blx	r7
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & SR_ERROR_INTERRUPTS) != 0) {
  400d2e:	f015 0fe0 	tst.w	r5, #224	; 0xe0
  400d32:	d00c      	beq.n	400d4e <local_usart_handler+0x116>
		/* An error occurred in either a transmission or reception.  Abort, and
		ensure the peripheral access mutex is made available to tasks. */
		usart_reset_status(
  400d34:	4630      	mov	r0, r6
  400d36:	4b14      	ldr	r3, [pc, #80]	; (400d88 <local_usart_handler+0x150>)
  400d38:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address);
		if (tx_dma_control[usart_index].peripheral_access_mutex != NULL) {
  400d3a:	4b0c      	ldr	r3, [pc, #48]	; (400d6c <local_usart_handler+0x134>)
  400d3c:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  400d40:	6860      	ldr	r0, [r4, #4]
  400d42:	b120      	cbz	r0, 400d4e <local_usart_handler+0x116>
			xSemaphoreGiveFromISR(
  400d44:	2100      	movs	r1, #0
  400d46:	aa01      	add	r2, sp, #4
  400d48:	460b      	mov	r3, r1
  400d4a:	4c09      	ldr	r4, [pc, #36]	; (400d70 <local_usart_handler+0x138>)
  400d4c:	47a0      	blx	r4
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  400d4e:	9b01      	ldr	r3, [sp, #4]
  400d50:	b10b      	cbz	r3, 400d56 <local_usart_handler+0x11e>
  400d52:	4b0e      	ldr	r3, [pc, #56]	; (400d8c <local_usart_handler+0x154>)
  400d54:	4798      	blx	r3
}
  400d56:	b003      	add	sp, #12
  400d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400d5a:	bf00      	nop
  400d5c:	0040979c 	.word	0x0040979c
  400d60:	004016f5 	.word	0x004016f5
  400d64:	004016f1 	.word	0x004016f1
  400d68:	004016ed 	.word	0x004016ed
  400d6c:	20000c2c 	.word	0x20000c2c
  400d70:	0040296d 	.word	0x0040296d
  400d74:	20000b4c 	.word	0x20000b4c
  400d78:	0040975c 	.word	0x0040975c
  400d7c:	004041a5 	.word	0x004041a5
  400d80:	00400b49 	.word	0x00400b49
  400d84:	00401701 	.word	0x00401701
  400d88:	004016f9 	.word	0x004016f9
  400d8c:	00402305 	.word	0x00402305

00400d90 <freertos_usart_serial_init>:
 *     the initialisation fails then NULL is returned.
 */
freertos_usart_if freertos_usart_serial_init(Usart *p_usart,
		const sam_usart_opt_t *const uart_parameters,
		const freertos_peripheral_options_t *const freertos_driver_parameters)
{
  400d90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  400d94:	b082      	sub	sp, #8
  400d96:	4605      	mov	r5, r0
  400d98:	4689      	mov	r9, r1
  400d9a:	4616      	mov	r6, r2
	portBASE_TYPE usart_index;
	bool is_valid_operating_mode;
	freertos_usart_if return_value;
	const enum peripheral_operation_mode valid_operating_modes[] = {USART_RS232};
  400d9c:	af02      	add	r7, sp, #8
  400d9e:	2300      	movs	r3, #0
  400da0:	f807 3d04 	strb.w	r3, [r7, #-4]!

	/* Find the index into the all_usart_definitions array that holds details of
	the p_usart peripheral. */
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  400da4:	4862      	ldr	r0, [pc, #392]	; (400f30 <freertos_usart_serial_init+0x1a0>)
  400da6:	2108      	movs	r1, #8
  400da8:	462a      	mov	r2, r5
  400daa:	4b62      	ldr	r3, [pc, #392]	; (400f34 <freertos_usart_serial_init+0x1a4>)
  400dac:	4798      	blx	r3
  400dae:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) p_usart);

	/* Check the requested operating mode is valid for the peripheral. */
	is_valid_operating_mode = check_requested_operating_mode(
  400db0:	7b30      	ldrb	r0, [r6, #12]
  400db2:	4639      	mov	r1, r7
  400db4:	2201      	movs	r2, #1
  400db6:	4b60      	ldr	r3, [pc, #384]	; (400f38 <freertos_usart_serial_init+0x1a8>)
  400db8:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_usart pointer was used, and a valid
	operating mode was requested. */
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
  400dba:	2c07      	cmp	r4, #7
  400dbc:	f300 80b1 	bgt.w	400f22 <freertos_usart_serial_init+0x192>
  400dc0:	2800      	cmp	r0, #0
  400dc2:	f000 80b0 	beq.w	400f26 <freertos_usart_serial_init+0x196>
		/* This function must be called exactly once per supported USART.  Check it
		has not been called	before. */
		configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read == NULL);
  400dc6:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400dca:	4a5c      	ldr	r2, [pc, #368]	; (400f3c <freertos_usart_serial_init+0x1ac>)
  400dcc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400dd0:	699b      	ldr	r3, [r3, #24]
  400dd2:	b11b      	cbz	r3, 400ddc <freertos_usart_serial_init+0x4c>
  400dd4:	485a      	ldr	r0, [pc, #360]	; (400f40 <freertos_usart_serial_init+0x1b0>)
  400dd6:	21e7      	movs	r1, #231	; 0xe7
  400dd8:	4b5a      	ldr	r3, [pc, #360]	; (400f44 <freertos_usart_serial_init+0x1b4>)
  400dda:	4798      	blx	r3

		/* Disable everything before enabling the clock. */
		usart_disable_tx(p_usart);
  400ddc:	4628      	mov	r0, r5
  400dde:	4b5a      	ldr	r3, [pc, #360]	; (400f48 <freertos_usart_serial_init+0x1b8>)
  400de0:	4798      	blx	r3
		usart_disable_rx(p_usart);
  400de2:	4628      	mov	r0, r5
  400de4:	4b59      	ldr	r3, [pc, #356]	; (400f4c <freertos_usart_serial_init+0x1bc>)
  400de6:	4798      	blx	r3
		pdc_disable_transfer(all_usart_definitions[usart_index].pdc_base_address,
  400de8:	f8df a144 	ldr.w	sl, [pc, #324]	; 400f30 <freertos_usart_serial_init+0x1a0>
  400dec:	0127      	lsls	r7, r4, #4
  400dee:	eb0a 0307 	add.w	r3, sl, r7
  400df2:	f8d3 8004 	ldr.w	r8, [r3, #4]
  400df6:	4640      	mov	r0, r8
  400df8:	f240 2102 	movw	r1, #514	; 0x202
  400dfc:	4b54      	ldr	r3, [pc, #336]	; (400f50 <freertos_usart_serial_init+0x1c0>)
  400dfe:	4798      	blx	r3
				(PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS));

#if (SAMG55)
		/* Enable the peripheral and set USART mode. */
		uint32_t temp = (uint32_t)all_usart_definitions[usart_index].peripheral_base_address - 0x200;
  400e00:	f85a 7007 	ldr.w	r7, [sl, r7]
  400e04:	f5a7 7700 	sub.w	r7, r7, #512	; 0x200
		Flexcom *p_flexcom = (Flexcom *)temp;
		flexcom_enable(p_flexcom);
  400e08:	4638      	mov	r0, r7
  400e0a:	4b52      	ldr	r3, [pc, #328]	; (400f54 <freertos_usart_serial_init+0x1c4>)
  400e0c:	4798      	blx	r3
		flexcom_set_opmode(p_flexcom, FLEXCOM_USART);
  400e0e:	4638      	mov	r0, r7
  400e10:	2101      	movs	r1, #1
  400e12:	4b51      	ldr	r3, [pc, #324]	; (400f58 <freertos_usart_serial_init+0x1c8>)
  400e14:	4798      	blx	r3
		/* Enable the peripheral clock in the PMC. */
		pmc_enable_periph_clk(
				all_usart_definitions[usart_index].peripheral_id);
#endif

		switch (freertos_driver_parameters->operation_mode) {
  400e16:	7b33      	ldrb	r3, [r6, #12]
  400e18:	b923      	cbnz	r3, 400e24 <freertos_usart_serial_init+0x94>
		case USART_RS232:
			/* Call the standard ASF init function. */
			usart_init_rs232(p_usart, uart_parameters,
  400e1a:	4628      	mov	r0, r5
  400e1c:	4649      	mov	r1, r9
  400e1e:	4a4f      	ldr	r2, [pc, #316]	; (400f5c <freertos_usart_serial_init+0x1cc>)
  400e20:	4b4f      	ldr	r3, [pc, #316]	; (400f60 <freertos_usart_serial_init+0x1d0>)
  400e22:	4798      	blx	r3
			/* Other modes are not currently supported. */
			break;
		}

		/* Disable all the interrupts. */
		usart_disable_interrupt(p_usart, MASK_ALL_INTERRUPTS);
  400e24:	4628      	mov	r0, r5
  400e26:	f04f 31ff 	mov.w	r1, #4294967295
  400e2a:	4b4e      	ldr	r3, [pc, #312]	; (400f64 <freertos_usart_serial_init+0x1d4>)
  400e2c:	4798      	blx	r3

		/* Create any required peripheral access mutexes and transaction complete
		semaphores.  This peripheral is full duplex so only the Tx semaphores
		are created in the following function.  The the Rx semaphores are
		created	separately. */
		create_peripheral_control_semaphores(
  400e2e:	7b70      	ldrb	r0, [r6, #13]
  400e30:	494d      	ldr	r1, [pc, #308]	; (400f68 <freertos_usart_serial_init+0x1d8>)
  400e32:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
  400e36:	2200      	movs	r2, #0
  400e38:	4b4c      	ldr	r3, [pc, #304]	; (400f6c <freertos_usart_serial_init+0x1dc>)
  400e3a:	4798      	blx	r3
				freertos_driver_parameters->options_flags,
				&(tx_dma_control[usart_index]),
				NULL /* The rx structures are not created in this function. */);

		/* Is the driver also going to receive? */
		if (freertos_driver_parameters->receive_buffer != NULL) {
  400e3c:	6833      	ldr	r3, [r6, #0]
  400e3e:	2b00      	cmp	r3, #0
  400e40:	d055      	beq.n	400eee <freertos_usart_serial_init+0x15e>
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
  400e42:	f04f 30ff 	mov.w	r0, #4294967295
  400e46:	2100      	movs	r1, #0
  400e48:	4b49      	ldr	r3, [pc, #292]	; (400f70 <freertos_usart_serial_init+0x1e0>)
  400e4a:	4798      	blx	r3
			and the end of the buffer, the actual amount returned will be
			capped to that available up to the end of the buffer only.  If this
			semaphore was a binary semaphore, it would then be 'taken' even
			though, unknown to the reading task, unread and therefore available
			data remained at the beginning of the buffer. */
			rx_buffer_definitions[usart_index].rx_event_semaphore =
  400e4c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400e50:	4a3a      	ldr	r2, [pc, #232]	; (400f3c <freertos_usart_serial_init+0x1ac>)
  400e52:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400e56:	6118      	str	r0, [r3, #16]
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
			configASSERT(rx_buffer_definitions[usart_index].rx_event_semaphore);
  400e58:	b920      	cbnz	r0, 400e64 <freertos_usart_serial_init+0xd4>
  400e5a:	4839      	ldr	r0, [pc, #228]	; (400f40 <freertos_usart_serial_init+0x1b0>)
  400e5c:	f44f 7192 	mov.w	r1, #292	; 0x124
  400e60:	4b38      	ldr	r3, [pc, #224]	; (400f44 <freertos_usart_serial_init+0x1b4>)
  400e62:	4798      	blx	r3

			/* Set the timeout to 5ms, then start waiting for a character (the
			timeout is not started until characters have started to	be
			received). */
			usart_set_rx_timeout(p_usart,
  400e64:	f8d9 3000 	ldr.w	r3, [r9]
  400e68:	4942      	ldr	r1, [pc, #264]	; (400f74 <freertos_usart_serial_init+0x1e4>)
  400e6a:	fba1 3103 	umull	r3, r1, r1, r3
  400e6e:	4628      	mov	r0, r5
  400e70:	0989      	lsrs	r1, r1, #6
  400e72:	4b41      	ldr	r3, [pc, #260]	; (400f78 <freertos_usart_serial_init+0x1e8>)
  400e74:	4798      	blx	r3
					(uart_parameters->baudrate / BITS_PER_5_MS));
			usart_start_rx_timeout(p_usart);
  400e76:	4628      	mov	r0, r5
  400e78:	4b40      	ldr	r3, [pc, #256]	; (400f7c <freertos_usart_serial_init+0x1ec>)
  400e7a:	4798      	blx	r3

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
  400e7c:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 400f3c <freertos_usart_serial_init+0x1ac>
  400e80:	00e1      	lsls	r1, r4, #3
  400e82:	ebc4 0901 	rsb	r9, r4, r1
  400e86:	ea4f 0989 	mov.w	r9, r9, lsl #2
  400e8a:	eb0a 0709 	add.w	r7, sl, r9
  400e8e:	6833      	ldr	r3, [r6, #0]
  400e90:	60bb      	str	r3, [r7, #8]
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
					freertos_driver_parameters->receive_buffer_size;
  400e92:	6873      	ldr	r3, [r6, #4]

			/* The receive buffer is currently empty, so the DMA has control
			over the entire buffer. */
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
					(uint32_t)freertos_driver_parameters->receive_buffer;
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
  400e94:	60fb      	str	r3, [r7, #12]
					freertos_driver_parameters->receive_buffer_size;
			pdc_rx_init(
  400e96:	1b09      	subs	r1, r1, r4
  400e98:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
  400e9c:	4640      	mov	r0, r8
  400e9e:	3108      	adds	r1, #8
  400ea0:	2200      	movs	r2, #0
  400ea2:	4b37      	ldr	r3, [pc, #220]	; (400f80 <freertos_usart_serial_init+0x1f0>)
  400ea4:	4798      	blx	r3
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;
  400ea6:	6833      	ldr	r3, [r6, #0]
					&(rx_buffer_definitions[usart_index].rx_pdc_parameters),
					NULL);

			/* Set the next byte to read to the start of the buffer as no data
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
  400ea8:	61bb      	str	r3, [r7, #24]
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
  400eaa:	68bb      	ldr	r3, [r7, #8]
			has yet been read. */
			rx_buffer_definitions[usart_index].next_byte_to_read =
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
  400eac:	f84a 3009 	str.w	r3, [sl, r9]
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
  400eb0:	6872      	ldr	r2, [r6, #4]
  400eb2:	4413      	add	r3, r2
					freertos_driver_parameters->receive_buffer;

			/* Remember the limits of entire buffer. */
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
  400eb4:	607b      	str	r3, [r7, #4]
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
					freertos_driver_parameters->receive_buffer_size;

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
  400eb6:	7b73      	ldrb	r3, [r6, #13]
  400eb8:	f013 0f02 	tst.w	r3, #2
  400ebc:	d00d      	beq.n	400eda <freertos_usart_serial_init+0x14a>
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
					xSemaphoreCreateMutex();
  400ebe:	2001      	movs	r0, #1
  400ec0:	4b30      	ldr	r3, [pc, #192]	; (400f84 <freertos_usart_serial_init+0x1f4>)
  400ec2:	4798      	blx	r3

			/* If the rx driver is to be thread aware, create an access control
			mutex. */
			if ((freertos_driver_parameters->options_flags &
					USE_RX_ACCESS_MUTEX) != 0) {
				rx_buffer_definitions[usart_index].rx_access_mutex =
  400ec4:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400ec8:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
  400ecc:	6158      	str	r0, [r3, #20]
					xSemaphoreCreateMutex();
				configASSERT(rx_buffer_definitions[usart_index].rx_access_mutex);
  400ece:	b920      	cbnz	r0, 400eda <freertos_usart_serial_init+0x14a>
  400ed0:	481b      	ldr	r0, [pc, #108]	; (400f40 <freertos_usart_serial_init+0x1b0>)
  400ed2:	f44f 71a5 	mov.w	r1, #330	; 0x14a
  400ed6:	4b1b      	ldr	r3, [pc, #108]	; (400f44 <freertos_usart_serial_init+0x1b4>)
  400ed8:	4798      	blx	r3
			}

			/* Catch the DMA running out of Rx space, and gaps in the
			reception.  These events are both used to signal that there is
			data available in the Rx buffer. */
			usart_enable_interrupt(p_usart, US_IER_ENDRX | US_IER_TIMEOUT);
  400eda:	4628      	mov	r0, r5
  400edc:	f44f 7184 	mov.w	r1, #264	; 0x108
  400ee0:	4b29      	ldr	r3, [pc, #164]	; (400f88 <freertos_usart_serial_init+0x1f8>)
  400ee2:	4798      	blx	r3

			/* The Rx DMA is running all the time, so enable it now. */
			pdc_enable_transfer(
  400ee4:	4640      	mov	r0, r8
  400ee6:	2101      	movs	r1, #1
  400ee8:	4b28      	ldr	r3, [pc, #160]	; (400f8c <freertos_usart_serial_init+0x1fc>)
  400eea:	4798      	blx	r3
  400eec:	e006      	b.n	400efc <freertos_usart_serial_init+0x16c>
		} else {
			/* next_byte_to_read is used to check to see if this function
			has been called before, so it must be set to something, even if
			it is not going to be used.  The value it is set to is not
			important, provided it is not zero (NULL). */
			rx_buffer_definitions[usart_index].next_byte_to_read = RX_NOT_USED;
  400eee:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  400ef2:	4a12      	ldr	r2, [pc, #72]	; (400f3c <freertos_usart_serial_init+0x1ac>)
  400ef4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400ef8:	2201      	movs	r2, #1
  400efa:	619a      	str	r2, [r3, #24]
		}

		/* Configure and enable the USART interrupt in the interrupt controller. */
		configure_interrupt_controller(all_usart_definitions[usart_index].peripheral_irq,
  400efc:	4f0c      	ldr	r7, [pc, #48]	; (400f30 <freertos_usart_serial_init+0x1a0>)
  400efe:	0124      	lsls	r4, r4, #4
  400f00:	193b      	adds	r3, r7, r4
  400f02:	f993 000c 	ldrsb.w	r0, [r3, #12]
  400f06:	68b1      	ldr	r1, [r6, #8]
  400f08:	4b21      	ldr	r3, [pc, #132]	; (400f90 <freertos_usart_serial_init+0x200>)
  400f0a:	4798      	blx	r3
				freertos_driver_parameters->interrupt_priority);

		/* Error interrupts are always enabled. */
		usart_enable_interrupt(
  400f0c:	5938      	ldr	r0, [r7, r4]
  400f0e:	21e0      	movs	r1, #224	; 0xe0
  400f10:	4b1d      	ldr	r3, [pc, #116]	; (400f88 <freertos_usart_serial_init+0x1f8>)
  400f12:	4798      	blx	r3
				all_usart_definitions[usart_index].peripheral_base_address,
				IER_ERROR_INTERRUPTS);

		/* Finally, enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  400f14:	4628      	mov	r0, r5
  400f16:	4b1f      	ldr	r3, [pc, #124]	; (400f94 <freertos_usart_serial_init+0x204>)
  400f18:	4798      	blx	r3
		usart_enable_rx(p_usart);
  400f1a:	4628      	mov	r0, r5
  400f1c:	4b1e      	ldr	r3, [pc, #120]	; (400f98 <freertos_usart_serial_init+0x208>)
  400f1e:	4798      	blx	r3
			sizeof(valid_operating_modes) /
			sizeof(enum peripheral_operation_mode));

	/* Don't do anything unless a valid p_usart pointer was used, and a valid
	operating mode was requested. */
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
  400f20:	e002      	b.n	400f28 <freertos_usart_serial_init+0x198>
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);

		return_value = (freertos_usart_if) p_usart;
	} else {
		return_value = NULL;
  400f22:	2500      	movs	r5, #0
  400f24:	e000      	b.n	400f28 <freertos_usart_serial_init+0x198>
  400f26:	2500      	movs	r5, #0
	}

	return return_value;
}
  400f28:	4628      	mov	r0, r5
  400f2a:	b002      	add	sp, #8
  400f2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  400f30:	0040979c 	.word	0x0040979c
  400f34:	00400845 	.word	0x00400845
  400f38:	00400875 	.word	0x00400875
  400f3c:	20000b4c 	.word	0x20000b4c
  400f40:	0040975c 	.word	0x0040975c
  400f44:	004041a5 	.word	0x004041a5
  400f48:	004016cd 	.word	0x004016cd
  400f4c:	004016dd 	.word	0x004016dd
  400f50:	00401455 	.word	0x00401455
  400f54:	00401299 	.word	0x00401299
  400f58:	00401415 	.word	0x00401415
  400f5c:	07270000 	.word	0x07270000
  400f60:	00401671 	.word	0x00401671
  400f64:	004016ed 	.word	0x004016ed
  400f68:	20000c2c 	.word	0x20000c2c
  400f6c:	004008a9 	.word	0x004008a9
  400f70:	004027a5 	.word	0x004027a5
  400f74:	51eb851f 	.word	0x51eb851f
  400f78:	004016e5 	.word	0x004016e5
  400f7c:	00401701 	.word	0x00401701
  400f80:	00401431 	.word	0x00401431
  400f84:	00402905 	.word	0x00402905
  400f88:	004016e9 	.word	0x004016e9
  400f8c:	00401449 	.word	0x00401449
  400f90:	0040095d 	.word	0x0040095d
  400f94:	004016c5 	.word	0x004016c5
  400f98:	004016d5 	.word	0x004016d5

00400f9c <freertos_usart_write_packet_async>:
 *     operation.
 */
status_code_t freertos_usart_write_packet_async(freertos_usart_if p_usart,
		const uint8_t *data, size_t len, portTickType block_time_ticks,
		xSemaphoreHandle notification_semaphore)
{
  400f9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400fa0:	b084      	sub	sp, #16
  400fa2:	4605      	mov	r5, r0
  400fa4:	460f      	mov	r7, r1
  400fa6:	4616      	mov	r6, r2
  400fa8:	9303      	str	r3, [sp, #12]
	status_code_t return_value;
	portBASE_TYPE usart_index;
	Usart *usart_base;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  400faa:	4817      	ldr	r0, [pc, #92]	; (401008 <freertos_usart_write_packet_async+0x6c>)
  400fac:	2108      	movs	r1, #8
  400fae:	462a      	mov	r2, r5
  400fb0:	4b16      	ldr	r3, [pc, #88]	; (40100c <freertos_usart_write_packet_async+0x70>)
  400fb2:	4798      	blx	r3
  400fb4:	4680      	mov	r8, r0
			MAX_USARTS,
			(void *) usart_base);

	/* Don't do anything unless a valid USART pointer was used. */
	if (usart_index < MAX_USARTS) {
  400fb6:	2807      	cmp	r0, #7
  400fb8:	dc21      	bgt.n	400ffe <freertos_usart_write_packet_async+0x62>
		return_value = freertos_obtain_peripheral_access_mutex(
  400fba:	4c15      	ldr	r4, [pc, #84]	; (401010 <freertos_usart_write_packet_async+0x74>)
  400fbc:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
  400fc0:	4620      	mov	r0, r4
  400fc2:	a903      	add	r1, sp, #12
  400fc4:	4b13      	ldr	r3, [pc, #76]	; (401014 <freertos_usart_write_packet_async+0x78>)
  400fc6:	4798      	blx	r3
				&(tx_dma_control[usart_index]),
				&block_time_ticks);

		if (return_value == STATUS_OK) {
  400fc8:	4603      	mov	r3, r0
  400fca:	b9c8      	cbnz	r0, 401000 <freertos_usart_write_packet_async+0x64>
			freertos_start_pdc_tx(&(tx_dma_control[usart_index]),
  400fcc:	4b0e      	ldr	r3, [pc, #56]	; (401008 <freertos_usart_write_packet_async+0x6c>)
  400fce:	eb03 1808 	add.w	r8, r3, r8, lsl #4
  400fd2:	f8d8 3004 	ldr.w	r3, [r8, #4]
  400fd6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  400fd8:	9200      	str	r2, [sp, #0]
  400fda:	2201      	movs	r2, #1
  400fdc:	9201      	str	r2, [sp, #4]
  400fde:	4620      	mov	r0, r4
  400fe0:	4639      	mov	r1, r7
  400fe2:	4632      	mov	r2, r6
  400fe4:	4e0c      	ldr	r6, [pc, #48]	; (401018 <freertos_usart_write_packet_async+0x7c>)
  400fe6:	47b0      	blx	r6
			/* Catch the end of transmission so the access mutex can be
			returned, and the task notified (if it supplied a notification
			semaphore).  The interrupt can be enabled here because the ENDTX
			signal from the PDC to the USART will have been de-asserted when
			the next transfer was configured. */
			usart_enable_interrupt(usart_base, US_IER_ENDTX);
  400fe8:	4628      	mov	r0, r5
  400fea:	2110      	movs	r1, #16
  400fec:	4b0b      	ldr	r3, [pc, #44]	; (40101c <freertos_usart_write_packet_async+0x80>)
  400fee:	4798      	blx	r3

			return_value = freertos_optionally_wait_transfer_completion(
  400ff0:	4620      	mov	r0, r4
  400ff2:	990a      	ldr	r1, [sp, #40]	; 0x28
  400ff4:	9a03      	ldr	r2, [sp, #12]
  400ff6:	4b0a      	ldr	r3, [pc, #40]	; (401020 <freertos_usart_write_packet_async+0x84>)
  400ff8:	4798      	blx	r3
  400ffa:	4603      	mov	r3, r0
  400ffc:	e000      	b.n	401000 <freertos_usart_write_packet_async+0x64>
					&(tx_dma_control[usart_index]),
					notification_semaphore,
					block_time_ticks);
		}
	} else {
		return_value = ERR_INVALID_ARG;
  400ffe:	23f8      	movs	r3, #248	; 0xf8
	}

	return return_value;
}
  401000:	b258      	sxtb	r0, r3
  401002:	b004      	add	sp, #16
  401004:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401008:	0040979c 	.word	0x0040979c
  40100c:	00400845 	.word	0x00400845
  401010:	20000c2c 	.word	0x20000c2c
  401014:	00400a4d 	.word	0x00400a4d
  401018:	00400a9d 	.word	0x00400a9d
  40101c:	004016e9 	.word	0x004016e9
  401020:	00400b1d 	.word	0x00400b1d

00401024 <freertos_usart_serial_read_packet>:
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
  401024:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401028:	b085      	sub	sp, #20
  40102a:	4604      	mov	r4, r0
  40102c:	460f      	mov	r7, r1
  40102e:	4616      	mov	r6, r2
  401030:	9301      	str	r3, [sp, #4]
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;

	usart_base = (Usart *) p_usart;
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
  401032:	484b      	ldr	r0, [pc, #300]	; (401160 <freertos_usart_serial_read_packet+0x13c>)
  401034:	2108      	movs	r1, #8
  401036:	4622      	mov	r2, r4
  401038:	4b4a      	ldr	r3, [pc, #296]	; (401164 <freertos_usart_serial_read_packet+0x140>)
  40103a:	4798      	blx	r3
  40103c:	4604      	mov	r4, r0
			MAX_USARTS,
			(void *) usart_base);

	/* It is possible to initialise the peripheral to only use Tx and not Rx.
	Check that Rx has been initialised. */
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read);
  40103e:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
  401042:	4b49      	ldr	r3, [pc, #292]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  401044:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  401048:	699b      	ldr	r3, [r3, #24]
  40104a:	b923      	cbnz	r3, 401056 <freertos_usart_serial_read_packet+0x32>
  40104c:	4847      	ldr	r0, [pc, #284]	; (40116c <freertos_usart_serial_read_packet+0x148>)
  40104e:	f44f 7108 	mov.w	r1, #544	; 0x220
  401052:	4b47      	ldr	r3, [pc, #284]	; (401170 <freertos_usart_serial_read_packet+0x14c>)
  401054:	4798      	blx	r3
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read !=
  401056:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  40105a:	4a43      	ldr	r2, [pc, #268]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  40105c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401060:	699b      	ldr	r3, [r3, #24]
  401062:	2b01      	cmp	r3, #1
  401064:	d104      	bne.n	401070 <freertos_usart_serial_read_packet+0x4c>
  401066:	4841      	ldr	r0, [pc, #260]	; (40116c <freertos_usart_serial_read_packet+0x148>)
  401068:	f240 2122 	movw	r1, #546	; 0x222
  40106c:	4b40      	ldr	r3, [pc, #256]	; (401170 <freertos_usart_serial_read_packet+0x14c>)
  40106e:	4798      	blx	r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
  401070:	2c07      	cmp	r4, #7
  401072:	dc5c      	bgt.n	40112e <freertos_usart_serial_read_packet+0x10a>
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
  401074:	493c      	ldr	r1, [pc, #240]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  401076:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  40107a:	009b      	lsls	r3, r3, #2
  40107c:	18ca      	adds	r2, r1, r3
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
  40107e:	6852      	ldr	r2, [r2, #4]
  401080:	58cb      	ldr	r3, [r1, r3]
  401082:	1ad3      	subs	r3, r2, r3
			RX_NOT_USED);

	/* Only do anything if the USART is valid. */
	if (usart_index < MAX_USARTS) {
		/* Must not request more bytes than will fit in the buffer. */
		if (len <=
  401084:	42b3      	cmp	r3, r6
  401086:	d354      	bcc.n	401132 <freertos_usart_serial_read_packet+0x10e>
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
			/* Remember the time on entry. */
			vTaskSetTimeOutState(&time_out_definition);
  401088:	a802      	add	r0, sp, #8
  40108a:	4b3a      	ldr	r3, [pc, #232]	; (401174 <freertos_usart_serial_read_packet+0x150>)
  40108c:	4798      	blx	r3

			/* If an Rx mutex is in use, attempt to obtain it. */
			if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
  40108e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  401092:	4a35      	ldr	r2, [pc, #212]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  401094:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  401098:	6958      	ldr	r0, [r3, #20]
  40109a:	2800      	cmp	r0, #0
  40109c:	d04d      	beq.n	40113a <freertos_usart_serial_read_packet+0x116>
				/* Attempt to obtain the mutex. */
				attempt_read = xSemaphoreTake(
  40109e:	2100      	movs	r1, #0
  4010a0:	9a01      	ldr	r2, [sp, #4]
  4010a2:	460b      	mov	r3, r1
  4010a4:	4d34      	ldr	r5, [pc, #208]	; (401178 <freertos_usart_serial_read_packet+0x154>)
  4010a6:	47a8      	blx	r5
						rx_buffer_definitions[usart_index].rx_access_mutex,
						block_time_ticks);

				if (attempt_read == pdTRUE) {
  4010a8:	2801      	cmp	r0, #1
  4010aa:	d144      	bne.n	401136 <freertos_usart_serial_read_packet+0x112>
					/* The semaphore was obtained, adjust the block_time_ticks to take
					into account the time taken to obtain the semaphore. */
					if (xTaskCheckForTimeOut(&time_out_definition,
  4010ac:	a802      	add	r0, sp, #8
  4010ae:	a901      	add	r1, sp, #4
  4010b0:	4b32      	ldr	r3, [pc, #200]	; (40117c <freertos_usart_serial_read_packet+0x158>)
  4010b2:	4798      	blx	r3
  4010b4:	2801      	cmp	r0, #1
  4010b6:	d140      	bne.n	40113a <freertos_usart_serial_read_packet+0x116>
							&block_time_ticks) == pdTRUE) {
						attempt_read = pdFALSE;

						/* The port is not going to be used, so return the
						mutex now. */
						xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
  4010b8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  4010bc:	4b2a      	ldr	r3, [pc, #168]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  4010be:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  4010c2:	6958      	ldr	r0, [r3, #20]
  4010c4:	2100      	movs	r1, #0
  4010c6:	460a      	mov	r2, r1
  4010c8:	460b      	mov	r3, r1
  4010ca:	4c2d      	ldr	r4, [pc, #180]	; (401180 <freertos_usart_serial_read_packet+0x15c>)
  4010cc:	47a0      	blx	r4
  4010ce:	e032      	b.n	401136 <freertos_usart_serial_read_packet+0x112>
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
  4010d0:	f8d8 0010 	ldr.w	r0, [r8, #16]
  4010d4:	2100      	movs	r1, #0
  4010d6:	9a01      	ldr	r2, [sp, #4]
  4010d8:	460b      	mov	r3, r1
  4010da:	47d8      	blx	fp

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
  4010dc:	f8d9 3004 	ldr.w	r3, [r9, #4]
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
  4010e0:	6819      	ldr	r1, [r3, #0]
  4010e2:	4640      	mov	r0, r8
  4010e4:	197a      	adds	r2, r7, r5
  4010e6:	1b73      	subs	r3, r6, r5
  4010e8:	47d0      	blx	sl

					/* The Rx DMA will have stopped if the Rx buffer had become
					full before this read operation.  If bytes were removed by
					this read then there is guaranteed to be space in the Rx
					buffer and the Rx DMA can be restarted. */
					if (bytes_read > 0) {
  4010ea:	182d      	adds	r5, r5, r0
  4010ec:	d00a      	beq.n	401104 <freertos_usart_serial_read_packet+0xe0>
						taskENTER_CRITICAL();
  4010ee:	4b25      	ldr	r3, [pc, #148]	; (401184 <freertos_usart_serial_read_packet+0x160>)
  4010f0:	4798      	blx	r3
						{
							if(rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size == 0UL) {
  4010f2:	f8d8 300c 	ldr.w	r3, [r8, #12]
  4010f6:	b91b      	cbnz	r3, 401100 <freertos_usart_serial_read_packet+0xdc>
								configure_rx_dma(usart_index, data_removed);
  4010f8:	4620      	mov	r0, r4
  4010fa:	2101      	movs	r1, #1
  4010fc:	4b22      	ldr	r3, [pc, #136]	; (401188 <freertos_usart_serial_read_packet+0x164>)
  4010fe:	4798      	blx	r3
							}
						}
						taskEXIT_CRITICAL();
  401100:	4b22      	ldr	r3, [pc, #136]	; (40118c <freertos_usart_serial_read_packet+0x168>)
  401102:	4798      	blx	r3

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
						&time_out_definition,
						&block_time_ticks) == pdFALSE));
  401104:	42ae      	cmp	r6, r5
  401106:	d905      	bls.n	401114 <freertos_usart_serial_read_packet+0xf0>
						taskEXIT_CRITICAL();
					}

				  /* Until all the requested bytes are received, or the function
				  runs out of time. */
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
  401108:	a802      	add	r0, sp, #8
  40110a:	a901      	add	r1, sp, #4
  40110c:	4b1b      	ldr	r3, [pc, #108]	; (40117c <freertos_usart_serial_read_packet+0x158>)
  40110e:	4798      	blx	r3
  401110:	2800      	cmp	r0, #0
  401112:	d0dd      	beq.n	4010d0 <freertos_usart_serial_read_packet+0xac>
						&time_out_definition,
						&block_time_ticks) == pdFALSE));

				if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
  401114:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  401118:	4b13      	ldr	r3, [pc, #76]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  40111a:	eb03 0484 	add.w	r4, r3, r4, lsl #2
  40111e:	6960      	ldr	r0, [r4, #20]
  401120:	b1c8      	cbz	r0, 401156 <freertos_usart_serial_read_packet+0x132>
					/* Return the mutex. */
					xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
  401122:	2100      	movs	r1, #0
  401124:	460a      	mov	r2, r1
  401126:	460b      	mov	r3, r1
  401128:	4c15      	ldr	r4, [pc, #84]	; (401180 <freertos_usart_serial_read_packet+0x15c>)
  40112a:	47a0      	blx	r4
  40112c:	e013      	b.n	401156 <freertos_usart_serial_read_packet+0x132>
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
	portBASE_TYPE usart_index, attempt_read;
	Usart *usart_base;
	xTimeOutType time_out_definition;
	uint32_t bytes_read = 0;
  40112e:	2500      	movs	r5, #0
  401130:	e011      	b.n	401156 <freertos_usart_serial_read_packet+0x132>
  401132:	2500      	movs	r5, #0
  401134:	e00f      	b.n	401156 <freertos_usart_serial_read_packet+0x132>
  401136:	2500      	movs	r5, #0
  401138:	e00d      	b.n	401156 <freertos_usart_serial_read_packet+0x132>
 * \return     The number of bytes that were copied into data.  This will be
 *     less than the requested number of bytes if a time out occurred.
 */
uint32_t freertos_usart_serial_read_packet(freertos_usart_if p_usart,
		uint8_t *data, uint32_t len, portTickType block_time_ticks)
{
  40113a:	2500      	movs	r5, #0
			}

			if (attempt_read == pdTRUE) {
				do {
					/* Wait until data is available. */
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
  40113c:	ebc4 08c4 	rsb	r8, r4, r4, lsl #3
  401140:	4b09      	ldr	r3, [pc, #36]	; (401168 <freertos_usart_serial_read_packet+0x144>)
  401142:	eb03 0888 	add.w	r8, r3, r8, lsl #2
  401146:	f8df b030 	ldr.w	fp, [pc, #48]	; 401178 <freertos_usart_serial_read_packet+0x154>

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
							&(rx_buffer_definitions[usart_index]),
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
  40114a:	4b05      	ldr	r3, [pc, #20]	; (401160 <freertos_usart_serial_read_packet+0x13c>)
  40114c:	eb03 1904 	add.w	r9, r3, r4, lsl #4
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
							block_time_ticks);

					/* Copy as much data as is available, up to however much
					a maximum of the total number of requested bytes. */
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
  401150:	f8df a03c 	ldr.w	sl, [pc, #60]	; 401190 <freertos_usart_serial_read_packet+0x16c>
  401154:	e7bc      	b.n	4010d0 <freertos_usart_serial_read_packet+0xac>
			}
		}
	}

	return bytes_read;
}
  401156:	4628      	mov	r0, r5
  401158:	b005      	add	sp, #20
  40115a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40115e:	bf00      	nop
  401160:	0040979c 	.word	0x0040979c
  401164:	00400845 	.word	0x00400845
  401168:	20000b4c 	.word	0x20000b4c
  40116c:	0040975c 	.word	0x0040975c
  401170:	004041a5 	.word	0x004041a5
  401174:	004037f9 	.word	0x004037f9
  401178:	00402a09 	.word	0x00402a09
  40117c:	00403829 	.word	0x00403829
  401180:	004027d5 	.word	0x004027d5
  401184:	00402325 	.word	0x00402325
  401188:	00400b49 	.word	0x00400b49
  40118c:	00402345 	.word	0x00402345
  401190:	004009c9 	.word	0x004009c9

00401194 <FLEXCOM0_Handler>:
 * handler calls the common interrupt handler.
 */
#if SAMG55
#ifdef CONF_FREERTOS_USE_USART0
void FLEXCOM0_Handler(void)
{
  401194:	b508      	push	{r3, lr}
	local_usart_handler(0);
  401196:	2000      	movs	r0, #0
  401198:	4b01      	ldr	r3, [pc, #4]	; (4011a0 <FLEXCOM0_Handler+0xc>)
  40119a:	4798      	blx	r3
  40119c:	bd08      	pop	{r3, pc}
  40119e:	bf00      	nop
  4011a0:	00400c39 	.word	0x00400c39

004011a4 <FLEXCOM7_Handler>:
	local_usart_handler(6);
}
#endif
#ifdef CONF_FREERTOS_USE_USART7
void FLEXCOM7_Handler(void)
{
  4011a4:	b508      	push	{r3, lr}
	local_usart_handler(7);
  4011a6:	2007      	movs	r0, #7
  4011a8:	4b01      	ldr	r3, [pc, #4]	; (4011b0 <FLEXCOM7_Handler+0xc>)
  4011aa:	4798      	blx	r3
  4011ac:	bd08      	pop	{r3, pc}
  4011ae:	bf00      	nop
  4011b0:	00400c39 	.word	0x00400c39

004011b4 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
  4011b4:	b538      	push	{r3, r4, r5, lr}

#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	WDT->WDT_MR = WDT_MR_WDDIS;
  4011b6:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  4011ba:	4b33      	ldr	r3, [pc, #204]	; (401288 <system_board_init+0xd4>)
  4011bc:	605c      	str	r4, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  4011be:	200b      	movs	r0, #11
  4011c0:	4d32      	ldr	r5, [pc, #200]	; (40128c <system_board_init+0xd8>)
  4011c2:	47a8      	blx	r5
  4011c4:	200c      	movs	r0, #12
  4011c6:	47a8      	blx	r5
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4011c8:	4b31      	ldr	r3, [pc, #196]	; (401290 <system_board_init+0xdc>)
  4011ca:	2240      	movs	r2, #64	; 0x40
  4011cc:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4011ce:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4011d2:	631a      	str	r2, [r3, #48]	; 0x30
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  4011d4:	2204      	movs	r2, #4
  4011d6:	615a      	str	r2, [r3, #20]
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4011d8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
  4011dc:	665a      	str	r2, [r3, #100]	; 0x64

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  4011de:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  4011e2:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  4011e4:	625a      	str	r2, [r3, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  4011e6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  4011ea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4011ec:	f022 0204 	bic.w	r2, r2, #4
  4011f0:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  4011f2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4011f4:	f022 0204 	bic.w	r2, r2, #4
  4011f8:	675a      	str	r2, [r3, #116]	; 0x74
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4011fa:	2202      	movs	r2, #2
  4011fc:	631a      	str	r2, [r3, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4011fe:	611a      	str	r2, [r3, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401200:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401204:	4a23      	ldr	r2, [pc, #140]	; (401294 <system_board_init+0xe0>)
  401206:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  40120a:	6311      	str	r1, [r2, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40120c:	6111      	str	r1, [r2, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40120e:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401212:	6314      	str	r4, [r2, #48]	; 0x30
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401214:	6114      	str	r4, [r2, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401216:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  40121a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40121e:	6619      	str	r1, [r3, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401220:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  401224:	6559      	str	r1, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  401226:	6259      	str	r1, [r3, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  401228:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
  40122c:	6f18      	ldr	r0, [r3, #112]	; 0x70
  40122e:	4308      	orrs	r0, r1
  401230:	6718      	str	r0, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401232:	6f58      	ldr	r0, [r3, #116]	; 0x74
  401234:	f020 50c0 	bic.w	r0, r0, #402653184	; 0x18000000
  401238:	6758      	str	r0, [r3, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40123a:	6059      	str	r1, [r3, #4]
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  40123c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401240:	6613      	str	r3, [r2, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401242:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  401246:	6553      	str	r3, [r2, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  401248:	6253      	str	r3, [r2, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  40124a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  40124e:	6f11      	ldr	r1, [r2, #112]	; 0x70
  401250:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  401254:	6711      	str	r1, [r2, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401256:	6f51      	ldr	r1, [r2, #116]	; 0x74
  401258:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  40125c:	6751      	str	r1, [r2, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  40125e:	6053      	str	r3, [r2, #4]
	Pio *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->PIO_PUER = mask;
	} else {
		base->PIO_PUDR = mask;
  401260:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401264:	6613      	str	r3, [r2, #96]	; 0x60

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->PIO_PPDER = mask;
	} else {
		base->PIO_PPDDR = mask;
  401266:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
		base->PIO_MDER = mask;
	} else {
		base->PIO_MDDR = mask;
  40126a:	6553      	str	r3, [r2, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
		base->PIO_IFER = mask;
	} else {
		base->PIO_IFDR = mask;
  40126c:	6253      	str	r3, [r2, #36]	; 0x24
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  40126e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->PIO_ABCDSR[0] |= mask;
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  401272:	6f11      	ldr	r1, [r2, #112]	; 0x70
  401274:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
  401278:	6711      	str	r1, [r2, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->PIO_ABCDSR[1] |= mask;
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  40127a:	6f51      	ldr	r1, [r2, #116]	; 0x74
  40127c:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
  401280:	6751      	str	r1, [r2, #116]	; 0x74
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  401282:	6053      	str	r3, [r2, #4]
  401284:	bd38      	pop	{r3, r4, r5, pc}
  401286:	bf00      	nop
  401288:	400e1450 	.word	0x400e1450
  40128c:	0040152d 	.word	0x0040152d
  401290:	400e0e00 	.word	0x400e0e00
  401294:	400e1000 	.word	0x400e1000

00401298 <flexcom_enable>:
 *
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 *
 */
void flexcom_enable(Flexcom *p_flexcom)
{
  401298:	b508      	push	{r3, lr}
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  40129a:	4b50      	ldr	r3, [pc, #320]	; (4013dc <flexcom_enable+0x144>)
  40129c:	781b      	ldrb	r3, [r3, #0]
  40129e:	2bff      	cmp	r3, #255	; 0xff
  4012a0:	d100      	bne.n	4012a4 <flexcom_enable+0xc>
  4012a2:	e7fe      	b.n	4012a2 <flexcom_enable+0xa>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  4012a4:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  4012a8:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4012aa:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
  4012ae:	2100      	movs	r1, #0
  4012b0:	4a4b      	ldr	r2, [pc, #300]	; (4013e0 <flexcom_enable+0x148>)
  4012b2:	7011      	strb	r1, [r2, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
  4012b4:	4949      	ldr	r1, [pc, #292]	; (4013dc <flexcom_enable+0x144>)
  4012b6:	780a      	ldrb	r2, [r1, #0]
  4012b8:	3201      	adds	r2, #1
  4012ba:	700a      	strb	r2, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  4012bc:	b92b      	cbnz	r3, 4012ca <flexcom_enable+0x32>
		cpu_irq_enable();
  4012be:	2201      	movs	r2, #1
  4012c0:	4b47      	ldr	r3, [pc, #284]	; (4013e0 <flexcom_enable+0x148>)
  4012c2:	701a      	strb	r2, [r3, #0]
  4012c4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4012c8:	b662      	cpsie	i
	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);
	/* Enable PMC clock for FLEXCOM */
#ifdef ID_FLEXCOM7
	 if (p_flexcom == FLEXCOM7) {
  4012ca:	4a46      	ldr	r2, [pc, #280]	; (4013e4 <flexcom_enable+0x14c>)
  4012cc:	4290      	cmp	r0, r2
  4012ce:	d10d      	bne.n	4012ec <flexcom_enable+0x54>
  4012d0:	2007      	movs	r0, #7
  4012d2:	4b45      	ldr	r3, [pc, #276]	; (4013e8 <flexcom_enable+0x150>)
  4012d4:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM7);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  4012d6:	2007      	movs	r0, #7
  4012d8:	4b44      	ldr	r3, [pc, #272]	; (4013ec <flexcom_enable+0x154>)
  4012da:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4012dc:	2007      	movs	r0, #7
  4012de:	2100      	movs	r1, #0
  4012e0:	4b43      	ldr	r3, [pc, #268]	; (4013f0 <flexcom_enable+0x158>)
  4012e2:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4012e4:	2007      	movs	r0, #7
  4012e6:	4b43      	ldr	r3, [pc, #268]	; (4013f4 <flexcom_enable+0x15c>)
  4012e8:	4798      	blx	r3
  4012ea:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM6
	if (p_flexcom == FLEXCOM6) {
  4012ec:	4a42      	ldr	r2, [pc, #264]	; (4013f8 <flexcom_enable+0x160>)
  4012ee:	4290      	cmp	r0, r2
  4012f0:	d10d      	bne.n	40130e <flexcom_enable+0x76>
  4012f2:	2016      	movs	r0, #22
  4012f4:	4b3c      	ldr	r3, [pc, #240]	; (4013e8 <flexcom_enable+0x150>)
  4012f6:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM6);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  4012f8:	2007      	movs	r0, #7
  4012fa:	4b3c      	ldr	r3, [pc, #240]	; (4013ec <flexcom_enable+0x154>)
  4012fc:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4012fe:	2007      	movs	r0, #7
  401300:	2100      	movs	r1, #0
  401302:	4b3b      	ldr	r3, [pc, #236]	; (4013f0 <flexcom_enable+0x158>)
  401304:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  401306:	2007      	movs	r0, #7
  401308:	4b3a      	ldr	r3, [pc, #232]	; (4013f4 <flexcom_enable+0x15c>)
  40130a:	4798      	blx	r3
  40130c:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM5
	if (p_flexcom == FLEXCOM5) {
  40130e:	4a3b      	ldr	r2, [pc, #236]	; (4013fc <flexcom_enable+0x164>)
  401310:	4290      	cmp	r0, r2
  401312:	d10d      	bne.n	401330 <flexcom_enable+0x98>
  401314:	2015      	movs	r0, #21
  401316:	4b34      	ldr	r3, [pc, #208]	; (4013e8 <flexcom_enable+0x150>)
  401318:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM5);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  40131a:	2007      	movs	r0, #7
  40131c:	4b33      	ldr	r3, [pc, #204]	; (4013ec <flexcom_enable+0x154>)
  40131e:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401320:	2007      	movs	r0, #7
  401322:	2100      	movs	r1, #0
  401324:	4b32      	ldr	r3, [pc, #200]	; (4013f0 <flexcom_enable+0x158>)
  401326:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  401328:	2007      	movs	r0, #7
  40132a:	4b32      	ldr	r3, [pc, #200]	; (4013f4 <flexcom_enable+0x15c>)
  40132c:	4798      	blx	r3
  40132e:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM4
	if (p_flexcom == FLEXCOM4) {
  401330:	4a33      	ldr	r2, [pc, #204]	; (401400 <flexcom_enable+0x168>)
  401332:	4290      	cmp	r0, r2
  401334:	d10d      	bne.n	401352 <flexcom_enable+0xba>
  401336:	2014      	movs	r0, #20
  401338:	4b2b      	ldr	r3, [pc, #172]	; (4013e8 <flexcom_enable+0x150>)
  40133a:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM4);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  40133c:	2007      	movs	r0, #7
  40133e:	4b2b      	ldr	r3, [pc, #172]	; (4013ec <flexcom_enable+0x154>)
  401340:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  401342:	2007      	movs	r0, #7
  401344:	2100      	movs	r1, #0
  401346:	4b2a      	ldr	r3, [pc, #168]	; (4013f0 <flexcom_enable+0x158>)
  401348:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  40134a:	2007      	movs	r0, #7
  40134c:	4b29      	ldr	r3, [pc, #164]	; (4013f4 <flexcom_enable+0x15c>)
  40134e:	4798      	blx	r3
  401350:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM3
	if (p_flexcom == FLEXCOM3) {
  401352:	4a2c      	ldr	r2, [pc, #176]	; (401404 <flexcom_enable+0x16c>)
  401354:	4290      	cmp	r0, r2
  401356:	d10d      	bne.n	401374 <flexcom_enable+0xdc>
  401358:	2013      	movs	r0, #19
  40135a:	4b23      	ldr	r3, [pc, #140]	; (4013e8 <flexcom_enable+0x150>)
  40135c:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM3);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  40135e:	2006      	movs	r0, #6
  401360:	4b22      	ldr	r3, [pc, #136]	; (4013ec <flexcom_enable+0x154>)
  401362:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  401364:	2006      	movs	r0, #6
  401366:	2100      	movs	r1, #0
  401368:	4b21      	ldr	r3, [pc, #132]	; (4013f0 <flexcom_enable+0x158>)
  40136a:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40136c:	2006      	movs	r0, #6
  40136e:	4b21      	ldr	r3, [pc, #132]	; (4013f4 <flexcom_enable+0x15c>)
  401370:	4798      	blx	r3
  401372:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM2
	if (p_flexcom == FLEXCOM2) {
  401374:	4a24      	ldr	r2, [pc, #144]	; (401408 <flexcom_enable+0x170>)
  401376:	4290      	cmp	r0, r2
  401378:	d10d      	bne.n	401396 <flexcom_enable+0xfe>
  40137a:	200e      	movs	r0, #14
  40137c:	4b1a      	ldr	r3, [pc, #104]	; (4013e8 <flexcom_enable+0x150>)
  40137e:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM2);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  401380:	2006      	movs	r0, #6
  401382:	4b1a      	ldr	r3, [pc, #104]	; (4013ec <flexcom_enable+0x154>)
  401384:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  401386:	2006      	movs	r0, #6
  401388:	2100      	movs	r1, #0
  40138a:	4b19      	ldr	r3, [pc, #100]	; (4013f0 <flexcom_enable+0x158>)
  40138c:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40138e:	2006      	movs	r0, #6
  401390:	4b18      	ldr	r3, [pc, #96]	; (4013f4 <flexcom_enable+0x15c>)
  401392:	4798      	blx	r3
  401394:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM1
	if (p_flexcom == FLEXCOM1) {
  401396:	4a1d      	ldr	r2, [pc, #116]	; (40140c <flexcom_enable+0x174>)
  401398:	4290      	cmp	r0, r2
  40139a:	d10d      	bne.n	4013b8 <flexcom_enable+0x120>
  40139c:	2009      	movs	r0, #9
  40139e:	4b12      	ldr	r3, [pc, #72]	; (4013e8 <flexcom_enable+0x150>)
  4013a0:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM1);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  4013a2:	2006      	movs	r0, #6
  4013a4:	4b11      	ldr	r3, [pc, #68]	; (4013ec <flexcom_enable+0x154>)
  4013a6:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4013a8:	2006      	movs	r0, #6
  4013aa:	2100      	movs	r1, #0
  4013ac:	4b10      	ldr	r3, [pc, #64]	; (4013f0 <flexcom_enable+0x158>)
  4013ae:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4013b0:	2006      	movs	r0, #6
  4013b2:	4b10      	ldr	r3, [pc, #64]	; (4013f4 <flexcom_enable+0x15c>)
  4013b4:	4798      	blx	r3
  4013b6:	bd08      	pop	{r3, pc}
	} else
#endif
#ifdef ID_FLEXCOM0
	if (p_flexcom == FLEXCOM0) {
  4013b8:	4a15      	ldr	r2, [pc, #84]	; (401410 <flexcom_enable+0x178>)
  4013ba:	4290      	cmp	r0, r2
  4013bc:	d10c      	bne.n	4013d8 <flexcom_enable+0x140>
  4013be:	2008      	movs	r0, #8
  4013c0:	4b09      	ldr	r3, [pc, #36]	; (4013e8 <flexcom_enable+0x150>)
  4013c2:	4798      	blx	r3
		sysclk_enable_peripheral_clock(ID_FLEXCOM0);
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_6);
  4013c4:	2006      	movs	r0, #6
  4013c6:	4b09      	ldr	r3, [pc, #36]	; (4013ec <flexcom_enable+0x154>)
  4013c8:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4013ca:	2006      	movs	r0, #6
  4013cc:	2100      	movs	r1, #0
  4013ce:	4b08      	ldr	r3, [pc, #32]	; (4013f0 <flexcom_enable+0x158>)
  4013d0:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  4013d2:	2006      	movs	r0, #6
  4013d4:	4b07      	ldr	r3, [pc, #28]	; (4013f4 <flexcom_enable+0x15c>)
  4013d6:	4798      	blx	r3
  4013d8:	bd08      	pop	{r3, pc}
  4013da:	bf00      	nop
  4013dc:	2000520c 	.word	0x2000520c
  4013e0:	20000000 	.word	0x20000000
  4013e4:	40034000 	.word	0x40034000
  4013e8:	0040152d 	.word	0x0040152d
  4013ec:	004015d5 	.word	0x004015d5
  4013f0:	00401581 	.word	0x00401581
  4013f4:	004015c5 	.word	0x004015c5
  4013f8:	40040000 	.word	0x40040000
  4013fc:	40008000 	.word	0x40008000
  401400:	4001c000 	.word	0x4001c000
  401404:	40018000 	.word	0x40018000
  401408:	40024000 	.word	0x40024000
  40140c:	40020000 	.word	0x40020000
  401410:	4000c000 	.word	0x4000c000

00401414 <flexcom_set_opmode>:
 * \param opmode  Opration mode.
 *
 */
void flexcom_set_opmode(Flexcom *p_flexcom, enum flexcom_opmode opmode)
{
	p_flexcom->FLEXCOM_MR = opmode;
  401414:	6001      	str	r1, [r0, #0]
  401416:	4770      	bx	lr

00401418 <pdc_tx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  401418:	460b      	mov	r3, r1
  40141a:	b119      	cbz	r1, 401424 <pdc_tx_init+0xc>
		p_pdc->PERIPH_TPR = p_packet->ul_addr;
  40141c:	6809      	ldr	r1, [r1, #0]
  40141e:	6081      	str	r1, [r0, #8]
		p_pdc->PERIPH_TCR = p_packet->ul_size;
  401420:	685b      	ldr	r3, [r3, #4]
  401422:	60c3      	str	r3, [r0, #12]
	}
	if (p_next_packet) {
  401424:	b11a      	cbz	r2, 40142e <pdc_tx_init+0x16>
		p_pdc->PERIPH_TNPR = p_next_packet->ul_addr;
  401426:	6813      	ldr	r3, [r2, #0]
  401428:	6183      	str	r3, [r0, #24]
		p_pdc->PERIPH_TNCR = p_next_packet->ul_size;
  40142a:	6853      	ldr	r3, [r2, #4]
  40142c:	61c3      	str	r3, [r0, #28]
  40142e:	4770      	bx	lr

00401430 <pdc_rx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
  401430:	460b      	mov	r3, r1
  401432:	b119      	cbz	r1, 40143c <pdc_rx_init+0xc>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
  401434:	6809      	ldr	r1, [r1, #0]
  401436:	6001      	str	r1, [r0, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
  401438:	685b      	ldr	r3, [r3, #4]
  40143a:	6043      	str	r3, [r0, #4]
	}
	if (p_next_packet) {
  40143c:	b11a      	cbz	r2, 401446 <pdc_rx_init+0x16>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
  40143e:	6813      	ldr	r3, [r2, #0]
  401440:	6103      	str	r3, [r0, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
  401442:	6853      	ldr	r3, [r2, #4]
  401444:	6143      	str	r3, [r0, #20]
  401446:	4770      	bx	lr

00401448 <pdc_enable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
  401448:	f021 01fe 	bic.w	r1, r1, #254	; 0xfe
  40144c:	05c9      	lsls	r1, r1, #23
  40144e:	0dc9      	lsrs	r1, r1, #23
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  401450:	6201      	str	r1, [r0, #32]
  401452:	4770      	bx	lr

00401454 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  401454:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
  401458:	f021 0101 	bic.w	r1, r1, #1
  40145c:	0589      	lsls	r1, r1, #22
  40145e:	0d89      	lsrs	r1, r1, #22
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  401460:	6201      	str	r1, [r0, #32]
  401462:	4770      	bx	lr

00401464 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  401464:	4a18      	ldr	r2, [pc, #96]	; (4014c8 <pmc_switch_mck_to_pllack+0x64>)
  401466:	6b13      	ldr	r3, [r2, #48]	; 0x30
  401468:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  40146c:	4318      	orrs	r0, r3
  40146e:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401470:	6e93      	ldr	r3, [r2, #104]	; 0x68
  401472:	f013 0f08 	tst.w	r3, #8
  401476:	d003      	beq.n	401480 <pmc_switch_mck_to_pllack+0x1c>
  401478:	e009      	b.n	40148e <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40147a:	3b01      	subs	r3, #1
  40147c:	d103      	bne.n	401486 <pmc_switch_mck_to_pllack+0x22>
  40147e:	e01e      	b.n	4014be <pmc_switch_mck_to_pllack+0x5a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  401480:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401484:	4910      	ldr	r1, [pc, #64]	; (4014c8 <pmc_switch_mck_to_pllack+0x64>)
  401486:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  401488:	f012 0f08 	tst.w	r2, #8
  40148c:	d0f5      	beq.n	40147a <pmc_switch_mck_to_pllack+0x16>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40148e:	4a0e      	ldr	r2, [pc, #56]	; (4014c8 <pmc_switch_mck_to_pllack+0x64>)
  401490:	6b13      	ldr	r3, [r2, #48]	; 0x30
  401492:	f023 0303 	bic.w	r3, r3, #3
  401496:	f043 0302 	orr.w	r3, r3, #2
  40149a:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40149c:	6e90      	ldr	r0, [r2, #104]	; 0x68
  40149e:	f010 0008 	ands.w	r0, r0, #8
  4014a2:	d004      	beq.n	4014ae <pmc_switch_mck_to_pllack+0x4a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4014a4:	2000      	movs	r0, #0
  4014a6:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4014a8:	3b01      	subs	r3, #1
  4014aa:	d103      	bne.n	4014b4 <pmc_switch_mck_to_pllack+0x50>
  4014ac:	e009      	b.n	4014c2 <pmc_switch_mck_to_pllack+0x5e>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4014ae:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4014b2:	4905      	ldr	r1, [pc, #20]	; (4014c8 <pmc_switch_mck_to_pllack+0x64>)
  4014b4:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4014b6:	f012 0f08 	tst.w	r2, #8
  4014ba:	d0f5      	beq.n	4014a8 <pmc_switch_mck_to_pllack+0x44>
  4014bc:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4014be:	2001      	movs	r0, #1
  4014c0:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4014c2:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  4014c4:	4770      	bx	lr
  4014c6:	bf00      	nop
  4014c8:	400e0400 	.word	0x400e0400

004014cc <pmc_switch_sclk_to_32kxtal>:
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  4014cc:	2801      	cmp	r0, #1
  4014ce:	d106      	bne.n	4014de <pmc_switch_sclk_to_32kxtal+0x12>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  4014d0:	4a05      	ldr	r2, [pc, #20]	; (4014e8 <pmc_switch_sclk_to_32kxtal+0x1c>)
  4014d2:	6893      	ldr	r3, [r2, #8]
  4014d4:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  4014d8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4014dc:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  4014de:	4a03      	ldr	r2, [pc, #12]	; (4014ec <pmc_switch_sclk_to_32kxtal+0x20>)
  4014e0:	4b01      	ldr	r3, [pc, #4]	; (4014e8 <pmc_switch_sclk_to_32kxtal+0x1c>)
  4014e2:	601a      	str	r2, [r3, #0]
  4014e4:	4770      	bx	lr
  4014e6:	bf00      	nop
  4014e8:	400e1410 	.word	0x400e1410
  4014ec:	a5000008 	.word	0xa5000008

004014f0 <pmc_osc_is_ready_32kxtal>:
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4014f0:	4b05      	ldr	r3, [pc, #20]	; (401508 <pmc_osc_is_ready_32kxtal+0x18>)
  4014f2:	695b      	ldr	r3, [r3, #20]
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4014f4:	f013 0f80 	tst.w	r3, #128	; 0x80
  4014f8:	bf1d      	ittte	ne
  4014fa:	4b04      	ldrne	r3, [pc, #16]	; (40150c <pmc_osc_is_ready_32kxtal+0x1c>)
  4014fc:	6e98      	ldrne	r0, [r3, #104]	; 0x68
  4014fe:	f3c0 10c0 	ubfxne	r0, r0, #7, #1
  401502:	2000      	moveq	r0, #0
}
  401504:	4770      	bx	lr
  401506:	bf00      	nop
  401508:	400e1410 	.word	0x400e1410
  40150c:	400e0400 	.word	0x400e0400

00401510 <pmc_disable_pllack>:
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
  401510:	2200      	movs	r2, #0
  401512:	4b01      	ldr	r3, [pc, #4]	; (401518 <pmc_disable_pllack+0x8>)
  401514:	629a      	str	r2, [r3, #40]	; 0x28
  401516:	4770      	bx	lr
  401518:	400e0400 	.word	0x400e0400

0040151c <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40151c:	4b02      	ldr	r3, [pc, #8]	; (401528 <pmc_is_locked_pllack+0xc>)
  40151e:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401520:	f000 0002 	and.w	r0, r0, #2
  401524:	4770      	bx	lr
  401526:	bf00      	nop
  401528:	400e0400 	.word	0x400e0400

0040152c <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  40152c:	2832      	cmp	r0, #50	; 0x32
  40152e:	d81e      	bhi.n	40156e <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
  401530:	281f      	cmp	r0, #31
  401532:	d80c      	bhi.n	40154e <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  401534:	4b11      	ldr	r3, [pc, #68]	; (40157c <pmc_enable_periph_clk+0x50>)
  401536:	699a      	ldr	r2, [r3, #24]
  401538:	2301      	movs	r3, #1
  40153a:	4083      	lsls	r3, r0
  40153c:	401a      	ands	r2, r3
  40153e:	4293      	cmp	r3, r2
  401540:	d017      	beq.n	401572 <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
  401542:	2301      	movs	r3, #1
  401544:	4083      	lsls	r3, r0
  401546:	4a0d      	ldr	r2, [pc, #52]	; (40157c <pmc_enable_periph_clk+0x50>)
  401548:	6113      	str	r3, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40154a:	2000      	movs	r0, #0
  40154c:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40154e:	4b0b      	ldr	r3, [pc, #44]	; (40157c <pmc_enable_periph_clk+0x50>)
  401550:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  401554:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401556:	2301      	movs	r3, #1
  401558:	4083      	lsls	r3, r0
  40155a:	401a      	ands	r2, r3
  40155c:	4293      	cmp	r3, r2
  40155e:	d00a      	beq.n	401576 <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
  401560:	2301      	movs	r3, #1
  401562:	4083      	lsls	r3, r0
  401564:	4a05      	ldr	r2, [pc, #20]	; (40157c <pmc_enable_periph_clk+0x50>)
  401566:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  40156a:	2000      	movs	r0, #0
  40156c:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  40156e:	2001      	movs	r0, #1
  401570:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  401572:	2000      	movs	r0, #0
  401574:	4770      	bx	lr
  401576:	2000      	movs	r0, #0
}
  401578:	4770      	bx	lr
  40157a:	bf00      	nop
  40157c:	400e0400 	.word	0x400e0400

00401580 <pmc_switch_pck_to_mck>:
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
  401580:	f041 0104 	orr.w	r1, r1, #4
  401584:	4b0e      	ldr	r3, [pc, #56]	; (4015c0 <pmc_switch_pck_to_mck+0x40>)
  401586:	f100 0210 	add.w	r2, r0, #16
  40158a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  40158e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  401590:	f44f 7180 	mov.w	r1, #256	; 0x100
  401594:	4081      	lsls	r1, r0
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  401596:	ea11 0003 	ands.w	r0, r1, r3
  40159a:	d004      	beq.n	4015a6 <pmc_switch_pck_to_mck+0x26>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  40159c:	2000      	movs	r0, #0
}
  40159e:	4770      	bx	lr
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  4015a0:	3b01      	subs	r3, #1
  4015a2:	d104      	bne.n	4015ae <pmc_switch_pck_to_mck+0x2e>
  4015a4:	e007      	b.n	4015b6 <pmc_switch_pck_to_mck+0x36>
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
  4015a6:	b410      	push	{r4}
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  4015a8:	f44f 6300 	mov.w	r3, #2048	; 0x800
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  4015ac:	4c04      	ldr	r4, [pc, #16]	; (4015c0 <pmc_switch_pck_to_mck+0x40>)
  4015ae:	6ea2      	ldr	r2, [r4, #104]	; 0x68
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
	for (ul_timeout = PMC_TIMEOUT;
  4015b0:	4211      	tst	r1, r2
  4015b2:	d0f5      	beq.n	4015a0 <pmc_switch_pck_to_mck+0x20>
  4015b4:	e000      	b.n	4015b8 <pmc_switch_pck_to_mck+0x38>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4015b6:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  4015b8:	f85d 4b04 	ldr.w	r4, [sp], #4
  4015bc:	4770      	bx	lr
  4015be:	bf00      	nop
  4015c0:	400e0400 	.word	0x400e0400

004015c4 <pmc_enable_pck>:
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_enable_pck(uint32_t ul_id)
{
	PMC->PMC_SCER = PMC_SCER_PCK0 << ul_id;
  4015c4:	f44f 7380 	mov.w	r3, #256	; 0x100
  4015c8:	4083      	lsls	r3, r0
  4015ca:	4a01      	ldr	r2, [pc, #4]	; (4015d0 <pmc_enable_pck+0xc>)
  4015cc:	6013      	str	r3, [r2, #0]
  4015ce:	4770      	bx	lr
  4015d0:	400e0400 	.word	0x400e0400

004015d4 <pmc_disable_pck>:
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_disable_pck(uint32_t ul_id)
{
	PMC->PMC_SCDR = PMC_SCER_PCK0 << ul_id;
  4015d4:	f44f 7380 	mov.w	r3, #256	; 0x100
  4015d8:	4083      	lsls	r3, r0
  4015da:	4a01      	ldr	r2, [pc, #4]	; (4015e0 <pmc_disable_pck+0xc>)
  4015dc:	6053      	str	r3, [r2, #4]
  4015de:	4770      	bx	lr
  4015e0:	400e0400 	.word	0x400e0400

004015e4 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  4015e4:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  4015e6:	010b      	lsls	r3, r1, #4
  4015e8:	4293      	cmp	r3, r2
  4015ea:	d90f      	bls.n	40160c <usart_set_async_baudrate+0x28>
  4015ec:	e01c      	b.n	401628 <usart_set_async_baudrate+0x44>
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  4015ee:	f002 0207 	and.w	r2, r2, #7
		return 1;
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
  4015f2:	6841      	ldr	r1, [r0, #4]
  4015f4:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  4015f8:	6041      	str	r1, [r0, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  4015fa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  4015fe:	6202      	str	r2, [r0, #32]

	return 0;
  401600:	2000      	movs	r0, #0
  401602:	e01e      	b.n	401642 <usart_set_async_baudrate+0x5e>
	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
		return 1;
  401604:	2001      	movs	r0, #1
  401606:	e01c      	b.n	401642 <usart_set_async_baudrate+0x5e>
  401608:	2001      	movs	r0, #1
  40160a:	e01a      	b.n	401642 <usart_set_async_baudrate+0x5e>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  40160c:	00d2      	lsls	r2, r2, #3
  40160e:	eb02 0253 	add.w	r2, r2, r3, lsr #1
  401612:	fbb2 f2f3 	udiv	r2, r2, r3
	cd = cd_fp >> 3;
  401616:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  401618:	1e5c      	subs	r4, r3, #1
  40161a:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  40161e:	428c      	cmp	r4, r1
  401620:	d8f0      	bhi.n	401604 <usart_set_async_baudrate+0x20>
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  401622:	f002 0207 	and.w	r2, r2, #7
  401626:	e7e8      	b.n	4015fa <usart_set_async_baudrate+0x16>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  401628:	00c9      	lsls	r1, r1, #3
  40162a:	00d2      	lsls	r2, r2, #3
  40162c:	eb02 0251 	add.w	r2, r2, r1, lsr #1
  401630:	fbb2 f2f1 	udiv	r2, r2, r1
	cd = cd_fp >> 3;
  401634:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  401636:	1e5c      	subs	r4, r3, #1
  401638:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  40163c:	428c      	cmp	r4, r1
  40163e:	d9d6      	bls.n	4015ee <usart_set_async_baudrate+0xa>
  401640:	e7e2      	b.n	401608 <usart_set_async_baudrate+0x24>

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);

	return 0;
}
  401642:	f85d 4b04 	ldr.w	r4, [sp], #4
  401646:	4770      	bx	lr

00401648 <usart_reset>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  401648:	4b08      	ldr	r3, [pc, #32]	; (40166c <usart_reset+0x24>)
  40164a:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
{
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  40164e:	2300      	movs	r3, #0
  401650:	6043      	str	r3, [r0, #4]
	p_usart->US_RTOR = 0;
  401652:	6243      	str	r3, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
  401654:	6283      	str	r3, [r0, #40]	; 0x28
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  401656:	2388      	movs	r3, #136	; 0x88
  401658:	6003      	str	r3, [r0, #0]
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  40165a:	2324      	movs	r3, #36	; 0x24
  40165c:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  40165e:	f44f 7380 	mov.w	r3, #256	; 0x100
  401662:	6003      	str	r3, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RTSDIS;
  401664:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  401668:	6003      	str	r3, [r0, #0]
  40166a:	4770      	bx	lr
  40166c:	55534100 	.word	0x55534100

00401670 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  401670:	b570      	push	{r4, r5, r6, lr}
  401672:	4605      	mov	r5, r0
  401674:	460c      	mov	r4, r1
  401676:	4616      	mov	r6, r2
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  401678:	4b0f      	ldr	r3, [pc, #60]	; (4016b8 <usart_init_rs232+0x48>)
  40167a:	4798      	blx	r3

	ul_reg_val = 0;
  40167c:	2200      	movs	r2, #0
  40167e:	4b0f      	ldr	r3, [pc, #60]	; (4016bc <usart_init_rs232+0x4c>)
  401680:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  401682:	b19c      	cbz	r4, 4016ac <usart_init_rs232+0x3c>
  401684:	4628      	mov	r0, r5
  401686:	6821      	ldr	r1, [r4, #0]
  401688:	4632      	mov	r2, r6
  40168a:	4b0d      	ldr	r3, [pc, #52]	; (4016c0 <usart_init_rs232+0x50>)
  40168c:	4798      	blx	r3
  40168e:	4602      	mov	r2, r0
  401690:	b970      	cbnz	r0, 4016b0 <usart_init_rs232+0x40>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  401692:	68a1      	ldr	r1, [r4, #8]
  401694:	6863      	ldr	r3, [r4, #4]
  401696:	4319      	orrs	r1, r3
  401698:	6923      	ldr	r3, [r4, #16]
  40169a:	4319      	orrs	r1, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  40169c:	68e3      	ldr	r3, [r4, #12]
  40169e:	430b      	orrs	r3, r1
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4016a0:	4906      	ldr	r1, [pc, #24]	; (4016bc <usart_init_rs232+0x4c>)
  4016a2:	600b      	str	r3, [r1, #0]
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
  4016a4:	6869      	ldr	r1, [r5, #4]
  4016a6:	430b      	orrs	r3, r1
  4016a8:	606b      	str	r3, [r5, #4]

	return 0;
  4016aa:	e002      	b.n	4016b2 <usart_init_rs232+0x42>

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  4016ac:	2201      	movs	r2, #1
  4016ae:	e000      	b.n	4016b2 <usart_init_rs232+0x42>
  4016b0:	2201      	movs	r2, #1
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;

	return 0;
}
  4016b2:	4610      	mov	r0, r2
  4016b4:	bd70      	pop	{r4, r5, r6, pc}
  4016b6:	bf00      	nop
  4016b8:	00401649 	.word	0x00401649
  4016bc:	20000c6c 	.word	0x20000c6c
  4016c0:	004015e5 	.word	0x004015e5

004016c4 <usart_enable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXEN;
  4016c4:	2340      	movs	r3, #64	; 0x40
  4016c6:	6003      	str	r3, [r0, #0]
  4016c8:	4770      	bx	lr
  4016ca:	bf00      	nop

004016cc <usart_disable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXDIS;
  4016cc:	2380      	movs	r3, #128	; 0x80
  4016ce:	6003      	str	r3, [r0, #0]
  4016d0:	4770      	bx	lr
  4016d2:	bf00      	nop

004016d4 <usart_enable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXEN;
  4016d4:	2310      	movs	r3, #16
  4016d6:	6003      	str	r3, [r0, #0]
  4016d8:	4770      	bx	lr
  4016da:	bf00      	nop

004016dc <usart_disable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXDIS;
  4016dc:	2320      	movs	r3, #32
  4016de:	6003      	str	r3, [r0, #0]
  4016e0:	4770      	bx	lr
  4016e2:	bf00      	nop

004016e4 <usart_set_rx_timeout>:
 * \param p_usart Pointer to a USART instance.
 * \param timeout The value of receive timeout.
 */
void usart_set_rx_timeout(Usart *p_usart, uint32_t timeout)
{
	p_usart->US_RTOR = timeout;
  4016e4:	6241      	str	r1, [r0, #36]	; 0x24
  4016e6:	4770      	bx	lr

004016e8 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  4016e8:	6081      	str	r1, [r0, #8]
  4016ea:	4770      	bx	lr

004016ec <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  4016ec:	60c1      	str	r1, [r0, #12]
  4016ee:	4770      	bx	lr

004016f0 <usart_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t usart_get_interrupt_mask(Usart *p_usart)
{
	return p_usart->US_IMR;
  4016f0:	6900      	ldr	r0, [r0, #16]
}
  4016f2:	4770      	bx	lr

004016f4 <usart_get_status>:
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
	return p_usart->US_CSR;
  4016f4:	6940      	ldr	r0, [r0, #20]
}
  4016f6:	4770      	bx	lr

004016f8 <usart_reset_status>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  4016f8:	f44f 7380 	mov.w	r3, #256	; 0x100
  4016fc:	6003      	str	r3, [r0, #0]
  4016fe:	4770      	bx	lr

00401700 <usart_start_rx_timeout>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_start_rx_timeout(Usart *p_usart)
{
	p_usart->US_CR = US_CR_STTTO;
  401700:	f44f 6300 	mov.w	r3, #2048	; 0x800
  401704:	6003      	str	r3, [r0, #0]
  401706:	4770      	bx	lr

00401708 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
  401708:	e7fe      	b.n	401708 <Dummy_Handler>
  40170a:	bf00      	nop

0040170c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  40170c:	b508      	push	{r3, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
  40170e:	4b2a      	ldr	r3, [pc, #168]	; (4017b8 <Reset_Handler+0xac>)
  401710:	4a2a      	ldr	r2, [pc, #168]	; (4017bc <Reset_Handler+0xb0>)
  401712:	429a      	cmp	r2, r3
  401714:	d003      	beq.n	40171e <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
  401716:	4b2a      	ldr	r3, [pc, #168]	; (4017c0 <Reset_Handler+0xb4>)
  401718:	4a27      	ldr	r2, [pc, #156]	; (4017b8 <Reset_Handler+0xac>)
  40171a:	429a      	cmp	r2, r3
  40171c:	d304      	bcc.n	401728 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  40171e:	4b29      	ldr	r3, [pc, #164]	; (4017c4 <Reset_Handler+0xb8>)
  401720:	4a29      	ldr	r2, [pc, #164]	; (4017c8 <Reset_Handler+0xbc>)
  401722:	429a      	cmp	r2, r3
  401724:	d310      	bcc.n	401748 <Reset_Handler+0x3c>
  401726:	e01b      	b.n	401760 <Reset_Handler+0x54>
  401728:	4923      	ldr	r1, [pc, #140]	; (4017b8 <Reset_Handler+0xac>)
  40172a:	1d0a      	adds	r2, r1, #4
  40172c:	4b27      	ldr	r3, [pc, #156]	; (4017cc <Reset_Handler+0xc0>)
  40172e:	1a9b      	subs	r3, r3, r2
  401730:	f023 0303 	bic.w	r3, r3, #3
  401734:	3304      	adds	r3, #4
  401736:	4a21      	ldr	r2, [pc, #132]	; (4017bc <Reset_Handler+0xb0>)
  401738:	4413      	add	r3, r2
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
                        *pDest++ = *pSrc++;
  40173a:	f852 0b04 	ldr.w	r0, [r2], #4
  40173e:	f841 0b04 	str.w	r0, [r1], #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
  401742:	429a      	cmp	r2, r3
  401744:	d1f9      	bne.n	40173a <Reset_Handler+0x2e>
  401746:	e7ea      	b.n	40171e <Reset_Handler+0x12>
  401748:	4b21      	ldr	r3, [pc, #132]	; (4017d0 <Reset_Handler+0xc4>)
  40174a:	4a22      	ldr	r2, [pc, #136]	; (4017d4 <Reset_Handler+0xc8>)
  40174c:	1ad2      	subs	r2, r2, r3
  40174e:	f022 0203 	bic.w	r2, r2, #3
  401752:	441a      	add	r2, r3
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  401754:	3b04      	subs	r3, #4
                *pDest++ = 0;
  401756:	2100      	movs	r1, #0
  401758:	f843 1b04 	str.w	r1, [r3], #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  40175c:	4293      	cmp	r3, r2
  40175e:	d1fb      	bne.n	401758 <Reset_Handler+0x4c>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  401760:	4b1d      	ldr	r3, [pc, #116]	; (4017d8 <Reset_Handler+0xcc>)
  401762:	f023 017f 	bic.w	r1, r3, #127	; 0x7f
  401766:	4a1d      	ldr	r2, [pc, #116]	; (4017dc <Reset_Handler+0xd0>)
  401768:	6091      	str	r1, [r2, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40176a:	f3ef 8210 	mrs	r2, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  40176e:	b672      	cpsid	i
  401770:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
  401774:	2000      	movs	r0, #0
  401776:	491a      	ldr	r1, [pc, #104]	; (4017e0 <Reset_Handler+0xd4>)
  401778:	7008      	strb	r0, [r1, #0]
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  40177a:	481a      	ldr	r0, [pc, #104]	; (4017e4 <Reset_Handler+0xd8>)
  40177c:	6801      	ldr	r1, [r0, #0]
  40177e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  401782:	6001      	str	r1, [r0, #0]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  401784:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb");
  401788:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  40178c:	b92a      	cbnz	r2, 40179a <Reset_Handler+0x8e>
		cpu_irq_enable();
  40178e:	2101      	movs	r1, #1
  401790:	4a13      	ldr	r2, [pc, #76]	; (4017e0 <Reset_Handler+0xd4>)
  401792:	7011      	strb	r1, [r2, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  401794:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  401798:	b662      	cpsie	i

#if __FPU_USED
	fpu_enable();
#endif

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  40179a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  40179e:	f5b3 3f20 	cmp.w	r3, #163840	; 0x28000
  4017a2:	d204      	bcs.n	4017ae <Reset_Handler+0xa2>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  4017a4:	4a0d      	ldr	r2, [pc, #52]	; (4017dc <Reset_Handler+0xd0>)
  4017a6:	6893      	ldr	r3, [r2, #8]
  4017a8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  4017ac:	6093      	str	r3, [r2, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  4017ae:	4b0e      	ldr	r3, [pc, #56]	; (4017e8 <Reset_Handler+0xdc>)
  4017b0:	4798      	blx	r3

        /* Branch to main function */
        main();
  4017b2:	4b0e      	ldr	r3, [pc, #56]	; (4017ec <Reset_Handler+0xe0>)
  4017b4:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  4017b6:	e7fe      	b.n	4017b6 <Reset_Handler+0xaa>
  4017b8:	20000000 	.word	0x20000000
  4017bc:	0040b394 	.word	0x0040b394
  4017c0:	20000a70 	.word	0x20000a70
  4017c4:	20005218 	.word	0x20005218
  4017c8:	20000a70 	.word	0x20000a70
  4017cc:	20000a73 	.word	0x20000a73
  4017d0:	20000a74 	.word	0x20000a74
  4017d4:	2000521b 	.word	0x2000521b
  4017d8:	00400000 	.word	0x00400000
  4017dc:	e000ed00 	.word	0xe000ed00
  4017e0:	20000000 	.word	0x20000000
  4017e4:	e000ed88 	.word	0xe000ed88
  4017e8:	00404439 	.word	0x00404439
  4017ec:	004041cd 	.word	0x004041cd

004017f0 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4017f0:	4b31      	ldr	r3, [pc, #196]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  4017f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4017f4:	f003 0303 	and.w	r3, r3, #3
  4017f8:	2b01      	cmp	r3, #1
  4017fa:	d00f      	beq.n	40181c <SystemCoreClockUpdate+0x2c>
  4017fc:	b113      	cbz	r3, 401804 <SystemCoreClockUpdate+0x14>
  4017fe:	2b02      	cmp	r3, #2
  401800:	d029      	beq.n	401856 <SystemCoreClockUpdate+0x66>
  401802:	e042      	b.n	40188a <SystemCoreClockUpdate+0x9a>
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401804:	4b2d      	ldr	r3, [pc, #180]	; (4018bc <SystemCoreClockUpdate+0xcc>)
  401806:	695b      	ldr	r3, [r3, #20]
  401808:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40180c:	bf14      	ite	ne
  40180e:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401812:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  401816:	4b2a      	ldr	r3, [pc, #168]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  401818:	601a      	str	r2, [r3, #0]
  40181a:	e036      	b.n	40188a <SystemCoreClockUpdate+0x9a>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  40181c:	4b26      	ldr	r3, [pc, #152]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  40181e:	6a1b      	ldr	r3, [r3, #32]
  401820:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  401824:	d003      	beq.n	40182e <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  401826:	4a27      	ldr	r2, [pc, #156]	; (4018c4 <SystemCoreClockUpdate+0xd4>)
  401828:	4b25      	ldr	r3, [pc, #148]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  40182a:	601a      	str	r2, [r3, #0]
  40182c:	e02d      	b.n	40188a <SystemCoreClockUpdate+0x9a>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40182e:	4a26      	ldr	r2, [pc, #152]	; (4018c8 <SystemCoreClockUpdate+0xd8>)
  401830:	4b23      	ldr	r3, [pc, #140]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  401832:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  401834:	4b20      	ldr	r3, [pc, #128]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  401836:	6a1b      	ldr	r3, [r3, #32]
  401838:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40183c:	2b10      	cmp	r3, #16
  40183e:	d002      	beq.n	401846 <SystemCoreClockUpdate+0x56>
  401840:	2b20      	cmp	r3, #32
  401842:	d004      	beq.n	40184e <SystemCoreClockUpdate+0x5e>
  401844:	e021      	b.n	40188a <SystemCoreClockUpdate+0x9a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				break;
			case CKGR_MOR_MOSCRCF_16_MHz:
				SystemCoreClock *= 2U;
  401846:	4a21      	ldr	r2, [pc, #132]	; (4018cc <SystemCoreClockUpdate+0xdc>)
  401848:	4b1d      	ldr	r3, [pc, #116]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  40184a:	601a      	str	r2, [r3, #0]
				break;
  40184c:	e01d      	b.n	40188a <SystemCoreClockUpdate+0x9a>
			case CKGR_MOR_MOSCRCF_24_MHz:
				SystemCoreClock *= 3U;
  40184e:	4a20      	ldr	r2, [pc, #128]	; (4018d0 <SystemCoreClockUpdate+0xe0>)
  401850:	4b1b      	ldr	r3, [pc, #108]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  401852:	601a      	str	r2, [r3, #0]
				break;
  401854:	e019      	b.n	40188a <SystemCoreClockUpdate+0x9a>
				break;
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  401856:	4b19      	ldr	r3, [pc, #100]	; (4018bc <SystemCoreClockUpdate+0xcc>)
  401858:	695b      	ldr	r3, [r3, #20]
  40185a:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40185e:	bf14      	ite	ne
  401860:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401864:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  401868:	4b15      	ldr	r3, [pc, #84]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  40186a:	601a      	str	r2, [r3, #0]
		}
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40186c:	4b12      	ldr	r3, [pc, #72]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  40186e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401870:	f003 0303 	and.w	r3, r3, #3
  401874:	2b02      	cmp	r3, #2
  401876:	d108      	bne.n	40188a <SystemCoreClockUpdate+0x9a>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  401878:	4b0f      	ldr	r3, [pc, #60]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  40187a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40187c:	4910      	ldr	r1, [pc, #64]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  40187e:	f3c3 420c 	ubfx	r2, r3, #16, #13
  401882:	680b      	ldr	r3, [r1, #0]
  401884:	fb02 3303 	mla	r3, r2, r3, r3
  401888:	600b      	str	r3, [r1, #0]
		break;
	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  40188a:	4b0b      	ldr	r3, [pc, #44]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  40188c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40188e:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401892:	2b70      	cmp	r3, #112	; 0x70
  401894:	d107      	bne.n	4018a6 <SystemCoreClockUpdate+0xb6>
		SystemCoreClock /= 3U;
  401896:	4a0a      	ldr	r2, [pc, #40]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  401898:	6813      	ldr	r3, [r2, #0]
  40189a:	490e      	ldr	r1, [pc, #56]	; (4018d4 <SystemCoreClockUpdate+0xe4>)
  40189c:	fba1 1303 	umull	r1, r3, r1, r3
  4018a0:	085b      	lsrs	r3, r3, #1
  4018a2:	6013      	str	r3, [r2, #0]
  4018a4:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4018a6:	4b04      	ldr	r3, [pc, #16]	; (4018b8 <SystemCoreClockUpdate+0xc8>)
  4018a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4018aa:	4905      	ldr	r1, [pc, #20]	; (4018c0 <SystemCoreClockUpdate+0xd0>)
  4018ac:	f3c2 1202 	ubfx	r2, r2, #4, #3
  4018b0:	680b      	ldr	r3, [r1, #0]
  4018b2:	40d3      	lsrs	r3, r2
  4018b4:	600b      	str	r3, [r1, #0]
  4018b6:	4770      	bx	lr
  4018b8:	400e0400 	.word	0x400e0400
  4018bc:	400e1410 	.word	0x400e1410
  4018c0:	20000004 	.word	0x20000004
  4018c4:	00b71b00 	.word	0x00b71b00
  4018c8:	007a1200 	.word	0x007a1200
  4018cc:	00f42400 	.word	0x00f42400
  4018d0:	016e3600 	.word	0x016e3600
  4018d4:	aaaaaaab 	.word	0xaaaaaaab

004018d8 <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  4018d8:	4b12      	ldr	r3, [pc, #72]	; (401924 <system_init_flash+0x4c>)
  4018da:	4298      	cmp	r0, r3
  4018dc:	d804      	bhi.n	4018e8 <system_init_flash+0x10>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4018de:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4018e2:	4b11      	ldr	r3, [pc, #68]	; (401928 <system_init_flash+0x50>)
  4018e4:	601a      	str	r2, [r3, #0]
  4018e6:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  4018e8:	4b10      	ldr	r3, [pc, #64]	; (40192c <system_init_flash+0x54>)
  4018ea:	4298      	cmp	r0, r3
  4018ec:	d803      	bhi.n	4018f6 <system_init_flash+0x1e>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4018ee:	4a10      	ldr	r2, [pc, #64]	; (401930 <system_init_flash+0x58>)
  4018f0:	4b0d      	ldr	r3, [pc, #52]	; (401928 <system_init_flash+0x50>)
  4018f2:	601a      	str	r2, [r3, #0]
  4018f4:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  4018f6:	4b0f      	ldr	r3, [pc, #60]	; (401934 <system_init_flash+0x5c>)
  4018f8:	4298      	cmp	r0, r3
  4018fa:	d803      	bhi.n	401904 <system_init_flash+0x2c>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4018fc:	4a0e      	ldr	r2, [pc, #56]	; (401938 <system_init_flash+0x60>)
  4018fe:	4b0a      	ldr	r3, [pc, #40]	; (401928 <system_init_flash+0x50>)
  401900:	601a      	str	r2, [r3, #0]
  401902:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  401904:	4b0d      	ldr	r3, [pc, #52]	; (40193c <system_init_flash+0x64>)
  401906:	4298      	cmp	r0, r3
  401908:	d803      	bhi.n	401912 <system_init_flash+0x3a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  40190a:	4a0d      	ldr	r2, [pc, #52]	; (401940 <system_init_flash+0x68>)
  40190c:	4b06      	ldr	r3, [pc, #24]	; (401928 <system_init_flash+0x50>)
  40190e:	601a      	str	r2, [r3, #0]
  401910:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  401912:	4b0c      	ldr	r3, [pc, #48]	; (401944 <system_init_flash+0x6c>)
  401914:	4298      	cmp	r0, r3
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401916:	bf94      	ite	ls
  401918:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40191c:	4a0a      	ldrhi	r2, [pc, #40]	; (401948 <system_init_flash+0x70>)
  40191e:	4b02      	ldr	r3, [pc, #8]	; (401928 <system_init_flash+0x50>)
  401920:	601a      	str	r2, [r3, #0]
  401922:	4770      	bx	lr
  401924:	01312cff 	.word	0x01312cff
  401928:	400e0a00 	.word	0x400e0a00
  40192c:	026259ff 	.word	0x026259ff
  401930:	04000100 	.word	0x04000100
  401934:	039386ff 	.word	0x039386ff
  401938:	04000200 	.word	0x04000200
  40193c:	04c4b3ff 	.word	0x04c4b3ff
  401940:	04000300 	.word	0x04000300
  401944:	05f5e0ff 	.word	0x05f5e0ff
  401948:	04000500 	.word	0x04000500

0040194c <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  40194c:	4b09      	ldr	r3, [pc, #36]	; (401974 <_sbrk+0x28>)
  40194e:	681b      	ldr	r3, [r3, #0]
  401950:	b913      	cbnz	r3, 401958 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
  401952:	4a09      	ldr	r2, [pc, #36]	; (401978 <_sbrk+0x2c>)
  401954:	4b07      	ldr	r3, [pc, #28]	; (401974 <_sbrk+0x28>)
  401956:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  401958:	4b06      	ldr	r3, [pc, #24]	; (401974 <_sbrk+0x28>)
  40195a:	681b      	ldr	r3, [r3, #0]

	if (((int)prev_heap + incr) > ramend) {
  40195c:	181a      	adds	r2, r3, r0
  40195e:	4907      	ldr	r1, [pc, #28]	; (40197c <_sbrk+0x30>)
  401960:	4291      	cmp	r1, r2
  401962:	db04      	blt.n	40196e <_sbrk+0x22>
		return (caddr_t) -1;	
	}

	heap += incr;
  401964:	4610      	mov	r0, r2
  401966:	4a03      	ldr	r2, [pc, #12]	; (401974 <_sbrk+0x28>)
  401968:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap;
  40196a:	4618      	mov	r0, r3
  40196c:	4770      	bx	lr
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  40196e:	f04f 30ff 	mov.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  401972:	4770      	bx	lr
  401974:	20000c70 	.word	0x20000c70
  401978:	20008218 	.word	0x20008218
  40197c:	20027ffc 	.word	0x20027ffc

00401980 <I2C_prvLEDTimerCallback>:
#endif		
}


static void I2C_prvLEDTimerCallback(void *pvParameters)
{
  401980:	b508      	push	{r3, lr}

	/* Just to remove compiler warnings. */
	(void) pvParameters;

	/* Toggle an LED to show the system is executing. */
	vParTestToggleLED(I2C_TIMER_LED);
  401982:	2001      	movs	r0, #1
  401984:	4b01      	ldr	r3, [pc, #4]	; (40198c <I2C_prvLEDTimerCallback+0xc>)
  401986:	4798      	blx	r3
  401988:	bd08      	pop	{r3, pc}
  40198a:	bf00      	nop
  40198c:	00404385 	.word	0x00404385

00401990 <i2c_command_task>:
}

/*-----------------------------------------------------------*/

static void i2c_command_task(void *pvParameters)
{
  401990:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  401994:	b089      	sub	sp, #36	; 0x24
	portTickType max_block_time_ticks = 200UL / portTICK_RATE_MS;
	status_code_t status = STATUS_OK;
	const portTickType xDelay = 500;
	xTimerHandle xLEDTimer;
	
	i2c_params_t params = *(i2c_params_t *)pvParameters;
  401996:	7805      	ldrb	r5, [r0, #0]
  401998:	7887      	ldrb	r7, [r0, #2]
  40199a:	6846      	ldr	r6, [r0, #4]
	
	memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  40199c:	4c3e      	ldr	r4, [pc, #248]	; (401a98 <i2c_command_task+0x108>)
  40199e:	4620      	mov	r0, r4
  4019a0:	2100      	movs	r1, #0
  4019a2:	223c      	movs	r2, #60	; 0x3c
  4019a4:	4b3d      	ldr	r3, [pc, #244]	; (401a9c <i2c_command_task+0x10c>)
  4019a6:	4798      	blx	r3
	sprintf((char *) local_buffer,
  4019a8:	46a8      	mov	r8, r5
  4019aa:	4620      	mov	r0, r4
  4019ac:	493c      	ldr	r1, [pc, #240]	; (401aa0 <i2c_command_task+0x110>)
  4019ae:	462a      	mov	r2, r5
  4019b0:	4b3c      	ldr	r3, [pc, #240]	; (401aa4 <i2c_command_task+0x114>)
  4019b2:	4798      	blx	r3
static void printConsole(char *message)
{
	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(message);
  4019b4:	4620      	mov	r0, r4
  4019b6:	4b3c      	ldr	r3, [pc, #240]	; (401aa8 <i2c_command_task+0x118>)
  4019b8:	4798      	blx	r3
			"I2C Task Running (addr=0x%02x)\r\n\r\n",params.chip_address);
	printConsole(local_buffer);	
	
	uint8_t chipAddress =params.chip_address;
	twi_packet_t packet;
	packet.addr[0] = params.chip_offset;
  4019ba:	f88d 700c 	strb.w	r7, [sp, #12]
	packet.addr_length = 1;
  4019be:	2301      	movs	r3, #1
  4019c0:	9304      	str	r3, [sp, #16]
	packet.buffer = data_buf;
  4019c2:	4b3a      	ldr	r3, [pc, #232]	; (401aac <i2c_command_task+0x11c>)
  4019c4:	9305      	str	r3, [sp, #20]
	packet.length = 4;
  4019c6:	2304      	movs	r3, #4
  4019c8:	9306      	str	r3, [sp, #24]
	packet.chip = 0x0;
  4019ca:	2300      	movs	r3, #0
  4019cc:	f88d 301c 	strb.w	r3, [sp, #28]
	
	cli_twi_i2c = (freertos_twi_if) params.twi_if;
  4019d0:	4b37      	ldr	r3, [pc, #220]	; (401ab0 <i2c_command_task+0x120>)
  4019d2:	601e      	str	r6, [r3, #0]
	configASSERT(cli_twi_i2c);	
  4019d4:	b91e      	cbnz	r6, 4019de <i2c_command_task+0x4e>
  4019d6:	4837      	ldr	r0, [pc, #220]	; (401ab4 <i2c_command_task+0x124>)
  4019d8:	21c0      	movs	r1, #192	; 0xc0
  4019da:	4b37      	ldr	r3, [pc, #220]	; (401ab8 <i2c_command_task+0x128>)
  4019dc:	4798      	blx	r3
#ifdef HIKU_I2C_LED_DEBUG	
	/* Create the timer that toggles an LED to show that the system is running,
	and that the other tasks are behaving as expected. */
	xLEDTimer = xTimerCreate((const signed char * const) "LED timer",/* A text name, purely to help debugging. */
  4019de:	4b37      	ldr	r3, [pc, #220]	; (401abc <i2c_command_task+0x12c>)
  4019e0:	9300      	str	r3, [sp, #0]
  4019e2:	4837      	ldr	r0, [pc, #220]	; (401ac0 <i2c_command_task+0x130>)
  4019e4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  4019e8:	2201      	movs	r2, #1
  4019ea:	2300      	movs	r3, #0
  4019ec:	4c35      	ldr	r4, [pc, #212]	; (401ac4 <i2c_command_task+0x134>)
  4019ee:	47a0      	blx	r4
							I2C_prvLEDTimerCallback			/* The function that is called each time the timer expires. */
							);

	/* Sanity check the timer's creation, then start the timer.  The timer
	will not actually start until the FreeRTOS kernel is started. */
	configASSERT(xLEDTimer);
  4019f0:	4604      	mov	r4, r0
  4019f2:	b918      	cbnz	r0, 4019fc <i2c_command_task+0x6c>
  4019f4:	482f      	ldr	r0, [pc, #188]	; (401ab4 <i2c_command_task+0x124>)
  4019f6:	21cd      	movs	r1, #205	; 0xcd
  4019f8:	4b2f      	ldr	r3, [pc, #188]	; (401ab8 <i2c_command_task+0x128>)
  4019fa:	4798      	blx	r3
	xTimerStart(xLEDTimer, I2C_DONT_BLOCK);	
  4019fc:	4b32      	ldr	r3, [pc, #200]	; (401ac8 <i2c_command_task+0x138>)
  4019fe:	4798      	blx	r3
  401a00:	4602      	mov	r2, r0
  401a02:	2300      	movs	r3, #0
  401a04:	9300      	str	r3, [sp, #0]
  401a06:	4620      	mov	r0, r4
  401a08:	4619      	mov	r1, r3
  401a0a:	4c30      	ldr	r4, [pc, #192]	; (401acc <i2c_command_task+0x13c>)
  401a0c:	47a0      	blx	r4
#endif /* HIKU_I2C_LED_DEBUG */	
	
	for (;;) {	
		
		packet.chip = chipAddress;
		memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  401a0e:	4c22      	ldr	r4, [pc, #136]	; (401a98 <i2c_command_task+0x108>)
  401a10:	4f22      	ldr	r7, [pc, #136]	; (401a9c <i2c_command_task+0x10c>)
		sprintf((char *) local_buffer,"I2C Probe: addr=0x%x status:%ld\r\n\r\n",
  401a12:	4e27      	ldr	r6, [pc, #156]	; (401ab0 <i2c_command_task+0x120>)

#endif /* HIKU_I2C_LED_DEBUG */	
	
	for (;;) {	
		
		packet.chip = chipAddress;
  401a14:	f88d 501c 	strb.w	r5, [sp, #28]
		memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  401a18:	4620      	mov	r0, r4
  401a1a:	2100      	movs	r1, #0
  401a1c:	223c      	movs	r2, #60	; 0x3c
  401a1e:	47b8      	blx	r7
		sprintf((char *) local_buffer,"I2C Probe: addr=0x%x status:%ld\r\n\r\n",
  401a20:	6830      	ldr	r0, [r6, #0]
  401a22:	4629      	mov	r1, r5
  401a24:	4b2a      	ldr	r3, [pc, #168]	; (401ad0 <i2c_command_task+0x140>)
  401a26:	4798      	blx	r3
  401a28:	4603      	mov	r3, r0
  401a2a:	4620      	mov	r0, r4
  401a2c:	4929      	ldr	r1, [pc, #164]	; (401ad4 <i2c_command_task+0x144>)
  401a2e:	4642      	mov	r2, r8
  401a30:	f8df c070 	ldr.w	ip, [pc, #112]	; 401aa4 <i2c_command_task+0x114>
  401a34:	47e0      	blx	ip
static void printConsole(char *message)
{
	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(message);
  401a36:	4620      	mov	r0, r4
  401a38:	4b1b      	ldr	r3, [pc, #108]	; (401aa8 <i2c_command_task+0x118>)
  401a3a:	4798      	blx	r3
		memset((void *) local_buffer, 0x00, sizeof(local_buffer));
		sprintf((char *) local_buffer,"I2C Probe: addr=0x%x status:%ld\r\n\r\n",
			chipAddress,(twi_probe(cli_twi_i2c, chipAddress)));
		printConsole(local_buffer);			
		
		if((status=freertos_twi_read_packet(cli_twi_i2c, &packet, max_block_time_ticks)) != STATUS_OK)
  401a3c:	6830      	ldr	r0, [r6, #0]
  401a3e:	a903      	add	r1, sp, #12
  401a40:	22c8      	movs	r2, #200	; 0xc8
  401a42:	2300      	movs	r3, #0
  401a44:	f8df c09c 	ldr.w	ip, [pc, #156]	; 401ae4 <i2c_command_task+0x154>
  401a48:	47e0      	blx	ip
  401a4a:	4681      	mov	r9, r0
  401a4c:	b170      	cbz	r0, 401a6c <i2c_command_task+0xdc>
		{
			memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  401a4e:	4620      	mov	r0, r4
  401a50:	2100      	movs	r1, #0
  401a52:	223c      	movs	r2, #60	; 0x3c
  401a54:	47b8      	blx	r7
			sprintf((char *) local_buffer,"I2C Read Packet:addr=0x%x status:%ld\r\n\r\n",
  401a56:	4620      	mov	r0, r4
  401a58:	491f      	ldr	r1, [pc, #124]	; (401ad8 <i2c_command_task+0x148>)
  401a5a:	4642      	mov	r2, r8
  401a5c:	464b      	mov	r3, r9
  401a5e:	f8df c044 	ldr.w	ip, [pc, #68]	; 401aa4 <i2c_command_task+0x114>
  401a62:	47e0      	blx	ip
static void printConsole(char *message)
{
	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(message);
  401a64:	4620      	mov	r0, r4
  401a66:	4b10      	ldr	r3, [pc, #64]	; (401aa8 <i2c_command_task+0x118>)
  401a68:	4798      	blx	r3
  401a6a:	e010      	b.n	401a8e <i2c_command_task+0xfe>
					chipAddress,status);
			printConsole(local_buffer);	
		}
		else
		{
			memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  401a6c:	4620      	mov	r0, r4
  401a6e:	2100      	movs	r1, #0
  401a70:	223c      	movs	r2, #60	; 0x3c
  401a72:	47b8      	blx	r7
			sprintf((char *) local_buffer,"I2C Read Packet:addr=0x%x status:%ld, buff=0x%02x\r\n\r\n",
			chipAddress,status,*data_buf);
  401a74:	4b0d      	ldr	r3, [pc, #52]	; (401aac <i2c_command_task+0x11c>)
			printConsole(local_buffer);	
		}
		else
		{
			memset((void *) local_buffer, 0x00, sizeof(local_buffer));
			sprintf((char *) local_buffer,"I2C Read Packet:addr=0x%x status:%ld, buff=0x%02x\r\n\r\n",
  401a76:	781b      	ldrb	r3, [r3, #0]
  401a78:	9300      	str	r3, [sp, #0]
  401a7a:	4620      	mov	r0, r4
  401a7c:	4917      	ldr	r1, [pc, #92]	; (401adc <i2c_command_task+0x14c>)
  401a7e:	4642      	mov	r2, r8
  401a80:	2300      	movs	r3, #0
  401a82:	f8df c020 	ldr.w	ip, [pc, #32]	; 401aa4 <i2c_command_task+0x114>
  401a86:	47e0      	blx	ip
static void printConsole(char *message)
{
	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(message);
  401a88:	4620      	mov	r0, r4
  401a8a:	4b07      	ldr	r3, [pc, #28]	; (401aa8 <i2c_command_task+0x118>)
  401a8c:	4798      	blx	r3
			memset((void *) local_buffer, 0x00, sizeof(local_buffer));
			sprintf((char *) local_buffer,"I2C Read Packet:addr=0x%x status:%ld, buff=0x%02x\r\n\r\n",
			chipAddress,status,*data_buf);
			printConsole(local_buffer);			
		}
		vTaskDelay(xDelay);
  401a8e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  401a92:	4b13      	ldr	r3, [pc, #76]	; (401ae0 <i2c_command_task+0x150>)
  401a94:	4798      	blx	r3
	}
  401a96:	e7bd      	b.n	401a14 <i2c_command_task+0x84>
  401a98:	20000c74 	.word	0x20000c74
  401a9c:	00404621 	.word	0x00404621
  401aa0:	0040982c 	.word	0x0040982c
  401aa4:	004046bd 	.word	0x004046bd
  401aa8:	00401db1 	.word	0x00401db1
  401aac:	20000cb4 	.word	0x20000cb4
  401ab0:	20000cb0 	.word	0x20000cb0
  401ab4:	00409850 	.word	0x00409850
  401ab8:	004041a5 	.word	0x004041a5
  401abc:	00401981 	.word	0x00401981
  401ac0:	004098a4 	.word	0x004098a4
  401ac4:	00403af9 	.word	0x00403af9
  401ac8:	00403085 	.word	0x00403085
  401acc:	00403b51 	.word	0x00403b51
  401ad0:	0040078d 	.word	0x0040078d
  401ad4:	004098b0 	.word	0x004098b0
  401ad8:	004098d4 	.word	0x004098d4
  401adc:	00409900 	.word	0x00409900
  401ae0:	004032fd 	.word	0x004032fd
  401ae4:	004002d1 	.word	0x004002d1

00401ae8 <create_twi_i2c_test_task>:
static freertos_twi_if cli_twi_i2c = NULL;

/*-----------------------------------------------------------*/

void create_twi_i2c_test_task(Twi *twi_base, uint16_t stack_depth_words, unsigned portBASE_TYPE task_priority, portBASE_TYPE set_asynchronous_api)
{
  401ae8:	b5f0      	push	{r4, r5, r6, r7, lr}
  401aea:	b089      	sub	sp, #36	; 0x24
  401aec:	4605      	mov	r5, r0
  401aee:	460e      	mov	r6, r1
  401af0:	4617      	mov	r7, r2
	freertos_twi_if freertos_i2c;
	
	freertos_peripheral_options_t driver_options = {
  401af2:	4b14      	ldr	r3, [pc, #80]	; (401b44 <create_twi_i2c_test_task+0x5c>)
  401af4:	ac04      	add	r4, sp, #16
  401af6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  401af8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		TWI_I2C_MASTER,									/* Configure the USART for RS232 operation. */
		(USE_TX_ACCESS_MUTEX | USE_RX_ACCESS_MUTEX | WAIT_TX_COMPLETE | WAIT_RX_COMPLETE)		/* Use access mutex on Tx (as more than one task transmits) but not Rx. Wait for a Tx to complete before returning from send functions. */
	};

	/* Initialise the TWI interface. */
	freertos_i2c = freertos_twi_master_init(twi_base, &driver_options);
  401afc:	4628      	mov	r0, r5
  401afe:	4621      	mov	r1, r4
  401b00:	4b11      	ldr	r3, [pc, #68]	; (401b48 <create_twi_i2c_test_task+0x60>)
  401b02:	4798      	blx	r3
	configASSERT(freertos_i2c);
  401b04:	4604      	mov	r4, r0
  401b06:	b918      	cbnz	r0, 401b10 <create_twi_i2c_test_task+0x28>
  401b08:	4810      	ldr	r0, [pc, #64]	; (401b4c <create_twi_i2c_test_task+0x64>)
  401b0a:	218f      	movs	r1, #143	; 0x8f
  401b0c:	4b10      	ldr	r3, [pc, #64]	; (401b50 <create_twi_i2c_test_task+0x68>)
  401b0e:	4798      	blx	r3
	twi_set_speed(twi_base, 400000, sysclk_get_cpu_hz());
  401b10:	4628      	mov	r0, r5
  401b12:	4910      	ldr	r1, [pc, #64]	; (401b54 <create_twi_i2c_test_task+0x6c>)
  401b14:	4a10      	ldr	r2, [pc, #64]	; (401b58 <create_twi_i2c_test_task+0x70>)
  401b16:	4b11      	ldr	r3, [pc, #68]	; (401b5c <create_twi_i2c_test_task+0x74>)
  401b18:	4798      	blx	r3
	/* Register the default CLI commands. */
	//vRegisterCLICommands();
	
	i2c_params_t *prms = (i2c_params_t *)pvPortMalloc(sizeof(i2c_params_t));
  401b1a:	2008      	movs	r0, #8
  401b1c:	4b10      	ldr	r3, [pc, #64]	; (401b60 <create_twi_i2c_test_task+0x78>)
  401b1e:	4798      	blx	r3
  401b20:	4603      	mov	r3, r0
	prms->chip_address = 0x4F;
  401b22:	224f      	movs	r2, #79	; 0x4f
  401b24:	7002      	strb	r2, [r0, #0]
	prms->chip_offset = 0x0;
  401b26:	2200      	movs	r2, #0
  401b28:	7082      	strb	r2, [r0, #2]
	prms->twi_if = freertos_i2c;
  401b2a:	6044      	str	r4, [r0, #4]
	/* Create the USART CLI task. */
	xTaskCreate(	i2c_command_task,			/* The task that implements the command console. */
  401b2c:	9700      	str	r7, [sp, #0]
  401b2e:	9201      	str	r2, [sp, #4]
  401b30:	9202      	str	r2, [sp, #8]
  401b32:	9203      	str	r2, [sp, #12]
  401b34:	480b      	ldr	r0, [pc, #44]	; (401b64 <create_twi_i2c_test_task+0x7c>)
  401b36:	490c      	ldr	r1, [pc, #48]	; (401b68 <create_twi_i2c_test_task+0x80>)
  401b38:	4632      	mov	r2, r6
  401b3a:	4c0c      	ldr	r4, [pc, #48]	; (401b6c <create_twi_i2c_test_task+0x84>)
  401b3c:	47a0      	blx	r4
					(const int8_t *const) "I2C_CLI",	/* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
					stack_depth_words,					/* The size of the stack allocated to the task. */
					(void *) (prms),			/* The parameter is used to pass the already configured USART port into the task. */
					task_priority,						/* The priority allocated to the task. */
					NULL);								/* Used to store the handle to the created task - in this case the handle is not required. */
}
  401b3e:	b009      	add	sp, #36	; 0x24
  401b40:	bdf0      	pop	{r4, r5, r6, r7, pc}
  401b42:	bf00      	nop
  401b44:	0040981c 	.word	0x0040981c
  401b48:	004001a5 	.word	0x004001a5
  401b4c:	00409850 	.word	0x00409850
  401b50:	004041a5 	.word	0x004041a5
  401b54:	00061a80 	.word	0x00061a80
  401b58:	07270000 	.word	0x07270000
  401b5c:	004006a9 	.word	0x004006a9
  401b60:	00402499 	.word	0x00402499
  401b64:	00401991 	.word	0x00401991
  401b68:	00409938 	.word	0x00409938
  401b6c:	00402d4d 	.word	0x00402d4d

00401b70 <usart_command_console_task>:
}

/*-----------------------------------------------------------*/

static void usart_command_console_task(void *pvParameters)
{
  401b70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401b74:	b087      	sub	sp, #28
	static int8_t input_string[MAX_INPUT_SIZE],
			last_input_string[MAX_INPUT_SIZE];
	portBASE_TYPE returned_value;
	portTickType max_block_time_ticks = 200UL / portTICK_RATE_MS;

	cli_usart = (freertos_usart_if) pvParameters;
  401b76:	4b5f      	ldr	r3, [pc, #380]	; (401cf4 <usart_command_console_task+0x184>)
  401b78:	6018      	str	r0, [r3, #0]
	configASSERT(cli_usart);
  401b7a:	b918      	cbnz	r0, 401b84 <usart_command_console_task+0x14>
  401b7c:	485e      	ldr	r0, [pc, #376]	; (401cf8 <usart_command_console_task+0x188>)
  401b7e:	2194      	movs	r1, #148	; 0x94
  401b80:	4b5e      	ldr	r3, [pc, #376]	; (401cfc <usart_command_console_task+0x18c>)
  401b82:	4798      	blx	r3

	/* Obtain the address of the output buffer.  Note there is no mutual
	exclusion on this buffer as it is assumed only one command console
	interface will be used at any one time. */
	output_string = (uint8_t *) FreeRTOS_CLIGetOutputBuffer();
  401b84:	4b5e      	ldr	r3, [pc, #376]	; (401d00 <usart_command_console_task+0x190>)
  401b86:	4798      	blx	r3
  401b88:	4604      	mov	r4, r0
  401b8a:	9002      	str	r0, [sp, #8]

	/* Send the welcome message.  The message is copied into RAM first as the
	DMA cannot send from Flash addresses. */
	strcpy((char *) output_string, (char *) welcome_message);
  401b8c:	495d      	ldr	r1, [pc, #372]	; (401d04 <usart_command_console_task+0x194>)
  401b8e:	2250      	movs	r2, #80	; 0x50
  401b90:	4b5d      	ldr	r3, [pc, #372]	; (401d08 <usart_command_console_task+0x198>)
  401b92:	4798      	blx	r3
	freertos_usart_write_packet(cli_usart, output_string,
  401b94:	4b57      	ldr	r3, [pc, #348]	; (401cf4 <usart_command_console_task+0x184>)
  401b96:	6818      	ldr	r0, [r3, #0]
  401b98:	2600      	movs	r6, #0
  401b9a:	9600      	str	r6, [sp, #0]
  401b9c:	4621      	mov	r1, r4
  401b9e:	224f      	movs	r2, #79	; 0x4f
  401ba0:	23c8      	movs	r3, #200	; 0xc8
  401ba2:	4d5a      	ldr	r5, [pc, #360]	; (401d0c <usart_command_console_task+0x19c>)
  401ba4:	47a8      	blx	r5
			strlen((char *) welcome_message),
			max_block_time_ticks);

	for (;;) {
		/* Only interested in reading one character at a time. */
		if (freertos_usart_serial_read_packet(cli_usart,
  401ba6:	4d53      	ldr	r5, [pc, #332]	; (401cf4 <usart_command_console_task+0x184>)
  401ba8:	4f59      	ldr	r7, [pc, #356]	; (401d10 <usart_command_console_task+0x1a0>)
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
						input_string[input_index] = received_char;
  401baa:	f8df 8178 	ldr.w	r8, [pc, #376]	; 401d24 <usart_command_console_task+0x1b4>
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
  401bae:	f108 0304 	add.w	r3, r8, #4
  401bb2:	9303      	str	r3, [sp, #12]
  401bb4:	f108 0b08 	add.w	fp, r8, #8
			strlen((char *) welcome_message),
			max_block_time_ticks);

	for (;;) {
		/* Only interested in reading one character at a time. */
		if (freertos_usart_serial_read_packet(cli_usart,
  401bb8:	6828      	ldr	r0, [r5, #0]
  401bba:	f10d 0117 	add.w	r1, sp, #23
  401bbe:	2201      	movs	r2, #1
  401bc0:	f04f 33ff 	mov.w	r3, #4294967295
  401bc4:	47b8      	blx	r7
  401bc6:	2801      	cmp	r0, #1
  401bc8:	d1f6      	bne.n	401bb8 <usart_command_console_task+0x48>
				&received_char, sizeof(received_char),
				portMAX_DELAY) == sizeof(received_char)) {
			/* Echo the character. */
			freertos_usart_write_packet(cli_usart, &received_char,
  401bca:	2300      	movs	r3, #0
  401bcc:	9300      	str	r3, [sp, #0]
  401bce:	6828      	ldr	r0, [r5, #0]
  401bd0:	f10d 0117 	add.w	r1, sp, #23
  401bd4:	2201      	movs	r2, #1
  401bd6:	23c8      	movs	r3, #200	; 0xc8
  401bd8:	f8df c130 	ldr.w	ip, [pc, #304]	; 401d0c <usart_command_console_task+0x19c>
  401bdc:	47e0      	blx	ip
					sizeof(received_char),
					max_block_time_ticks);

			if (received_char == '\r') {
  401bde:	f89d 3017 	ldrb.w	r3, [sp, #23]
  401be2:	2b0d      	cmp	r3, #13
  401be4:	d170      	bne.n	401cc8 <usart_command_console_task+0x158>
				/* Start to transmit a line separator, just to make the output
				easier to read. */
				strcpy((char *) output_string,
  401be6:	4b4b      	ldr	r3, [pc, #300]	; (401d14 <usart_command_console_task+0x1a4>)
  401be8:	881a      	ldrh	r2, [r3, #0]
  401bea:	789b      	ldrb	r3, [r3, #2]
  401bec:	9802      	ldr	r0, [sp, #8]
  401bee:	4601      	mov	r1, r0
  401bf0:	8002      	strh	r2, [r0, #0]
  401bf2:	7083      	strb	r3, [r0, #2]
						(char *) new_line);
				freertos_usart_write_packet(cli_usart,
  401bf4:	2300      	movs	r3, #0
  401bf6:	9300      	str	r3, [sp, #0]
  401bf8:	6828      	ldr	r0, [r5, #0]
  401bfa:	2202      	movs	r2, #2
  401bfc:	23c8      	movs	r3, #200	; 0xc8
  401bfe:	f8df c10c 	ldr.w	ip, [pc, #268]	; 401d0c <usart_command_console_task+0x19c>
  401c02:	47e0      	blx	ip
						(char *) new_line),
						max_block_time_ticks);

				/* See if the command is empty, indicating that the last command
				is to be executed again. */
				if (input_index == 0) {
  401c04:	b91e      	cbnz	r6, 401c0e <usart_command_console_task+0x9e>
					strcpy((char *) input_string,
  401c06:	4640      	mov	r0, r8
  401c08:	4943      	ldr	r1, [pc, #268]	; (401d18 <usart_command_console_task+0x1a8>)
  401c0a:	4b44      	ldr	r3, [pc, #272]	; (401d1c <usart_command_console_task+0x1ac>)
  401c0c:	4798      	blx	r3
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
  401c0e:	f8df a118 	ldr.w	sl, [pc, #280]	; 401d28 <usart_command_console_task+0x1b8>
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Start the USART transmitting the generated string. */
					freertos_usart_write_packet(cli_usart,
  401c12:	f8df 9118 	ldr.w	r9, [pc, #280]	; 401d2c <usart_command_console_task+0x1bc>
				command interpreter is called repeatedly until it returns pdFALSE as
				it might generate more than one string. */
				do {
					/* Get the string to write to the UART from the command
					interpreter. */
					returned_value = FreeRTOS_CLIProcessCommand(
  401c16:	4640      	mov	r0, r8
  401c18:	9c02      	ldr	r4, [sp, #8]
  401c1a:	4621      	mov	r1, r4
  401c1c:	f44f 72c8 	mov.w	r2, #400	; 0x190
  401c20:	47d0      	blx	sl
  401c22:	4606      	mov	r6, r0
							input_string,
							(int8_t *) output_string,
							configCOMMAND_INT_MAX_OUTPUT_SIZE);

					/* Start the USART transmitting the generated string. */
					freertos_usart_write_packet(cli_usart,
  401c24:	4620      	mov	r0, r4
  401c26:	47c8      	blx	r9
  401c28:	4602      	mov	r2, r0
  401c2a:	2300      	movs	r3, #0
  401c2c:	9300      	str	r3, [sp, #0]
  401c2e:	6828      	ldr	r0, [r5, #0]
  401c30:	4621      	mov	r1, r4
  401c32:	23c8      	movs	r3, #200	; 0xc8
  401c34:	4c35      	ldr	r4, [pc, #212]	; (401d0c <usart_command_console_task+0x19c>)
  401c36:	47a0      	blx	r4
							output_string,
							strlen((char *)
							output_string),
							max_block_time_ticks);
				} while (returned_value != pdFALSE);
  401c38:	2e00      	cmp	r6, #0
  401c3a:	d1ec      	bne.n	401c16 <usart_command_console_task+0xa6>

				/* All the strings generated by the input command have been sent.
				Clear the input	string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy((char *) last_input_string,
  401c3c:	4836      	ldr	r0, [pc, #216]	; (401d18 <usart_command_console_task+0x1a8>)
  401c3e:	4641      	mov	r1, r8
  401c40:	4b36      	ldr	r3, [pc, #216]	; (401d1c <usart_command_console_task+0x1ac>)
  401c42:	4798      	blx	r3
						(char *) input_string);
				input_index = 0;
				memset(input_string, 0x00, MAX_INPUT_SIZE);
  401c44:	2200      	movs	r2, #0
  401c46:	f8c8 2000 	str.w	r2, [r8]
  401c4a:	9b03      	ldr	r3, [sp, #12]
  401c4c:	601a      	str	r2, [r3, #0]
  401c4e:	465b      	mov	r3, fp
  401c50:	f843 2b04 	str.w	r2, [r3], #4
  401c54:	f8cb 2004 	str.w	r2, [fp, #4]
  401c58:	3304      	adds	r3, #4
  401c5a:	f843 2b04 	str.w	r2, [r3], #4
  401c5e:	f843 2b04 	str.w	r2, [r3], #4
  401c62:	f843 2b04 	str.w	r2, [r3], #4
  401c66:	f843 2b04 	str.w	r2, [r3], #4
  401c6a:	f843 2b04 	str.w	r2, [r3], #4
  401c6e:	f843 2b04 	str.w	r2, [r3], #4
  401c72:	f843 2b04 	str.w	r2, [r3], #4
  401c76:	f843 2b04 	str.w	r2, [r3], #4
  401c7a:	801a      	strh	r2, [r3, #0]

				/* Start to transmit a line separator, just to make the output
				easier to read. */
				strcpy((char *) output_string,
  401c7c:	4e28      	ldr	r6, [pc, #160]	; (401d20 <usart_command_console_task+0x1b0>)
  401c7e:	f8dd e008 	ldr.w	lr, [sp, #8]
  401c82:	f106 0930 	add.w	r9, r6, #48	; 0x30
  401c86:	4634      	mov	r4, r6
  401c88:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  401c8a:	f8ce 0000 	str.w	r0, [lr]
  401c8e:	f8ce 1004 	str.w	r1, [lr, #4]
  401c92:	f8ce 2008 	str.w	r2, [lr, #8]
  401c96:	f8ce 300c 	str.w	r3, [lr, #12]
  401c9a:	4626      	mov	r6, r4
  401c9c:	f10e 0e10 	add.w	lr, lr, #16
  401ca0:	454c      	cmp	r4, r9
  401ca2:	d1f0      	bne.n	401c86 <usart_command_console_task+0x116>
  401ca4:	ce03      	ldmia	r6!, {r0, r1}
  401ca6:	f8ce 0000 	str.w	r0, [lr]
  401caa:	f8ce 1004 	str.w	r1, [lr, #4]
  401cae:	7833      	ldrb	r3, [r6, #0]
  401cb0:	f88e 3008 	strb.w	r3, [lr, #8]
						(char *) line_separator);
				freertos_usart_write_packet(cli_usart,
  401cb4:	2600      	movs	r6, #0
  401cb6:	9600      	str	r6, [sp, #0]
  401cb8:	6828      	ldr	r0, [r5, #0]
  401cba:	9902      	ldr	r1, [sp, #8]
  401cbc:	2238      	movs	r2, #56	; 0x38
  401cbe:	23c8      	movs	r3, #200	; 0xc8
  401cc0:	f8df c048 	ldr.w	ip, [pc, #72]	; 401d0c <usart_command_console_task+0x19c>
  401cc4:	47e0      	blx	ip
  401cc6:	e777      	b.n	401bb8 <usart_command_console_task+0x48>
						output_string, strlen(
						(char *) line_separator),
						max_block_time_ticks);
			} else {
				if (received_char == '\n') {
  401cc8:	2b0a      	cmp	r3, #10
  401cca:	f43f af75 	beq.w	401bb8 <usart_command_console_task+0x48>
					/* Ignore the character. */
				} else if (received_char == '\b') {
  401cce:	2b08      	cmp	r3, #8
  401cd0:	d108      	bne.n	401ce4 <usart_command_console_task+0x174>
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if (input_index > 0) {
  401cd2:	2e00      	cmp	r6, #0
  401cd4:	f43f af70 	beq.w	401bb8 <usart_command_console_task+0x48>
						input_index--;
  401cd8:	3e01      	subs	r6, #1
  401cda:	b2f6      	uxtb	r6, r6
						input_string[input_index] = '\0';
  401cdc:	2300      	movs	r3, #0
  401cde:	f808 3006 	strb.w	r3, [r8, r6]
  401ce2:	e769      	b.n	401bb8 <usart_command_console_task+0x48>
					}
				} else {
					/* A character was entered.  Add it to the string
					entered so far.  When a \n is entered the complete
					string will be passed to the command interpreter. */
					if (input_index < MAX_INPUT_SIZE) {
  401ce4:	2e31      	cmp	r6, #49	; 0x31
  401ce6:	f63f af67 	bhi.w	401bb8 <usart_command_console_task+0x48>
						input_string[input_index] = received_char;
  401cea:	f808 3006 	strb.w	r3, [r8, r6]
						input_index++;
  401cee:	3601      	adds	r6, #1
  401cf0:	b2f6      	uxtb	r6, r6
  401cf2:	e761      	b.n	401bb8 <usart_command_console_task+0x48>
  401cf4:	20000d54 	.word	0x20000d54
  401cf8:	00409968 	.word	0x00409968
  401cfc:	004041a5 	.word	0x004041a5
  401d00:	00402185 	.word	0x00402185
  401d04:	004099bc 	.word	0x004099bc
  401d08:	004044ed 	.word	0x004044ed
  401d0c:	00400f9d 	.word	0x00400f9d
  401d10:	00401025 	.word	0x00401025
  401d14:	0040984c 	.word	0x0040984c
  401d18:	20000cec 	.word	0x20000cec
  401d1c:	00404a3d 	.word	0x00404a3d
  401d20:	00409a0c 	.word	0x00409a0c
  401d24:	20000d20 	.word	0x20000d20
  401d28:	0040208d 	.word	0x0040208d
  401d2c:	00404af9 	.word	0x00404af9

00401d30 <create_usart_cli_task>:

/*-----------------------------------------------------------*/

void create_usart_cli_task(Usart *usart_base, uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority)
{
  401d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401d34:	b08e      	sub	sp, #56	; 0x38
  401d36:	4686      	mov	lr, r0
  401d38:	460f      	mov	r7, r1
  401d3a:	4690      	mov	r8, r2
	freertos_usart_if freertos_usart;
	freertos_peripheral_options_t driver_options = {
  401d3c:	4c14      	ldr	r4, [pc, #80]	; (401d90 <create_usart_cli_task+0x60>)
  401d3e:	ae0a      	add	r6, sp, #40	; 0x28
  401d40:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  401d44:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
		configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,	/* The priority used by the USART interrupts. */
		USART_RS232,									/* Configure the USART for RS232 operation. */
		(WAIT_TX_COMPLETE | USE_TX_ACCESS_MUTEX)		/* Use access mutex on Tx (as more than one task transmits) but not Rx. Wait for a Tx to complete before returning from send functions. */
	};

	const sam_usart_opt_t usart_settings = {
  401d48:	ad04      	add	r5, sp, #16
  401d4a:	3410      	adds	r4, #16
  401d4c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  401d4e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  401d50:	e894 0003 	ldmia.w	r4, {r0, r1}
  401d54:	e885 0003 	stmia.w	r5, {r0, r1}
		US_MR_CHMODE_NORMAL,
		0 /* Only used in IrDA mode. */
	};

	/* Initialise the USART interface. */
	freertos_usart = freertos_usart_serial_init(usart_base,
  401d58:	4670      	mov	r0, lr
  401d5a:	a904      	add	r1, sp, #16
  401d5c:	4632      	mov	r2, r6
  401d5e:	4b0d      	ldr	r3, [pc, #52]	; (401d94 <create_usart_cli_task+0x64>)
  401d60:	4798      	blx	r3
			&usart_settings,
			&driver_options);
	configASSERT(freertos_usart);
  401d62:	4604      	mov	r4, r0
  401d64:	b918      	cbnz	r0, 401d6e <create_usart_cli_task+0x3e>
  401d66:	480c      	ldr	r0, [pc, #48]	; (401d98 <create_usart_cli_task+0x68>)
  401d68:	217b      	movs	r1, #123	; 0x7b
  401d6a:	4b0c      	ldr	r3, [pc, #48]	; (401d9c <create_usart_cli_task+0x6c>)
  401d6c:	4798      	blx	r3

	/* Register the default CLI commands. */
	vRegisterCLICommands();
  401d6e:	4b0c      	ldr	r3, [pc, #48]	; (401da0 <create_usart_cli_task+0x70>)
  401d70:	4798      	blx	r3

	/* Create the USART CLI task. */
	xTaskCreate(	usart_command_console_task,			/* The task that implements the command console. */
  401d72:	f8cd 8000 	str.w	r8, [sp]
  401d76:	2300      	movs	r3, #0
  401d78:	9301      	str	r3, [sp, #4]
  401d7a:	9302      	str	r3, [sp, #8]
  401d7c:	9303      	str	r3, [sp, #12]
  401d7e:	4809      	ldr	r0, [pc, #36]	; (401da4 <create_usart_cli_task+0x74>)
  401d80:	4909      	ldr	r1, [pc, #36]	; (401da8 <create_usart_cli_task+0x78>)
  401d82:	463a      	mov	r2, r7
  401d84:	4623      	mov	r3, r4
  401d86:	4c09      	ldr	r4, [pc, #36]	; (401dac <create_usart_cli_task+0x7c>)
  401d88:	47a0      	blx	r4
					(const int8_t *const) "U_CLI",	/* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
					stack_depth_words,					/* The size of the stack allocated to the task. */
					(void *) freertos_usart,			/* The parameter is used to pass the already configured USART port into the task. */
					task_priority,						/* The priority allocated to the task. */
					NULL);								/* Used to store the handle to the created task - in this case the handle is not required. */
}
  401d8a:	b00e      	add	sp, #56	; 0x38
  401d8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401d90:	00409940 	.word	0x00409940
  401d94:	00400d91 	.word	0x00400d91
  401d98:	00409968 	.word	0x00409968
  401d9c:	004041a5 	.word	0x004041a5
  401da0:	00404129 	.word	0x00404129
  401da4:	00401b71 	.word	0x00401b71
  401da8:	00409a48 	.word	0x00409a48
  401dac:	00402d4d 	.word	0x00402d4d

00401db0 <usart_cli_output>:
}

/*-----------------------------------------------------------*/

void usart_cli_output(const uint8_t *message_string)
{
  401db0:	b530      	push	{r4, r5, lr}
  401db2:	b083      	sub	sp, #12
	const portTickType max_block_time_ticks = 200UL / portTICK_RATE_MS;

	/* The USART is configured to use a mutex on Tx, so can be safely written
	to directly. */
	if (cli_usart != NULL) {
  401db4:	4b07      	ldr	r3, [pc, #28]	; (401dd4 <usart_cli_output+0x24>)
  401db6:	681d      	ldr	r5, [r3, #0]
  401db8:	b155      	cbz	r5, 401dd0 <usart_cli_output+0x20>
  401dba:	4604      	mov	r4, r0
		freertos_usart_write_packet(cli_usart, message_string,
  401dbc:	4b06      	ldr	r3, [pc, #24]	; (401dd8 <usart_cli_output+0x28>)
  401dbe:	4798      	blx	r3
  401dc0:	4602      	mov	r2, r0
  401dc2:	2300      	movs	r3, #0
  401dc4:	9300      	str	r3, [sp, #0]
  401dc6:	4628      	mov	r0, r5
  401dc8:	4621      	mov	r1, r4
  401dca:	23c8      	movs	r3, #200	; 0xc8
  401dcc:	4c03      	ldr	r4, [pc, #12]	; (401ddc <usart_cli_output+0x2c>)
  401dce:	47a0      	blx	r4
				strlen((const char *) message_string), max_block_time_ticks);
	}
}
  401dd0:	b003      	add	sp, #12
  401dd2:	bd30      	pop	{r4, r5, pc}
  401dd4:	20000d54 	.word	0x20000d54
  401dd8:	00404af9 	.word	0x00404af9
  401ddc:	00400f9d 	.word	0x00400f9d

00401de0 <usart_echo_rx_task>:
}

/*-----------------------------------------------------------*/

static void usart_echo_rx_task(void *pvParameters)
{
  401de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  401de4:	4680      	mov	r8, r0
	unsigned portBASE_TYPE string_index;

	/* The (already open) USART port is passed in as the task parameter. */
	usart_port = (freertos_usart_if)pvParameters;

	string_index = 0;
  401de6:	2400      	movs	r4, #0

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
  401de8:	f8df 9080 	ldr.w	r9, [pc, #128]	; 401e6c <usart_echo_rx_task+0x8c>
  401dec:	4f18      	ldr	r7, [pc, #96]	; (401e50 <usart_echo_rx_task+0x70>)

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
				strlen((const char *) echo_strings[string_index]),
  401dee:	4d19      	ldr	r5, [pc, #100]	; (401e54 <usart_echo_rx_task+0x74>)
	usart_port = (freertos_usart_if)pvParameters;

	string_index = 0;

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
  401df0:	4648      	mov	r0, r9
  401df2:	2100      	movs	r1, #0
  401df4:	224f      	movs	r2, #79	; 0x4f
  401df6:	47b8      	blx	r7

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
				strlen((const char *) echo_strings[string_index]),
  401df8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
  401dfc:	4e16      	ldr	r6, [pc, #88]	; (401e58 <usart_echo_rx_task+0x78>)
  401dfe:	47b0      	blx	r6
  401e00:	4602      	mov	r2, r0
	string_index = 0;

	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
  401e02:	4640      	mov	r0, r8
  401e04:	4649      	mov	r1, r9
  401e06:	f04f 33ff 	mov.w	r3, #4294967295
  401e0a:	f8df c064 	ldr.w	ip, [pc, #100]	; 401e70 <usart_echo_rx_task+0x90>
  401e0e:	47e0      	blx	ip
  401e10:	4682      	mov	sl, r0
				strlen((const char *) echo_strings[string_index]),
				portMAX_DELAY);

		/* Ensure the string received is that expected. */
		configASSERT(received == strlen((const char *) echo_strings[string_index]));
  401e12:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
  401e16:	47b0      	blx	r6
  401e18:	4550      	cmp	r0, sl
  401e1a:	d004      	beq.n	401e26 <usart_echo_rx_task+0x46>
  401e1c:	480f      	ldr	r0, [pc, #60]	; (401e5c <usart_echo_rx_task+0x7c>)
  401e1e:	f44f 71a5 	mov.w	r1, #330	; 0x14a
  401e22:	4b0f      	ldr	r3, [pc, #60]	; (401e60 <usart_echo_rx_task+0x80>)
  401e24:	4798      	blx	r3
		configASSERT(strcmp((const char *) rx_buffer, (const char *) echo_strings[string_index]) == 0);
  401e26:	4648      	mov	r0, r9
  401e28:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
  401e2c:	4b0d      	ldr	r3, [pc, #52]	; (401e64 <usart_echo_rx_task+0x84>)
  401e2e:	4798      	blx	r3
  401e30:	b120      	cbz	r0, 401e3c <usart_echo_rx_task+0x5c>
  401e32:	480a      	ldr	r0, [pc, #40]	; (401e5c <usart_echo_rx_task+0x7c>)
  401e34:	f240 114b 	movw	r1, #331	; 0x14b
  401e38:	4b09      	ldr	r3, [pc, #36]	; (401e60 <usart_echo_rx_task+0x80>)
  401e3a:	4798      	blx	r3

		/* Increment a loop counter as an indication that this task is still
		actually receiving strings. */
		rx_task_loops++;
  401e3c:	4a0a      	ldr	r2, [pc, #40]	; (401e68 <usart_echo_rx_task+0x88>)
  401e3e:	6813      	ldr	r3, [r2, #0]
  401e40:	3301      	adds	r3, #1
  401e42:	6013      	str	r3, [r2, #0]

		/* Expect the next string the next time around. */
		string_index++;
  401e44:	3401      	adds	r4, #1
		if (string_index >= (sizeof(echo_strings) / sizeof(uint8_t *))) {
			string_index = 0;
  401e46:	2c75      	cmp	r4, #117	; 0x75
  401e48:	bf28      	it	cs
  401e4a:	2400      	movcs	r4, #0
  401e4c:	e7d0      	b.n	401df0 <usart_echo_rx_task+0x10>
  401e4e:	bf00      	nop
  401e50:	00404621 	.word	0x00404621
  401e54:	20000008 	.word	0x20000008
  401e58:	00404af9 	.word	0x00404af9
  401e5c:	00409a78 	.word	0x00409a78
  401e60:	004041a5 	.word	0x004041a5
  401e64:	00404769 	.word	0x00404769
  401e68:	20000d5c 	.word	0x20000d5c
  401e6c:	20000e00 	.word	0x20000e00
  401e70:	00401025 	.word	0x00401025

00401e74 <usart_echo_tx_task>:
}

/*-----------------------------------------------------------*/

static void usart_echo_tx_task(void *pvParameters)
{
  401e74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  401e78:	b082      	sub	sp, #8
  401e7a:	4680      	mov	r8, r0
  401e7c:	4d29      	ldr	r5, [pc, #164]	; (401f24 <usart_echo_tx_task+0xb0>)
  401e7e:	1f2c      	subs	r4, r5, #4
  401e80:	f505 75e8 	add.w	r5, r5, #464	; 0x1d0
	status_code_t returned_status;

	/* Check the strings being sent fit in the buffers provided. */
	for(string_index = 0; string_index < sizeof(echo_strings) / sizeof(uint8_t *); string_index++)
	{
		configASSERT(strlen((char *) echo_strings[string_index]) <= RX_BUFFER_SIZE);
  401e84:	4e28      	ldr	r6, [pc, #160]	; (401f28 <usart_echo_tx_task+0xb4>)
  401e86:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 401f44 <usart_echo_tx_task+0xd0>
  401e8a:	4f28      	ldr	r7, [pc, #160]	; (401f2c <usart_echo_tx_task+0xb8>)
  401e8c:	f854 0f04 	ldr.w	r0, [r4, #4]!
  401e90:	47b0      	blx	r6
  401e92:	284f      	cmp	r0, #79	; 0x4f
  401e94:	d903      	bls.n	401e9e <usart_echo_tx_task+0x2a>
  401e96:	4648      	mov	r0, r9
  401e98:	f240 1109 	movw	r1, #265	; 0x109
  401e9c:	47b8      	blx	r7
	xSemaphoreHandle notification_semaphore;
	unsigned portBASE_TYPE string_index;
	status_code_t returned_status;

	/* Check the strings being sent fit in the buffers provided. */
	for(string_index = 0; string_index < sizeof(echo_strings) / sizeof(uint8_t *); string_index++)
  401e9e:	42ac      	cmp	r4, r5
  401ea0:	d1f4      	bne.n	401e8c <usart_echo_tx_task+0x18>
	/* The (already open) USART port is passed in as the task parameter. */
	usart_port = (freertos_usart_if)pvParameters;

	/* Create the semaphore to be used to get notified of end of
	transmissions. */
	vSemaphoreCreateBinary(notification_semaphore);
  401ea2:	2001      	movs	r0, #1
  401ea4:	2100      	movs	r1, #0
  401ea6:	2203      	movs	r2, #3
  401ea8:	4b21      	ldr	r3, [pc, #132]	; (401f30 <usart_echo_tx_task+0xbc>)
  401eaa:	4798      	blx	r3
  401eac:	4606      	mov	r6, r0
  401eae:	2800      	cmp	r0, #0
  401eb0:	d032      	beq.n	401f18 <usart_echo_tx_task+0xa4>
  401eb2:	2100      	movs	r1, #0
  401eb4:	460a      	mov	r2, r1
  401eb6:	460b      	mov	r3, r1
  401eb8:	4c1e      	ldr	r4, [pc, #120]	; (401f34 <usart_echo_tx_task+0xc0>)
  401eba:	47a0      	blx	r4
	configASSERT(notification_semaphore);

	/* Start with the semaphore in the expected state - no data has been sent
	yet.  A block time of zero is used as the semaphore is guaranteed to be
	there as it has only just been created. */
	xSemaphoreTake(notification_semaphore, 0);
  401ebc:	4630      	mov	r0, r6
  401ebe:	2100      	movs	r1, #0
  401ec0:	460a      	mov	r2, r1
  401ec2:	460b      	mov	r3, r1
  401ec4:	4c1c      	ldr	r4, [pc, #112]	; (401f38 <usart_echo_tx_task+0xc4>)
  401ec6:	47a0      	blx	r4

	string_index = 0;
  401ec8:	2400      	movs	r4, #0

	for (;;) {
		/* Data cannot be sent from Flash, so copy the string to RAM. */
		strcpy((char *) local_buffer,
  401eca:	4d1c      	ldr	r5, [pc, #112]	; (401f3c <usart_echo_tx_task+0xc8>)
				(const char *) echo_strings[string_index]);
  401ecc:	f8df a054 	ldr.w	sl, [pc, #84]	; 401f24 <usart_echo_tx_task+0xb0>

	string_index = 0;

	for (;;) {
		/* Data cannot be sent from Flash, so copy the string to RAM. */
		strcpy((char *) local_buffer,
  401ed0:	f8df 9078 	ldr.w	r9, [pc, #120]	; 401f4c <usart_echo_tx_task+0xd8>
  401ed4:	4628      	mov	r0, r5
  401ed6:	f85a 1024 	ldr.w	r1, [sl, r4, lsl #2]
  401eda:	47c8      	blx	r9
				(const char *) echo_strings[string_index]);

		/* Start send. */
		returned_status = freertos_usart_write_packet_async(usart_port,
  401edc:	4628      	mov	r0, r5
  401ede:	4b12      	ldr	r3, [pc, #72]	; (401f28 <usart_echo_tx_task+0xb4>)
  401ee0:	4798      	blx	r3
  401ee2:	4602      	mov	r2, r0
  401ee4:	9600      	str	r6, [sp, #0]
  401ee6:	4640      	mov	r0, r8
  401ee8:	4629      	mov	r1, r5
  401eea:	2364      	movs	r3, #100	; 0x64
  401eec:	4f14      	ldr	r7, [pc, #80]	; (401f40 <usart_echo_tx_task+0xcc>)
  401eee:	47b8      	blx	r7
				local_buffer, strlen((char *) local_buffer),
				time_out_definition, notification_semaphore);
		configASSERT(returned_status == STATUS_OK);
  401ef0:	b120      	cbz	r0, 401efc <usart_echo_tx_task+0x88>
  401ef2:	4814      	ldr	r0, [pc, #80]	; (401f44 <usart_echo_tx_task+0xd0>)
  401ef4:	f44f 7192 	mov.w	r1, #292	; 0x124
  401ef8:	4b0c      	ldr	r3, [pc, #48]	; (401f2c <usart_echo_tx_task+0xb8>)
  401efa:	4798      	blx	r3

		/* The async version of the write function is being used, so wait for
		the end of the transmission.  No CPU time is used while waiting for the
		semaphore.*/
		xSemaphoreTake(notification_semaphore, time_out_definition * 2);
  401efc:	4630      	mov	r0, r6
  401efe:	2100      	movs	r1, #0
  401f00:	22c8      	movs	r2, #200	; 0xc8
  401f02:	460b      	mov	r3, r1
  401f04:	4f0c      	ldr	r7, [pc, #48]	; (401f38 <usart_echo_tx_task+0xc4>)
  401f06:	47b8      	blx	r7
		vTaskDelay(short_delay);
  401f08:	200a      	movs	r0, #10
  401f0a:	4b0f      	ldr	r3, [pc, #60]	; (401f48 <usart_echo_tx_task+0xd4>)
  401f0c:	4798      	blx	r3

		/* Send the next string next time around. */
		string_index++;
  401f0e:	3401      	adds	r4, #1
		if (string_index >= (sizeof(echo_strings) / sizeof(uint8_t *))) {
			string_index = 0;
  401f10:	2c75      	cmp	r4, #117	; 0x75
  401f12:	bf28      	it	cs
  401f14:	2400      	movcs	r4, #0
  401f16:	e7dd      	b.n	401ed4 <usart_echo_tx_task+0x60>
	usart_port = (freertos_usart_if)pvParameters;

	/* Create the semaphore to be used to get notified of end of
	transmissions. */
	vSemaphoreCreateBinary(notification_semaphore);
	configASSERT(notification_semaphore);
  401f18:	480a      	ldr	r0, [pc, #40]	; (401f44 <usart_echo_tx_task+0xd0>)
  401f1a:	f44f 7189 	mov.w	r1, #274	; 0x112
  401f1e:	4b03      	ldr	r3, [pc, #12]	; (401f2c <usart_echo_tx_task+0xb8>)
  401f20:	4798      	blx	r3
  401f22:	e7cb      	b.n	401ebc <usart_echo_tx_task+0x48>
  401f24:	20000008 	.word	0x20000008
  401f28:	00404af9 	.word	0x00404af9
  401f2c:	004041a5 	.word	0x004041a5
  401f30:	00402745 	.word	0x00402745
  401f34:	004027d5 	.word	0x004027d5
  401f38:	00402a09 	.word	0x00402a09
  401f3c:	20000d60 	.word	0x20000d60
  401f40:	00400f9d 	.word	0x00400f9d
  401f44:	00409a78 	.word	0x00409a78
  401f48:	004032fd 	.word	0x004032fd
  401f4c:	00404a3d 	.word	0x00404a3d

00401f50 <create_usart_echo_test_tasks>:
/*-----------------------------------------------------------*/

void create_usart_echo_test_tasks(Usart *usart_base,
		uint16_t stack_depth_words,
		unsigned portBASE_TYPE task_priority)
{
  401f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401f54:	b08e      	sub	sp, #56	; 0x38
  401f56:	4686      	mov	lr, r0
  401f58:	4688      	mov	r8, r1
  401f5a:	4617      	mov	r7, r2
	freertos_usart_if freertos_usart;
	freertos_peripheral_options_t driver_options = {
  401f5c:	4c18      	ldr	r4, [pc, #96]	; (401fc0 <create_usart_echo_test_tasks+0x70>)
  401f5e:	ae0a      	add	r6, sp, #40	; 0x28
  401f60:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  401f64:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
		configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY,	/* The priority used by the USART interrupts. */
		USART_RS232,									/* Configure the USART for RS232 operation. */
		(USE_TX_ACCESS_MUTEX | USE_RX_ACCESS_MUTEX)
	};

	const sam_usart_opt_t usart_settings = {
  401f68:	ad04      	add	r5, sp, #16
  401f6a:	3410      	adds	r4, #16
  401f6c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  401f6e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  401f70:	e894 0003 	ldmia.w	r4, {r0, r1}
  401f74:	e885 0003 	stmia.w	r5, {r0, r1}
		US_MR_CHMODE_NORMAL,
		0 /* Only used in IrDA mode. */
	}; /*_RB_ TODO This is not SAM specific, not a good thing. */

	/* Initialise the USART interface. */
	freertos_usart = freertos_usart_serial_init(usart_base,
  401f78:	4670      	mov	r0, lr
  401f7a:	a904      	add	r1, sp, #16
  401f7c:	4632      	mov	r2, r6
  401f7e:	4b11      	ldr	r3, [pc, #68]	; (401fc4 <create_usart_echo_test_tasks+0x74>)
  401f80:	4798      	blx	r3
			&usart_settings,
			&driver_options);
	configASSERT(freertos_usart);
  401f82:	4606      	mov	r6, r0
  401f84:	b918      	cbnz	r0, 401f8e <create_usart_echo_test_tasks+0x3e>
  401f86:	4810      	ldr	r0, [pc, #64]	; (401fc8 <create_usart_echo_test_tasks+0x78>)
  401f88:	21ef      	movs	r1, #239	; 0xef
  401f8a:	4b10      	ldr	r3, [pc, #64]	; (401fcc <create_usart_echo_test_tasks+0x7c>)
  401f8c:	4798      	blx	r3

	/* Create the two tasks as described above. */
	xTaskCreate(usart_echo_tx_task, (const signed char *const) "Tx",
  401f8e:	9700      	str	r7, [sp, #0]
  401f90:	2400      	movs	r4, #0
  401f92:	9401      	str	r4, [sp, #4]
  401f94:	9402      	str	r4, [sp, #8]
  401f96:	9403      	str	r4, [sp, #12]
  401f98:	480d      	ldr	r0, [pc, #52]	; (401fd0 <create_usart_echo_test_tasks+0x80>)
  401f9a:	490e      	ldr	r1, [pc, #56]	; (401fd4 <create_usart_echo_test_tasks+0x84>)
  401f9c:	4642      	mov	r2, r8
  401f9e:	4633      	mov	r3, r6
  401fa0:	4d0d      	ldr	r5, [pc, #52]	; (401fd8 <create_usart_echo_test_tasks+0x88>)
  401fa2:	47a8      	blx	r5
			stack_depth_words, (void *) freertos_usart,
			task_priority, NULL);
	xTaskCreate(usart_echo_rx_task, (const signed char *const) "Rx",
  401fa4:	3701      	adds	r7, #1
  401fa6:	9700      	str	r7, [sp, #0]
  401fa8:	9401      	str	r4, [sp, #4]
  401faa:	9402      	str	r4, [sp, #8]
  401fac:	9403      	str	r4, [sp, #12]
  401fae:	480b      	ldr	r0, [pc, #44]	; (401fdc <create_usart_echo_test_tasks+0x8c>)
  401fb0:	490b      	ldr	r1, [pc, #44]	; (401fe0 <create_usart_echo_test_tasks+0x90>)
  401fb2:	4642      	mov	r2, r8
  401fb4:	4633      	mov	r3, r6
  401fb6:	47a8      	blx	r5
			stack_depth_words, (void *) freertos_usart,
			task_priority + 1, NULL);
}
  401fb8:	b00e      	add	sp, #56	; 0x38
  401fba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401fbe:	bf00      	nop
  401fc0:	00409a50 	.word	0x00409a50
  401fc4:	00400d91 	.word	0x00400d91
  401fc8:	00409a78 	.word	0x00409a78
  401fcc:	004041a5 	.word	0x004041a5
  401fd0:	00401e75 	.word	0x00401e75
  401fd4:	00409ad0 	.word	0x00409ad0
  401fd8:	00402d4d 	.word	0x00402d4d
  401fdc:	00401de1 	.word	0x00401de1
  401fe0:	00409ad4 	.word	0x00409ad4

00401fe4 <are_usart_echo_tasks_still_running>:
{
	static uint32_t last_loop_count = 0;
	portBASE_TYPE return_value = pdPASS;

	/* Ensure the count of Rx loops is still incrementing. */
	if (last_loop_count == rx_task_loops) {
  401fe4:	4b04      	ldr	r3, [pc, #16]	; (401ff8 <are_usart_echo_tasks_still_running+0x14>)
  401fe6:	681b      	ldr	r3, [r3, #0]
  401fe8:	4a04      	ldr	r2, [pc, #16]	; (401ffc <are_usart_echo_tasks_still_running+0x18>)
  401fea:	6810      	ldr	r0, [r2, #0]
		/* The Rx task has somehow stalled, set the error LED. */
		return_value = pdFAIL;
	}

	last_loop_count = rx_task_loops;
  401fec:	6013      	str	r3, [r2, #0]

	return return_value;
}
  401fee:	1ac0      	subs	r0, r0, r3
  401ff0:	bf18      	it	ne
  401ff2:	2001      	movne	r0, #1
  401ff4:	4770      	bx	lr
  401ff6:	bf00      	nop
  401ff8:	20000d5c 	.word	0x20000d5c
  401ffc:	20000d58 	.word	0x20000d58

00402000 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvHelpCommand( int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString )
{
  402000:	b538      	push	{r3, r4, r5, lr}
  402002:	460a      	mov	r2, r1
static const CLI_Definition_List_Item_t * pxCommand = NULL;
signed portBASE_TYPE xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
  402004:	4b08      	ldr	r3, [pc, #32]	; (402028 <prvHelpCommand+0x28>)
  402006:	681b      	ldr	r3, [r3, #0]
  402008:	b913      	cbnz	r3, 402010 <prvHelpCommand+0x10>
	{
		/* Reset the pxCommand pointer back to the start of the list. */
		pxCommand = &xRegisteredCommands;
  40200a:	4908      	ldr	r1, [pc, #32]	; (40202c <prvHelpCommand+0x2c>)
  40200c:	4b06      	ldr	r3, [pc, #24]	; (402028 <prvHelpCommand+0x28>)
  40200e:	6019      	str	r1, [r3, #0]
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( ( char * ) pcWriteBuffer, ( const char * ) pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
  402010:	4c05      	ldr	r4, [pc, #20]	; (402028 <prvHelpCommand+0x28>)
  402012:	6825      	ldr	r5, [r4, #0]
  402014:	682b      	ldr	r3, [r5, #0]
  402016:	6859      	ldr	r1, [r3, #4]
  402018:	4b05      	ldr	r3, [pc, #20]	; (402030 <prvHelpCommand+0x30>)
  40201a:	4798      	blx	r3
	pxCommand = pxCommand->pxNext;
  40201c:	6868      	ldr	r0, [r5, #4]
  40201e:	6020      	str	r0, [r4, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
  402020:	3000      	adds	r0, #0
  402022:	bf18      	it	ne
  402024:	2001      	movne	r0, #1
  402026:	bd38      	pop	{r3, r4, r5, pc}
  402028:	20000fe4 	.word	0x20000fe4
  40202c:	200001dc 	.word	0x200001dc
  402030:	00404c49 	.word	0x00404c49

00402034 <FreeRTOS_CLIRegisterCommand>:
static int8_t cOutputBuffer[ configCOMMAND_INT_MAX_OUTPUT_SIZE ];

/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
  402034:	b538      	push	{r3, r4, r5, lr}
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;

	/* Check the parameter is not NULL. */
	configASSERT( pxCommandToRegister );
  402036:	4605      	mov	r5, r0
  402038:	b918      	cbnz	r0, 402042 <FreeRTOS_CLIRegisterCommand+0xe>
  40203a:	480e      	ldr	r0, [pc, #56]	; (402074 <FreeRTOS_CLIRegisterCommand+0x40>)
  40203c:	2167      	movs	r1, #103	; 0x67
  40203e:	4b0e      	ldr	r3, [pc, #56]	; (402078 <FreeRTOS_CLIRegisterCommand+0x44>)
  402040:	4798      	blx	r3

	/* Create a new list item that will reference the command being registered. */
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
  402042:	2008      	movs	r0, #8
  402044:	4b0d      	ldr	r3, [pc, #52]	; (40207c <FreeRTOS_CLIRegisterCommand+0x48>)
  402046:	4798      	blx	r3
	configASSERT( pxNewListItem );
  402048:	4604      	mov	r4, r0
  40204a:	b928      	cbnz	r0, 402058 <FreeRTOS_CLIRegisterCommand+0x24>
  40204c:	4809      	ldr	r0, [pc, #36]	; (402074 <FreeRTOS_CLIRegisterCommand+0x40>)
  40204e:	216b      	movs	r1, #107	; 0x6b
  402050:	4b09      	ldr	r3, [pc, #36]	; (402078 <FreeRTOS_CLIRegisterCommand+0x44>)
  402052:	4798      	blx	r3

portBASE_TYPE FreeRTOS_CLIRegisterCommand( const CLI_Command_Definition_t * const pxCommandToRegister )
{
static CLI_Definition_List_Item_t *pxLastCommandInList = &xRegisteredCommands;
CLI_Definition_List_Item_t *pxNewListItem;
portBASE_TYPE xReturn = pdFAIL;
  402054:	2000      	movs	r0, #0
  402056:	bd38      	pop	{r3, r4, r5, pc}
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
	configASSERT( pxNewListItem );

	if( pxNewListItem != NULL )
	{
		taskENTER_CRITICAL();
  402058:	4b09      	ldr	r3, [pc, #36]	; (402080 <FreeRTOS_CLIRegisterCommand+0x4c>)
  40205a:	4798      	blx	r3
		{
			/* Reference the command being registered from the newly created
			list item. */
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
  40205c:	6025      	str	r5, [r4, #0]

			/* The new list item will get added to the end of the list, so
			pxNext has nowhere to point. */
			pxNewListItem->pxNext = NULL;
  40205e:	2300      	movs	r3, #0
  402060:	6063      	str	r3, [r4, #4]

			/* Add the newly created list item to the end of the already existing
			list. */
			pxLastCommandInList->pxNext = pxNewListItem;
  402062:	4b08      	ldr	r3, [pc, #32]	; (402084 <FreeRTOS_CLIRegisterCommand+0x50>)
  402064:	681a      	ldr	r2, [r3, #0]
  402066:	6054      	str	r4, [r2, #4]

			/* Set the end of list marker to the new list item. */
			pxLastCommandInList = pxNewListItem;
  402068:	601c      	str	r4, [r3, #0]
		}
		taskEXIT_CRITICAL();
  40206a:	4b07      	ldr	r3, [pc, #28]	; (402088 <FreeRTOS_CLIRegisterCommand+0x54>)
  40206c:	4798      	blx	r3

		xReturn = pdPASS;
  40206e:	2001      	movs	r0, #1
	}

	return xReturn;
}
  402070:	bd38      	pop	{r3, r4, r5, pc}
  402072:	bf00      	nop
  402074:	0040a984 	.word	0x0040a984
  402078:	004041a5 	.word	0x004041a5
  40207c:	00402499 	.word	0x00402499
  402080:	00402325 	.word	0x00402325
  402084:	200001e4 	.word	0x200001e4
  402088:	00402345 	.word	0x00402345

0040208c <FreeRTOS_CLIProcessCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE FreeRTOS_CLIProcessCommand( const int8_t * const pcCommandInput, int8_t * pcWriteBuffer, size_t xWriteBufferLen  )
{
  40208c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402090:	b083      	sub	sp, #12
  402092:	4606      	mov	r6, r0
  402094:	9101      	str	r1, [sp, #4]
  402096:	4692      	mov	sl, r2
size_t xCommandStringLength;

	/* Note:  This function is not re-entrant.  It must not be called from more
	thank one task. */

	if( pxCommand == NULL )
  402098:	4b33      	ldr	r3, [pc, #204]	; (402168 <FreeRTOS_CLIProcessCommand+0xdc>)
  40209a:	681a      	ldr	r2, [r3, #0]
  40209c:	2a00      	cmp	r2, #0
  40209e:	d147      	bne.n	402130 <FreeRTOS_CLIProcessCommand+0xa4>
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  4020a0:	4c32      	ldr	r4, [pc, #200]	; (40216c <FreeRTOS_CLIProcessCommand+0xe0>)
  4020a2:	601c      	str	r4, [r3, #0]
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
  4020a4:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 40217c <FreeRTOS_CLIProcessCommand+0xf0>
			a sub-string of a longer command, check the byte after the expected
			end of the string is either the end of the string or a space before
			a parameter. */
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
			{
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
  4020a8:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 402180 <FreeRTOS_CLIProcessCommand+0xf4>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  4020ac:	4699      	mov	r9, r3
		{
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
  4020ae:	6827      	ldr	r7, [r4, #0]
  4020b0:	683d      	ldr	r5, [r7, #0]
			xCommandStringLength = strlen( ( const char * ) pcRegisteredCommandString );
  4020b2:	4628      	mov	r0, r5
  4020b4:	47c0      	blx	r8
  4020b6:	4602      	mov	r2, r0

			/* To ensure the string lengths match exactly, so as not to pick up
			a sub-string of a longer command, check the byte after the expected
			end of the string is either the end of the string or a space before
			a parameter. */
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
  4020b8:	5633      	ldrsb	r3, [r6, r0]
  4020ba:	f033 0320 	bics.w	r3, r3, #32
  4020be:	d124      	bne.n	40210a <FreeRTOS_CLIProcessCommand+0x7e>
			{
				if( strncmp( ( const char * ) pcCommandInput, ( const char * ) pcRegisteredCommandString, xCommandStringLength ) == 0 )
  4020c0:	4630      	mov	r0, r6
  4020c2:	4629      	mov	r1, r5
  4020c4:	47d8      	blx	fp
  4020c6:	bb00      	cbnz	r0, 40210a <FreeRTOS_CLIProcessCommand+0x7e>
				{
					/* The command has been found.  Check it has the expected
					number of parameters.  If cExpectedNumberOfParameters is -1,
					then there could be a variable number of parameters and no
					check is made. */
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
  4020c8:	7b39      	ldrb	r1, [r7, #12]
  4020ca:	f011 0f80 	tst.w	r1, #128	; 0x80
  4020ce:	d142      	bne.n	402156 <FreeRTOS_CLIProcessCommand+0xca>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  4020d0:	7832      	ldrb	r2, [r6, #0]
  4020d2:	b1aa      	cbz	r2, 402100 <FreeRTOS_CLIProcessCommand+0x74>
  4020d4:	4630      	mov	r0, r6
  4020d6:	2300      	movs	r3, #0
  4020d8:	461c      	mov	r4, r3
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
  4020da:	461d      	mov	r5, r3
		if( ( *pcCommandString ) == ' ' )
		{
			if( xLastCharacterWasSpace != pdTRUE )
			{
				cParameters++;
				xLastCharacterWasSpace = pdTRUE;
  4020dc:	2701      	movs	r7, #1
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
	{
		if( ( *pcCommandString ) == ' ' )
  4020de:	b252      	sxtb	r2, r2
  4020e0:	2a20      	cmp	r2, #32
  4020e2:	d104      	bne.n	4020ee <FreeRTOS_CLIProcessCommand+0x62>
		{
			if( xLastCharacterWasSpace != pdTRUE )
  4020e4:	b924      	cbnz	r4, 4020f0 <FreeRTOS_CLIProcessCommand+0x64>
			{
				cParameters++;
  4020e6:	3301      	adds	r3, #1
  4020e8:	b2db      	uxtb	r3, r3
				xLastCharacterWasSpace = pdTRUE;
  4020ea:	463c      	mov	r4, r7
  4020ec:	e000      	b.n	4020f0 <FreeRTOS_CLIProcessCommand+0x64>
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
  4020ee:	462c      	mov	r4, r5
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  4020f0:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  4020f4:	2a00      	cmp	r2, #0
  4020f6:	d1f2      	bne.n	4020de <FreeRTOS_CLIProcessCommand+0x52>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
  4020f8:	b11c      	cbz	r4, 402102 <FreeRTOS_CLIProcessCommand+0x76>
	{
		cParameters--;
  4020fa:	3b01      	subs	r3, #1
  4020fc:	b2db      	uxtb	r3, r3
  4020fe:	e000      	b.n	402102 <FreeRTOS_CLIProcessCommand+0x76>
{
int8_t cParameters = 0;
portBASE_TYPE xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
  402100:	2300      	movs	r3, #0
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  402102:	4a19      	ldr	r2, [pc, #100]	; (402168 <FreeRTOS_CLIProcessCommand+0xdc>)
  402104:	6812      	ldr	r2, [r2, #0]
  402106:	b932      	cbnz	r2, 402116 <FreeRTOS_CLIProcessCommand+0x8a>
  402108:	e01e      	b.n	402148 <FreeRTOS_CLIProcessCommand+0xbc>
	thank one task. */

	if( pxCommand == NULL )
	{
		/* Search for the command string in the list of registered commands. */
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
  40210a:	6864      	ldr	r4, [r4, #4]
  40210c:	f8c9 4000 	str.w	r4, [r9]
  402110:	2c00      	cmp	r4, #0
  402112:	d1cc      	bne.n	4020ae <FreeRTOS_CLIProcessCommand+0x22>
  402114:	e018      	b.n	402148 <FreeRTOS_CLIProcessCommand+0xbc>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  402116:	b249      	sxtb	r1, r1
  402118:	b25b      	sxtb	r3, r3
  40211a:	4299      	cmp	r1, r3
  40211c:	d008      	beq.n	402130 <FreeRTOS_CLIProcessCommand+0xa4>
	{
		/* The command was found, but the number of parameters with the command
		was incorrect. */
		strncpy( ( char * ) pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
  40211e:	9801      	ldr	r0, [sp, #4]
  402120:	4913      	ldr	r1, [pc, #76]	; (402170 <FreeRTOS_CLIProcessCommand+0xe4>)
  402122:	4652      	mov	r2, sl
  402124:	4b13      	ldr	r3, [pc, #76]	; (402174 <FreeRTOS_CLIProcessCommand+0xe8>)
  402126:	4798      	blx	r3
		pxCommand = NULL;
  402128:	2300      	movs	r3, #0
  40212a:	4a0f      	ldr	r2, [pc, #60]	; (402168 <FreeRTOS_CLIProcessCommand+0xdc>)
  40212c:	6013      	str	r3, [r2, #0]
  40212e:	e017      	b.n	402160 <FreeRTOS_CLIProcessCommand+0xd4>
	}
	else if( pxCommand != NULL )
	{
		/* Call the callback function that is registered to this command. */
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
  402130:	6813      	ldr	r3, [r2, #0]
  402132:	689b      	ldr	r3, [r3, #8]
  402134:	9801      	ldr	r0, [sp, #4]
  402136:	4651      	mov	r1, sl
  402138:	4632      	mov	r2, r6
  40213a:	4798      	blx	r3

		/* If xReturn is pdFALSE, then no further strings will be returned
		after this one, and	pxCommand can be reset to NULL ready to search
		for the next entered command. */
		if( xReturn == pdFALSE )
  40213c:	4603      	mov	r3, r0
  40213e:	b978      	cbnz	r0, 402160 <FreeRTOS_CLIProcessCommand+0xd4>
		{
			pxCommand = NULL;
  402140:	2100      	movs	r1, #0
  402142:	4a09      	ldr	r2, [pc, #36]	; (402168 <FreeRTOS_CLIProcessCommand+0xdc>)
  402144:	6011      	str	r1, [r2, #0]
  402146:	e00b      	b.n	402160 <FreeRTOS_CLIProcessCommand+0xd4>
		}
	}
	else
	{
		/* pxCommand was NULL, the command was not found. */
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
  402148:	9801      	ldr	r0, [sp, #4]
  40214a:	490b      	ldr	r1, [pc, #44]	; (402178 <FreeRTOS_CLIProcessCommand+0xec>)
  40214c:	4652      	mov	r2, sl
  40214e:	4b09      	ldr	r3, [pc, #36]	; (402174 <FreeRTOS_CLIProcessCommand+0xe8>)
  402150:	4798      	blx	r3
		xReturn = pdFALSE;
  402152:	2300      	movs	r3, #0
  402154:	e004      	b.n	402160 <FreeRTOS_CLIProcessCommand+0xd4>
				}
			}
		}
	}

	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
  402156:	4b04      	ldr	r3, [pc, #16]	; (402168 <FreeRTOS_CLIProcessCommand+0xdc>)
  402158:	681a      	ldr	r2, [r3, #0]
  40215a:	2a00      	cmp	r2, #0
  40215c:	d1e8      	bne.n	402130 <FreeRTOS_CLIProcessCommand+0xa4>
  40215e:	e7f3      	b.n	402148 <FreeRTOS_CLIProcessCommand+0xbc>
		strncpy( ( char * ) pcWriteBuffer, ( const char * const ) "Command not recognised.  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
		xReturn = pdFALSE;
	}

	return xReturn;
}
  402160:	4618      	mov	r0, r3
  402162:	b003      	add	sp, #12
  402164:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402168:	20000fe0 	.word	0x20000fe0
  40216c:	200001dc 	.word	0x200001dc
  402170:	0040a9c8 	.word	0x0040a9c8
  402174:	00404c49 	.word	0x00404c49
  402178:	0040aa20 	.word	0x0040aa20
  40217c:	00404af9 	.word	0x00404af9
  402180:	00404bb1 	.word	0x00404bb1

00402184 <FreeRTOS_CLIGetOutputBuffer>:
/*-----------------------------------------------------------*/

int8_t *FreeRTOS_CLIGetOutputBuffer( void )
{
	return cOutputBuffer;
}
  402184:	4800      	ldr	r0, [pc, #0]	; (402188 <FreeRTOS_CLIGetOutputBuffer+0x4>)
  402186:	4770      	bx	lr
  402188:	20000e50 	.word	0x20000e50

0040218c <FreeRTOS_CLIGetParameter>:
const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;

	*pxParameterStringLength = 0;
  40218c:	2300      	movs	r3, #0
  40218e:	6013      	str	r3, [r2, #0]

	while( uxParametersFound < uxWantedParameter )
  402190:	bb11      	cbnz	r1, 4021d8 <FreeRTOS_CLIGetParameter+0x4c>
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;
  402192:	4618      	mov	r0, r3
			break;
		}
	}

	return pcReturn;
}
  402194:	4770      	bx	lr

	while( uxParametersFound < uxWantedParameter )
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  402196:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  40219a:	b353      	cbz	r3, 4021f2 <FreeRTOS_CLIGetParameter+0x66>
  40219c:	b25b      	sxtb	r3, r3
  40219e:	2b20      	cmp	r3, #32
  4021a0:	d1f9      	bne.n	402196 <FreeRTOS_CLIGetParameter+0xa>
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
  4021a2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  4021a6:	b259      	sxtb	r1, r3
  4021a8:	2920      	cmp	r1, #32
  4021aa:	d0fa      	beq.n	4021a2 <FreeRTOS_CLIGetParameter+0x16>
		{
			pcCommandString++;
		}

		/* Was a string found? */
		if( *pcCommandString != 0x00 )
  4021ac:	b1eb      	cbz	r3, 4021ea <FreeRTOS_CLIGetParameter+0x5e>
		{
			/* Is this the start of the required parameter? */
			uxParametersFound++;
  4021ae:	3401      	adds	r4, #1

			if( uxParametersFound == uxWantedParameter )
  4021b0:	42ac      	cmp	r4, r5
  4021b2:	d114      	bne.n	4021de <FreeRTOS_CLIGetParameter+0x52>
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  4021b4:	f990 3000 	ldrsb.w	r3, [r0]
  4021b8:	f033 0320 	bics.w	r3, r3, #32
  4021bc:	d017      	beq.n	4021ee <FreeRTOS_CLIGetParameter+0x62>
  4021be:	4601      	mov	r1, r0
				{
					( *pxParameterStringLength )++;
  4021c0:	6813      	ldr	r3, [r2, #0]
  4021c2:	3301      	adds	r3, #1
  4021c4:	6013      	str	r3, [r2, #0]

			if( uxParametersFound == uxWantedParameter )
			{
				/* How long is the parameter? */
				pcReturn = pcCommandString;
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  4021c6:	f911 4f01 	ldrsb.w	r4, [r1, #1]!
  4021ca:	f034 0420 	bics.w	r4, r4, #32
  4021ce:	d1f7      	bne.n	4021c0 <FreeRTOS_CLIGetParameter+0x34>
					pcCommandString++;
				}

				if( *pxParameterStringLength == 0 )
				{
					pcReturn = NULL;
  4021d0:	2b00      	cmp	r3, #0
  4021d2:	bf08      	it	eq
  4021d4:	2000      	moveq	r0, #0
  4021d6:	e00e      	b.n	4021f6 <FreeRTOS_CLIGetParameter+0x6a>
	return cOutputBuffer;
}
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
  4021d8:	b430      	push	{r4, r5}
  4021da:	460d      	mov	r5, r1
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;

	*pxParameterStringLength = 0;

	while( uxParametersFound < uxWantedParameter )
  4021dc:	2400      	movs	r4, #0
	{
		/* Index the character pointer past the current word.  If this is the start
		of the command string then the first word is the command itself. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
  4021de:	7803      	ldrb	r3, [r0, #0]
  4021e0:	b13b      	cbz	r3, 4021f2 <FreeRTOS_CLIGetParameter+0x66>
  4021e2:	b25b      	sxtb	r3, r3
  4021e4:	2b20      	cmp	r3, #32
  4021e6:	d1d6      	bne.n	402196 <FreeRTOS_CLIGetParameter+0xa>
  4021e8:	e7db      	b.n	4021a2 <FreeRTOS_CLIGetParameter+0x16>
/*-----------------------------------------------------------*/

const int8_t *FreeRTOS_CLIGetParameter( const int8_t *pcCommandString, unsigned portBASE_TYPE uxWantedParameter, portBASE_TYPE *pxParameterStringLength )
{
unsigned portBASE_TYPE uxParametersFound = 0;
const int8_t *pcReturn = NULL;
  4021ea:	2000      	movs	r0, #0
  4021ec:	e003      	b.n	4021f6 <FreeRTOS_CLIGetParameter+0x6a>
					pcCommandString++;
				}

				if( *pxParameterStringLength == 0 )
				{
					pcReturn = NULL;
  4021ee:	2000      	movs	r0, #0
  4021f0:	e001      	b.n	4021f6 <FreeRTOS_CLIGetParameter+0x6a>
		{
			pcCommandString++;
		}

		/* Find the start of the next string. */
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
  4021f2:	7803      	ldrb	r3, [r0, #0]
  4021f4:	e7da      	b.n	4021ac <FreeRTOS_CLIGetParameter+0x20>
			break;
		}
	}

	return pcReturn;
}
  4021f6:	bc30      	pop	{r4, r5}
  4021f8:	4770      	bx	lr
  4021fa:	bf00      	nop

004021fc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  4021fc:	f100 0308 	add.w	r3, r0, #8
  402200:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  402202:	f04f 32ff 	mov.w	r2, #4294967295
  402206:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  402208:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  40220a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  40220c:	2300      	movs	r3, #0
  40220e:	6003      	str	r3, [r0, #0]
  402210:	4770      	bx	lr
  402212:	bf00      	nop

00402214 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  402214:	2300      	movs	r3, #0
  402216:	6103      	str	r3, [r0, #16]
  402218:	4770      	bx	lr
  40221a:	bf00      	nop

0040221c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  40221c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  40221e:	685a      	ldr	r2, [r3, #4]
  402220:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  402222:	6842      	ldr	r2, [r0, #4]
  402224:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  402226:	685a      	ldr	r2, [r3, #4]
  402228:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  40222a:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  40222c:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  40222e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  402230:	6803      	ldr	r3, [r0, #0]
  402232:	3301      	adds	r3, #1
  402234:	6003      	str	r3, [r0, #0]
  402236:	4770      	bx	lr

00402238 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  402238:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  40223a:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  40223c:	f1b4 3fff 	cmp.w	r4, #4294967295
  402240:	d101      	bne.n	402246 <vListInsert+0xe>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  402242:	6903      	ldr	r3, [r0, #16]
  402244:	e00a      	b.n	40225c <vListInsert+0x24>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  402246:	f100 0308 	add.w	r3, r0, #8
  40224a:	68c2      	ldr	r2, [r0, #12]
  40224c:	6812      	ldr	r2, [r2, #0]
  40224e:	4294      	cmp	r4, r2
  402250:	d304      	bcc.n	40225c <vListInsert+0x24>
  402252:	685b      	ldr	r3, [r3, #4]
  402254:	685a      	ldr	r2, [r3, #4]
  402256:	6812      	ldr	r2, [r2, #0]
  402258:	4294      	cmp	r4, r2
  40225a:	d2fa      	bcs.n	402252 <vListInsert+0x1a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  40225c:	685a      	ldr	r2, [r3, #4]
  40225e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  402260:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  402262:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  402264:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  402266:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  402268:	6803      	ldr	r3, [r0, #0]
  40226a:	3301      	adds	r3, #1
  40226c:	6003      	str	r3, [r0, #0]
}
  40226e:	f85d 4b04 	ldr.w	r4, [sp], #4
  402272:	4770      	bx	lr

00402274 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  402274:	6843      	ldr	r3, [r0, #4]
  402276:	6882      	ldr	r2, [r0, #8]
  402278:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  40227a:	6883      	ldr	r3, [r0, #8]
  40227c:	6842      	ldr	r2, [r0, #4]
  40227e:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  402280:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  402282:	685a      	ldr	r2, [r3, #4]
  402284:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  402286:	bf04      	itt	eq
  402288:	6882      	ldreq	r2, [r0, #8]
  40228a:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  40228c:	2200      	movs	r2, #0
  40228e:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  402290:	681a      	ldr	r2, [r3, #0]
  402292:	3a01      	subs	r2, #1
  402294:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  402296:	6818      	ldr	r0, [r3, #0]
}
  402298:	4770      	bx	lr
  40229a:	bf00      	nop

0040229c <prvPortStartFirstTask>:

/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile (
  40229c:	4803      	ldr	r0, [pc, #12]	; (4022ac <prvPortStartFirstTask+0x10>)
  40229e:	6800      	ldr	r0, [r0, #0]
  4022a0:	6800      	ldr	r0, [r0, #0]
  4022a2:	f380 8808 	msr	MSP, r0
  4022a6:	b662      	cpsie	i
  4022a8:	df00      	svc	0
  4022aa:	bf00      	nop
  4022ac:	e000ed08 	.word	0xe000ed08

004022b0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  4022b0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 4022c0 <vPortEnableVFP+0x10>
  4022b4:	6801      	ldr	r1, [r0, #0]
  4022b6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4022ba:	6001      	str	r1, [r0, #0]
  4022bc:	4770      	bx	lr
  4022be:	0000      	.short	0x0000
  4022c0:	e000ed88 	.word	0xe000ed88

004022c4 <pxPortInitialiseStack>:
	/* Offset added to account for the way the MCU uses the stack on
	* entry/exit
	* of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;    /* xPSR */
  4022c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  4022c8:	f840 3c04 	str.w	r3, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE)pxCode;       /* PC */
  4022cc:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;    /* LR */
  4022d0:	2300      	movs	r3, #0
  4022d2:	f840 3c0c 	str.w	r3, [r0, #-12]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;    /* R12, R3, R2 and R1. */
	*pxTopOfStack = (portSTACK_TYPE)pvParameters;       /* R0 */
  4022d6:	f840 2c20 	str.w	r2, [r0, #-32]

	/* A save method is being used that requires each task to maintain its
	* own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
  4022da:	f06f 0302 	mvn.w	r3, #2
  4022de:	f840 3c24 	str.w	r3, [r0, #-36]

	pxTopOfStack -= 8;    /* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
  4022e2:	3844      	subs	r0, #68	; 0x44
  4022e4:	4770      	bx	lr
  4022e6:	bf00      	nop

004022e8 <SVC_Handler>:
/*-----------------------------------------------------------*/

/*void vPortSVCHandler( void )*/ /* ATMEL */
__attribute__ ((naked)) void SVC_Handler( void )
{
	__asm volatile (
  4022e8:	4b05      	ldr	r3, [pc, #20]	; (402300 <pxCurrentTCBConst2>)
  4022ea:	6819      	ldr	r1, [r3, #0]
  4022ec:	6808      	ldr	r0, [r1, #0]
  4022ee:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4022f2:	f380 8809 	msr	PSP, r0
  4022f6:	f04f 0000 	mov.w	r0, #0
  4022fa:	f380 8811 	msr	BASEPRI, r0
  4022fe:	4770      	bx	lr

00402300 <pxCurrentTCBConst2>:
  402300:	200050a4 	.word	0x200050a4

00402304 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  402304:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402308:	4b01      	ldr	r3, [pc, #4]	; (402310 <vPortYieldFromISR+0xc>)
  40230a:	601a      	str	r2, [r3, #0]
  40230c:	4770      	bx	lr
  40230e:	bf00      	nop
  402310:	e000ed04 	.word	0xe000ed04

00402314 <ulPortSetInterruptMask>:

/*-----------------------------------------------------------*/

__attribute__((naked)) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile \
  402314:	f3ef 8011 	mrs	r0, BASEPRI
  402318:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  40231c:	f381 8811 	msr	BASEPRI, r1
  402320:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	 * warnings. */
	return 0;
}
  402322:	2000      	movs	r0, #0

00402324 <vPortEnterCritical>:
}

/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  402324:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
  402326:	4b03      	ldr	r3, [pc, #12]	; (402334 <vPortEnterCritical+0x10>)
  402328:	4798      	blx	r3
	uxCriticalNesting++;
  40232a:	4a03      	ldr	r2, [pc, #12]	; (402338 <vPortEnterCritical+0x14>)
  40232c:	6813      	ldr	r3, [r2, #0]
  40232e:	3301      	adds	r3, #1
  402330:	6013      	str	r3, [r2, #0]
  402332:	bd08      	pop	{r3, pc}
  402334:	00402315 	.word	0x00402315
  402338:	200001e8 	.word	0x200001e8

0040233c <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__((naked)) void vPortClearInterruptMask(
		unsigned long ulNewMaskValue )
{
	__asm volatile \
  40233c:	f380 8811 	msr	BASEPRI, r0
  402340:	4770      	bx	lr
  402342:	bf00      	nop

00402344 <vPortExitCritical>:
}

/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  402344:	b508      	push	{r3, lr}
	uxCriticalNesting--;
  402346:	4a04      	ldr	r2, [pc, #16]	; (402358 <vPortExitCritical+0x14>)
  402348:	6813      	ldr	r3, [r2, #0]
  40234a:	3b01      	subs	r3, #1
  40234c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  40234e:	b913      	cbnz	r3, 402356 <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  402350:	2000      	movs	r0, #0
  402352:	4b02      	ldr	r3, [pc, #8]	; (40235c <vPortExitCritical+0x18>)
  402354:	4798      	blx	r3
  402356:	bd08      	pop	{r3, pc}
  402358:	200001e8 	.word	0x200001e8
  40235c:	0040233d 	.word	0x0040233d

00402360 <PendSV_Handler>:
/*void xPortPendSVHandler( void )*/
__attribute__((naked)) void PendSV_Handler( void )   /* ATMEL */
{
	/* This is a naked function. */

	__asm volatile
  402360:	f3ef 8009 	mrs	r0, PSP
  402364:	4b11      	ldr	r3, [pc, #68]	; (4023ac <pxCurrentTCBConst>)
  402366:	681a      	ldr	r2, [r3, #0]
  402368:	f01e 0f10 	tst.w	lr, #16
  40236c:	bf08      	it	eq
  40236e:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  402372:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402376:	6010      	str	r0, [r2, #0]
  402378:	e92d 4008 	stmdb	sp!, {r3, lr}
  40237c:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  402380:	f380 8811 	msr	BASEPRI, r0
  402384:	f001 f90a 	bl	40359c <vTaskSwitchContext>
  402388:	f04f 0000 	mov.w	r0, #0
  40238c:	f380 8811 	msr	BASEPRI, r0
  402390:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  402394:	6819      	ldr	r1, [r3, #0]
  402396:	6808      	ldr	r0, [r1, #0]
  402398:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40239c:	f01e 0f10 	tst.w	lr, #16
  4023a0:	bf08      	it	eq
  4023a2:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  4023a6:	f380 8809 	msr	PSP, r0
  4023aa:	4770      	bx	lr

004023ac <pxCurrentTCBConst>:
  4023ac:	200050a4 	.word	0x200050a4

004023b0 <SysTick_Handler>:
	);
}

/*-----------------------------------------------------------*/
void SysTick_Handler( void ) /* ATMEL */
{
  4023b0:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  4023b2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4023b6:	4b05      	ldr	r3, [pc, #20]	; (4023cc <SysTick_Handler+0x1c>)
  4023b8:	601a      	str	r2, [r3, #0]
	#endif

	(void)portSET_INTERRUPT_MASK_FROM_ISR();
  4023ba:	4b05      	ldr	r3, [pc, #20]	; (4023d0 <SysTick_Handler+0x20>)
  4023bc:	4798      	blx	r3
	{
		vTaskIncrementTick();
  4023be:	4b05      	ldr	r3, [pc, #20]	; (4023d4 <SysTick_Handler+0x24>)
  4023c0:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  4023c2:	2000      	movs	r0, #0
  4023c4:	4b04      	ldr	r3, [pc, #16]	; (4023d8 <SysTick_Handler+0x28>)
  4023c6:	4798      	blx	r3
  4023c8:	bd08      	pop	{r3, pc}
  4023ca:	bf00      	nop
  4023cc:	e000ed04 	.word	0xe000ed04
  4023d0:	00402315 	.word	0x00402315
  4023d4:	004030c5 	.word	0x004030c5
  4023d8:	0040233d 	.word	0x0040233d

004023dc <vPortSetupTimerInterrupt>:
 */
__attribute__((weak)) void vPortSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG
		= (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
  4023dc:	4a03      	ldr	r2, [pc, #12]	; (4023ec <vPortSetupTimerInterrupt+0x10>)
  4023de:	4b04      	ldr	r3, [pc, #16]	; (4023f0 <vPortSetupTimerInterrupt+0x14>)
  4023e0:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT |
  4023e2:	2207      	movs	r2, #7
  4023e4:	3b04      	subs	r3, #4
  4023e6:	601a      	str	r2, [r3, #0]
  4023e8:	4770      	bx	lr
  4023ea:	bf00      	nop
  4023ec:	0001d4bb 	.word	0x0001d4bb
  4023f0:	e000e014 	.word	0xe000e014

004023f4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
  4023f4:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	* See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  4023f6:	4b0c      	ldr	r3, [pc, #48]	; (402428 <xPortStartScheduler+0x34>)
  4023f8:	681a      	ldr	r2, [r3, #0]
  4023fa:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  4023fe:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  402400:	681a      	ldr	r2, [r3, #0]
  402402:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
  402406:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	* here already. */
	vPortSetupTimerInterrupt();
  402408:	4b08      	ldr	r3, [pc, #32]	; (40242c <xPortStartScheduler+0x38>)
  40240a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  40240c:	2400      	movs	r4, #0
  40240e:	4b08      	ldr	r3, [pc, #32]	; (402430 <xPortStartScheduler+0x3c>)
  402410:	601c      	str	r4, [r3, #0]

#if defined (__VFP_FP__) && !defined(__SOFTFP__)
	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
  402412:	4b08      	ldr	r3, [pc, #32]	; (402434 <xPortStartScheduler+0x40>)
  402414:	4798      	blx	r3
#endif

	/* Lazy save always. */
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
  402416:	4a08      	ldr	r2, [pc, #32]	; (402438 <xPortStartScheduler+0x44>)
  402418:	6813      	ldr	r3, [r2, #0]
  40241a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  40241e:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  402420:	4b06      	ldr	r3, [pc, #24]	; (40243c <xPortStartScheduler+0x48>)
  402422:	4798      	blx	r3

	/* Should not get here! */
	return 0;
}
  402424:	4620      	mov	r0, r4
  402426:	bd10      	pop	{r4, pc}
  402428:	e000ed20 	.word	0xe000ed20
  40242c:	004023dd 	.word	0x004023dd
  402430:	200001e8 	.word	0x200001e8
  402434:	004022b1 	.word	0x004022b1
  402438:	e000ef34 	.word	0xe000ef34
  40243c:	0040229d 	.word	0x0040229d

00402440 <prvInsertBlockIntoFreeList>:
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  402440:	4a13      	ldr	r2, [pc, #76]	; (402490 <prvInsertBlockIntoFreeList+0x50>)
  402442:	e000      	b.n	402446 <prvInsertBlockIntoFreeList+0x6>
  402444:	461a      	mov	r2, r3
  402446:	6813      	ldr	r3, [r2, #0]
  402448:	4283      	cmp	r3, r0
  40244a:	d3fb      	bcc.n	402444 <prvInsertBlockIntoFreeList+0x4>
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  40244c:	b430      	push	{r4, r5}
  40244e:	4611      	mov	r1, r2
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  402450:	6854      	ldr	r4, [r2, #4]
  402452:	1915      	adds	r5, r2, r4
  402454:	4285      	cmp	r5, r0
  402456:	d103      	bne.n	402460 <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  402458:	6868      	ldr	r0, [r5, #4]
  40245a:	4404      	add	r4, r0
  40245c:	6054      	str	r4, [r2, #4]
  40245e:	4610      	mov	r0, r2
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  402460:	6842      	ldr	r2, [r0, #4]
  402462:	1884      	adds	r4, r0, r2
  402464:	429c      	cmp	r4, r3
  402466:	d10c      	bne.n	402482 <prvInsertBlockIntoFreeList+0x42>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  402468:	4b0a      	ldr	r3, [pc, #40]	; (402494 <prvInsertBlockIntoFreeList+0x54>)
  40246a:	681b      	ldr	r3, [r3, #0]
  40246c:	429c      	cmp	r4, r3
  40246e:	d006      	beq.n	40247e <prvInsertBlockIntoFreeList+0x3e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  402470:	6863      	ldr	r3, [r4, #4]
  402472:	441a      	add	r2, r3
  402474:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  402476:	680b      	ldr	r3, [r1, #0]
  402478:	681b      	ldr	r3, [r3, #0]
  40247a:	6003      	str	r3, [r0, #0]
  40247c:	e002      	b.n	402484 <prvInsertBlockIntoFreeList+0x44>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  40247e:	6004      	str	r4, [r0, #0]
  402480:	e000      	b.n	402484 <prvInsertBlockIntoFreeList+0x44>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  402482:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  402484:	4281      	cmp	r1, r0
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  402486:	bf18      	it	ne
  402488:	6008      	strne	r0, [r1, #0]
	}
}
  40248a:	bc30      	pop	{r4, r5}
  40248c:	4770      	bx	lr
  40248e:	bf00      	nop
  402490:	20004fec 	.word	0x20004fec
  402494:	20004fe8 	.word	0x20004fe8

00402498 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  402498:	b538      	push	{r3, r4, r5, lr}
  40249a:	4604      	mov	r4, r0
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
  40249c:	4b2b      	ldr	r3, [pc, #172]	; (40254c <pvPortMalloc+0xb4>)
  40249e:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  4024a0:	4b2b      	ldr	r3, [pc, #172]	; (402550 <pvPortMalloc+0xb8>)
  4024a2:	681b      	ldr	r3, [r3, #0]
  4024a4:	b99b      	cbnz	r3, 4024ce <pvPortMalloc+0x36>
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  4024a6:	4a2b      	ldr	r2, [pc, #172]	; (402554 <pvPortMalloc+0xbc>)
  4024a8:	4b2b      	ldr	r3, [pc, #172]	; (402558 <pvPortMalloc+0xc0>)
  4024aa:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4024ac:	2100      	movs	r1, #0
  4024ae:	6051      	str	r1, [r2, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
	pucHeapEnd -= heapSTRUCT_SIZE;
	pxEnd = ( void * ) pucHeapEnd;
  4024b0:	f643 72f0 	movw	r2, #16368	; 0x3ff0
  4024b4:	1898      	adds	r0, r3, r2
  4024b6:	4d26      	ldr	r5, [pc, #152]	; (402550 <pvPortMalloc+0xb8>)
  4024b8:	6028      	str	r0, [r5, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
	pxEnd->xBlockSize = 0;
  4024ba:	f643 75f4 	movw	r5, #16372	; 0x3ff4
  4024be:	5159      	str	r1, [r3, r5]
	pxEnd->pxNextFreeBlock = NULL;
  4024c0:	5099      	str	r1, [r3, r2]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  4024c2:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  4024c4:	6018      	str	r0, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  4024c6:	4a25      	ldr	r2, [pc, #148]	; (40255c <pvPortMalloc+0xc4>)
  4024c8:	6813      	ldr	r3, [r2, #0]
  4024ca:	3b10      	subs	r3, #16
  4024cc:	6013      	str	r3, [r2, #0]
			prvHeapInit();
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  4024ce:	2c00      	cmp	r4, #0
  4024d0:	d037      	beq.n	402542 <pvPortMalloc+0xaa>
		{
			xWantedSize += heapSTRUCT_SIZE;
  4024d2:	f104 0210 	add.w	r2, r4, #16

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  4024d6:	f012 0f07 	tst.w	r2, #7
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  4024da:	bf1c      	itt	ne
  4024dc:	f022 0207 	bicne.w	r2, r2, #7
  4024e0:	3208      	addne	r2, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  4024e2:	1e51      	subs	r1, r2, #1
  4024e4:	f643 73fe 	movw	r3, #16382	; 0x3ffe
  4024e8:	4299      	cmp	r1, r3
  4024ea:	d827      	bhi.n	40253c <pvPortMalloc+0xa4>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
  4024ec:	4919      	ldr	r1, [pc, #100]	; (402554 <pvPortMalloc+0xbc>)
  4024ee:	680c      	ldr	r4, [r1, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4024f0:	e001      	b.n	4024f6 <pvPortMalloc+0x5e>
  4024f2:	4621      	mov	r1, r4
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
  4024f4:	461c      	mov	r4, r3
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4024f6:	6863      	ldr	r3, [r4, #4]
  4024f8:	429a      	cmp	r2, r3
  4024fa:	d902      	bls.n	402502 <pvPortMalloc+0x6a>
  4024fc:	6823      	ldr	r3, [r4, #0]
  4024fe:	2b00      	cmp	r3, #0
  402500:	d1f7      	bne.n	4024f2 <pvPortMalloc+0x5a>
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
  402502:	4b13      	ldr	r3, [pc, #76]	; (402550 <pvPortMalloc+0xb8>)
  402504:	681b      	ldr	r3, [r3, #0]
  402506:	429c      	cmp	r4, r3
  402508:	d018      	beq.n	40253c <pvPortMalloc+0xa4>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  40250a:	680d      	ldr	r5, [r1, #0]
  40250c:	3510      	adds	r5, #16

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  40250e:	6823      	ldr	r3, [r4, #0]
  402510:	600b      	str	r3, [r1, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  402512:	6863      	ldr	r3, [r4, #4]
  402514:	1a9b      	subs	r3, r3, r2
  402516:	2b20      	cmp	r3, #32
  402518:	d904      	bls.n	402524 <pvPortMalloc+0x8c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  40251a:	18a0      	adds	r0, r4, r2

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  40251c:	6043      	str	r3, [r0, #4]
					pxBlock->xBlockSize = xWantedSize;
  40251e:	6062      	str	r2, [r4, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  402520:	4b0f      	ldr	r3, [pc, #60]	; (402560 <pvPortMalloc+0xc8>)
  402522:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  402524:	4a0d      	ldr	r2, [pc, #52]	; (40255c <pvPortMalloc+0xc4>)
  402526:	6813      	ldr	r3, [r2, #0]
  402528:	6861      	ldr	r1, [r4, #4]
  40252a:	1a5b      	subs	r3, r3, r1
  40252c:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
  40252e:	4b0d      	ldr	r3, [pc, #52]	; (402564 <pvPortMalloc+0xcc>)
  402530:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
  402532:	b94d      	cbnz	r5, 402548 <pvPortMalloc+0xb0>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
  402534:	4b0c      	ldr	r3, [pc, #48]	; (402568 <pvPortMalloc+0xd0>)
  402536:	4798      	blx	r3
  402538:	2500      	movs	r5, #0
  40253a:	e005      	b.n	402548 <pvPortMalloc+0xb0>

				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
  40253c:	4b09      	ldr	r3, [pc, #36]	; (402564 <pvPortMalloc+0xcc>)
  40253e:	4798      	blx	r3
  402540:	e7f8      	b.n	402534 <pvPortMalloc+0x9c>
  402542:	4b08      	ldr	r3, [pc, #32]	; (402564 <pvPortMalloc+0xcc>)
  402544:	4798      	blx	r3
  402546:	e7f5      	b.n	402534 <pvPortMalloc+0x9c>
		}
	}
	#endif

	return pvReturn;
}
  402548:	4628      	mov	r0, r5
  40254a:	bd38      	pop	{r3, r4, r5, pc}
  40254c:	00403075 	.word	0x00403075
  402550:	20004fe8 	.word	0x20004fe8
  402554:	20004fec 	.word	0x20004fec
  402558:	20000fe8 	.word	0x20000fe8
  40255c:	200001ec 	.word	0x200001ec
  402560:	00402441 	.word	0x00402441
  402564:	004031f1 	.word	0x004031f1
  402568:	0040418d 	.word	0x0040418d

0040256c <vPortFree>:
void vPortFree( void *pv )
{
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv != NULL )
  40256c:	b180      	cbz	r0, 402590 <vPortFree+0x24>
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  40256e:	b510      	push	{r4, lr}
  402570:	4604      	mov	r4, r0
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
  402572:	4b08      	ldr	r3, [pc, #32]	; (402594 <vPortFree+0x28>)
  402574:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
  402576:	4a08      	ldr	r2, [pc, #32]	; (402598 <vPortFree+0x2c>)
  402578:	6811      	ldr	r1, [r2, #0]
  40257a:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  40257e:	440b      	add	r3, r1
  402580:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  402582:	f1a4 0010 	sub.w	r0, r4, #16
  402586:	4b05      	ldr	r3, [pc, #20]	; (40259c <vPortFree+0x30>)
  402588:	4798      	blx	r3
		}
		xTaskResumeAll();
  40258a:	4b05      	ldr	r3, [pc, #20]	; (4025a0 <vPortFree+0x34>)
  40258c:	4798      	blx	r3
  40258e:	bd10      	pop	{r4, pc}
  402590:	4770      	bx	lr
  402592:	bf00      	nop
  402594:	00403075 	.word	0x00403075
  402598:	200001ec 	.word	0x200001ec
  40259c:	00402441 	.word	0x00402441
  4025a0:	004031f1 	.word	0x004031f1

004025a4 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4025a4:	b510      	push	{r4, lr}
  4025a6:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4025a8:	6c03      	ldr	r3, [r0, #64]	; 0x40
  4025aa:	b93b      	cbnz	r3, 4025bc <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4025ac:	6803      	ldr	r3, [r0, #0]
  4025ae:	bb1b      	cbnz	r3, 4025f8 <prvCopyDataToQueue+0x54>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  4025b0:	6840      	ldr	r0, [r0, #4]
  4025b2:	4b13      	ldr	r3, [pc, #76]	; (402600 <prvCopyDataToQueue+0x5c>)
  4025b4:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  4025b6:	2300      	movs	r3, #0
  4025b8:	6063      	str	r3, [r4, #4]
  4025ba:	e01d      	b.n	4025f8 <prvCopyDataToQueue+0x54>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  4025bc:	b96a      	cbnz	r2, 4025da <prvCopyDataToQueue+0x36>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  4025be:	6880      	ldr	r0, [r0, #8]
  4025c0:	461a      	mov	r2, r3
  4025c2:	4b10      	ldr	r3, [pc, #64]	; (402604 <prvCopyDataToQueue+0x60>)
  4025c4:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4025c6:	68a2      	ldr	r2, [r4, #8]
  4025c8:	6c23      	ldr	r3, [r4, #64]	; 0x40
  4025ca:	4413      	add	r3, r2
  4025cc:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  4025ce:	6862      	ldr	r2, [r4, #4]
  4025d0:	4293      	cmp	r3, r2
  4025d2:	d311      	bcc.n	4025f8 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  4025d4:	6823      	ldr	r3, [r4, #0]
  4025d6:	60a3      	str	r3, [r4, #8]
  4025d8:	e00e      	b.n	4025f8 <prvCopyDataToQueue+0x54>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  4025da:	68c0      	ldr	r0, [r0, #12]
  4025dc:	461a      	mov	r2, r3
  4025de:	4b09      	ldr	r3, [pc, #36]	; (402604 <prvCopyDataToQueue+0x60>)
  4025e0:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  4025e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
  4025e4:	425b      	negs	r3, r3
  4025e6:	68e2      	ldr	r2, [r4, #12]
  4025e8:	441a      	add	r2, r3
  4025ea:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  4025ec:	6821      	ldr	r1, [r4, #0]
  4025ee:	428a      	cmp	r2, r1
  4025f0:	d202      	bcs.n	4025f8 <prvCopyDataToQueue+0x54>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  4025f2:	6862      	ldr	r2, [r4, #4]
  4025f4:	4413      	add	r3, r2
  4025f6:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  4025f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4025fa:	3301      	adds	r3, #1
  4025fc:	63a3      	str	r3, [r4, #56]	; 0x38
  4025fe:	bd10      	pop	{r4, pc}
  402600:	00403989 	.word	0x00403989
  402604:	004044ed 	.word	0x004044ed

00402608 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  402608:	b538      	push	{r3, r4, r5, lr}
  40260a:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  40260c:	6800      	ldr	r0, [r0, #0]
  40260e:	b158      	cbz	r0, 402628 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  402610:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  402612:	68dc      	ldr	r4, [r3, #12]
  402614:	4414      	add	r4, r2
  402616:	60dc      	str	r4, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  402618:	685d      	ldr	r5, [r3, #4]
  40261a:	42ac      	cmp	r4, r5
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  40261c:	bf28      	it	cs
  40261e:	60d8      	strcs	r0, [r3, #12]
  402620:	4608      	mov	r0, r1
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  402622:	68d9      	ldr	r1, [r3, #12]
  402624:	4b01      	ldr	r3, [pc, #4]	; (40262c <prvCopyDataFromQueue+0x24>)
  402626:	4798      	blx	r3
  402628:	bd38      	pop	{r3, r4, r5, pc}
  40262a:	bf00      	nop
  40262c:	004044ed 	.word	0x004044ed

00402630 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  402630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402632:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  402634:	4b1e      	ldr	r3, [pc, #120]	; (4026b0 <prvUnlockQueue+0x80>)
  402636:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  402638:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40263a:	2b00      	cmp	r3, #0
  40263c:	dd13      	ble.n	402666 <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40263e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402640:	b91b      	cbnz	r3, 40264a <prvUnlockQueue+0x1a>
  402642:	e010      	b.n	402666 <prvUnlockQueue+0x36>
  402644:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402646:	b923      	cbnz	r3, 402652 <prvUnlockQueue+0x22>
  402648:	e00d      	b.n	402666 <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40264a:	f104 0624 	add.w	r6, r4, #36	; 0x24
  40264e:	4d19      	ldr	r5, [pc, #100]	; (4026b4 <prvUnlockQueue+0x84>)
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  402650:	4f19      	ldr	r7, [pc, #100]	; (4026b8 <prvUnlockQueue+0x88>)
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402652:	4630      	mov	r0, r6
  402654:	47a8      	blx	r5
  402656:	b100      	cbz	r0, 40265a <prvUnlockQueue+0x2a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  402658:	47b8      	blx	r7
				}

				--( pxQueue->xTxLock );
  40265a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40265c:	3b01      	subs	r3, #1
  40265e:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  402660:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  402662:	2b00      	cmp	r3, #0
  402664:	dcee      	bgt.n	402644 <prvUnlockQueue+0x14>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  402666:	f04f 33ff 	mov.w	r3, #4294967295
  40266a:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  40266c:	4b13      	ldr	r3, [pc, #76]	; (4026bc <prvUnlockQueue+0x8c>)
  40266e:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  402670:	4b0f      	ldr	r3, [pc, #60]	; (4026b0 <prvUnlockQueue+0x80>)
  402672:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  402674:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402676:	2b00      	cmp	r3, #0
  402678:	dd13      	ble.n	4026a2 <prvUnlockQueue+0x72>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40267a:	6923      	ldr	r3, [r4, #16]
  40267c:	b91b      	cbnz	r3, 402686 <prvUnlockQueue+0x56>
  40267e:	e010      	b.n	4026a2 <prvUnlockQueue+0x72>
  402680:	6923      	ldr	r3, [r4, #16]
  402682:	b923      	cbnz	r3, 40268e <prvUnlockQueue+0x5e>
  402684:	e00d      	b.n	4026a2 <prvUnlockQueue+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  402686:	f104 0610 	add.w	r6, r4, #16
  40268a:	4d0a      	ldr	r5, [pc, #40]	; (4026b4 <prvUnlockQueue+0x84>)
				{
					vTaskMissedYield();
  40268c:	4f0a      	ldr	r7, [pc, #40]	; (4026b8 <prvUnlockQueue+0x88>)
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40268e:	4630      	mov	r0, r6
  402690:	47a8      	blx	r5
  402692:	b100      	cbz	r0, 402696 <prvUnlockQueue+0x66>
				{
					vTaskMissedYield();
  402694:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  402696:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402698:	3b01      	subs	r3, #1
  40269a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  40269c:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40269e:	2b00      	cmp	r3, #0
  4026a0:	dcee      	bgt.n	402680 <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  4026a2:	f04f 33ff 	mov.w	r3, #4294967295
  4026a6:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  4026a8:	4b04      	ldr	r3, [pc, #16]	; (4026bc <prvUnlockQueue+0x8c>)
  4026aa:	4798      	blx	r3
  4026ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4026ae:	bf00      	nop
  4026b0:	00402325 	.word	0x00402325
  4026b4:	00403771 	.word	0x00403771
  4026b8:	004038b5 	.word	0x004038b5
  4026bc:	00402345 	.word	0x00402345

004026c0 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
  4026c0:	b538      	push	{r3, r4, r5, lr}
  4026c2:	460d      	mov	r5, r1
	configASSERT( pxQueue );
  4026c4:	4604      	mov	r4, r0
  4026c6:	b920      	cbnz	r0, 4026d2 <xQueueGenericReset+0x12>
  4026c8:	4817      	ldr	r0, [pc, #92]	; (402728 <xQueueGenericReset+0x68>)
  4026ca:	f240 111b 	movw	r1, #283	; 0x11b
  4026ce:	4b17      	ldr	r3, [pc, #92]	; (40272c <xQueueGenericReset+0x6c>)
  4026d0:	4798      	blx	r3

	taskENTER_CRITICAL();
  4026d2:	4b17      	ldr	r3, [pc, #92]	; (402730 <xQueueGenericReset+0x70>)
  4026d4:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  4026d6:	6822      	ldr	r2, [r4, #0]
  4026d8:	6c21      	ldr	r1, [r4, #64]	; 0x40
  4026da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4026dc:	fb03 f301 	mul.w	r3, r3, r1
  4026e0:	18d0      	adds	r0, r2, r3
  4026e2:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  4026e4:	2000      	movs	r0, #0
  4026e6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  4026e8:	60a2      	str	r2, [r4, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  4026ea:	1a5b      	subs	r3, r3, r1
  4026ec:	4413      	add	r3, r2
  4026ee:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  4026f0:	f04f 33ff 	mov.w	r3, #4294967295
  4026f4:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  4026f6:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  4026f8:	b955      	cbnz	r5, 402710 <xQueueGenericReset+0x50>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4026fa:	6923      	ldr	r3, [r4, #16]
  4026fc:	b17b      	cbz	r3, 40271e <xQueueGenericReset+0x5e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  4026fe:	f104 0010 	add.w	r0, r4, #16
  402702:	4b0c      	ldr	r3, [pc, #48]	; (402734 <xQueueGenericReset+0x74>)
  402704:	4798      	blx	r3
  402706:	2801      	cmp	r0, #1
  402708:	d109      	bne.n	40271e <xQueueGenericReset+0x5e>
				{
					portYIELD_WITHIN_API();
  40270a:	4b0b      	ldr	r3, [pc, #44]	; (402738 <xQueueGenericReset+0x78>)
  40270c:	4798      	blx	r3
  40270e:	e006      	b.n	40271e <xQueueGenericReset+0x5e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  402710:	f104 0010 	add.w	r0, r4, #16
  402714:	4d09      	ldr	r5, [pc, #36]	; (40273c <xQueueGenericReset+0x7c>)
  402716:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  402718:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40271c:	47a8      	blx	r5
		}
	}
	taskEXIT_CRITICAL();
  40271e:	4b08      	ldr	r3, [pc, #32]	; (402740 <xQueueGenericReset+0x80>)
  402720:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
  402722:	2001      	movs	r0, #1
  402724:	bd38      	pop	{r3, r4, r5, pc}
  402726:	bf00      	nop
  402728:	0040aaa8 	.word	0x0040aaa8
  40272c:	004041a5 	.word	0x004041a5
  402730:	00402325 	.word	0x00402325
  402734:	00403771 	.word	0x00403771
  402738:	00402305 	.word	0x00402305
  40273c:	004021fd 	.word	0x004021fd
  402740:	00402345 	.word	0x00402345

00402744 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  402744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  402746:	b1d0      	cbz	r0, 40277e <xQueueGenericCreate+0x3a>
  402748:	460d      	mov	r5, r1
  40274a:	4617      	mov	r7, r2
  40274c:	4606      	mov	r6, r0
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  40274e:	2050      	movs	r0, #80	; 0x50
  402750:	4b0f      	ldr	r3, [pc, #60]	; (402790 <xQueueGenericCreate+0x4c>)
  402752:	4798      	blx	r3
		if( pxNewQueue != NULL )
  402754:	4604      	mov	r4, r0
  402756:	b190      	cbz	r0, 40277e <xQueueGenericCreate+0x3a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  402758:	fb05 f006 	mul.w	r0, r5, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  40275c:	3001      	adds	r0, #1
  40275e:	4b0c      	ldr	r3, [pc, #48]	; (402790 <xQueueGenericCreate+0x4c>)
  402760:	4798      	blx	r3
  402762:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
  402764:	b140      	cbz	r0, 402778 <xQueueGenericCreate+0x34>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  402766:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  402768:	6425      	str	r5, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  40276a:	4620      	mov	r0, r4
  40276c:	2101      	movs	r1, #1
  40276e:	4b09      	ldr	r3, [pc, #36]	; (402794 <xQueueGenericCreate+0x50>)
  402770:	4798      	blx	r3
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
  402772:	f884 704d 	strb.w	r7, [r4, #77]	; 0x4d
  402776:	e008      	b.n	40278a <xQueueGenericCreate+0x46>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  402778:	4620      	mov	r0, r4
  40277a:	4b07      	ldr	r3, [pc, #28]	; (402798 <xQueueGenericCreate+0x54>)
  40277c:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  40277e:	4807      	ldr	r0, [pc, #28]	; (40279c <xQueueGenericCreate+0x58>)
  402780:	f240 1171 	movw	r1, #369	; 0x171
  402784:	4b06      	ldr	r3, [pc, #24]	; (4027a0 <xQueueGenericCreate+0x5c>)
  402786:	4798      	blx	r3
  402788:	2400      	movs	r4, #0

	return xReturn;
}
  40278a:	4620      	mov	r0, r4
  40278c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40278e:	bf00      	nop
  402790:	00402499 	.word	0x00402499
  402794:	004026c1 	.word	0x004026c1
  402798:	0040256d 	.word	0x0040256d
  40279c:	0040aaa8 	.word	0x0040aaa8
  4027a0:	004041a5 	.word	0x004041a5

004027a4 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
  4027a4:	b538      	push	{r3, r4, r5, lr}
  4027a6:	460d      	mov	r5, r1
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  4027a8:	2100      	movs	r1, #0
  4027aa:	2202      	movs	r2, #2
  4027ac:	4b06      	ldr	r3, [pc, #24]	; (4027c8 <xQueueCreateCountingSemaphore+0x24>)
  4027ae:	4798      	blx	r3

		if( pxHandle != NULL )
  4027b0:	4604      	mov	r4, r0
  4027b2:	b108      	cbz	r0, 4027b8 <xQueueCreateCountingSemaphore+0x14>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
  4027b4:	6385      	str	r5, [r0, #56]	; 0x38
  4027b6:	e004      	b.n	4027c2 <xQueueCreateCountingSemaphore+0x1e>
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
  4027b8:	4804      	ldr	r0, [pc, #16]	; (4027cc <xQueueCreateCountingSemaphore+0x28>)
  4027ba:	f44f 710f 	mov.w	r1, #572	; 0x23c
  4027be:	4b04      	ldr	r3, [pc, #16]	; (4027d0 <xQueueCreateCountingSemaphore+0x2c>)
  4027c0:	4798      	blx	r3
		return pxHandle;
	}
  4027c2:	4620      	mov	r0, r4
  4027c4:	bd38      	pop	{r3, r4, r5, pc}
  4027c6:	bf00      	nop
  4027c8:	00402745 	.word	0x00402745
  4027cc:	0040aaa8 	.word	0x0040aaa8
  4027d0:	004041a5 	.word	0x004041a5

004027d4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  4027d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4027d8:	b085      	sub	sp, #20
  4027da:	468b      	mov	fp, r1
  4027dc:	9201      	str	r2, [sp, #4]
  4027de:	9300      	str	r3, [sp, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;

	configASSERT( pxQueue );
  4027e0:	4604      	mov	r4, r0
  4027e2:	b920      	cbnz	r0, 4027ee <xQueueGenericSend+0x1a>
  4027e4:	483a      	ldr	r0, [pc, #232]	; (4028d0 <xQueueGenericSend+0xfc>)
  4027e6:	f44f 7112 	mov.w	r1, #584	; 0x248
  4027ea:	4b3a      	ldr	r3, [pc, #232]	; (4028d4 <xQueueGenericSend+0x100>)
  4027ec:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  4027ee:	f1bb 0f00 	cmp.w	fp, #0
  4027f2:	d106      	bne.n	402802 <xQueueGenericSend+0x2e>
  4027f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
  4027f6:	b123      	cbz	r3, 402802 <xQueueGenericSend+0x2e>
  4027f8:	4835      	ldr	r0, [pc, #212]	; (4028d0 <xQueueGenericSend+0xfc>)
  4027fa:	f240 2149 	movw	r1, #585	; 0x249
  4027fe:	4b35      	ldr	r3, [pc, #212]	; (4028d4 <xQueueGenericSend+0x100>)
  402800:	4798      	blx	r3

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  402802:	f04f 0900 	mov.w	r9, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  402806:	4d34      	ldr	r5, [pc, #208]	; (4028d8 <xQueueGenericSend+0x104>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402808:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 402900 <xQueueGenericSend+0x12c>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  40280c:	4e33      	ldr	r6, [pc, #204]	; (4028dc <xQueueGenericSend+0x108>)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  40280e:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  402810:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  402812:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  402814:	429a      	cmp	r2, r3
  402816:	d212      	bcs.n	40283e <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  402818:	4620      	mov	r0, r4
  40281a:	4659      	mov	r1, fp
  40281c:	9a00      	ldr	r2, [sp, #0]
  40281e:	4b30      	ldr	r3, [pc, #192]	; (4028e0 <xQueueGenericSend+0x10c>)
  402820:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  402822:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402824:	b13b      	cbz	r3, 402836 <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  402826:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40282a:	4b2e      	ldr	r3, [pc, #184]	; (4028e4 <xQueueGenericSend+0x110>)
  40282c:	4798      	blx	r3
  40282e:	2801      	cmp	r0, #1
  402830:	d101      	bne.n	402836 <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  402832:	4b2d      	ldr	r3, [pc, #180]	; (4028e8 <xQueueGenericSend+0x114>)
  402834:	4798      	blx	r3
					}
				}

				taskEXIT_CRITICAL();
  402836:	4b29      	ldr	r3, [pc, #164]	; (4028dc <xQueueGenericSend+0x108>)
  402838:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  40283a:	2001      	movs	r0, #1
  40283c:	e044      	b.n	4028c8 <xQueueGenericSend+0xf4>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  40283e:	9b01      	ldr	r3, [sp, #4]
  402840:	b91b      	cbnz	r3, 40284a <xQueueGenericSend+0x76>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  402842:	4b26      	ldr	r3, [pc, #152]	; (4028dc <xQueueGenericSend+0x108>)
  402844:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  402846:	2000      	movs	r0, #0
  402848:	e03e      	b.n	4028c8 <xQueueGenericSend+0xf4>
				}
				else if( xEntryTimeSet == pdFALSE )
  40284a:	f1b9 0f00 	cmp.w	r9, #0
  40284e:	d103      	bne.n	402858 <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402850:	a802      	add	r0, sp, #8
  402852:	47d0      	blx	sl
					xEntryTimeSet = pdTRUE;
  402854:	f04f 0901 	mov.w	r9, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  402858:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40285a:	4b24      	ldr	r3, [pc, #144]	; (4028ec <xQueueGenericSend+0x118>)
  40285c:	4798      	blx	r3
		prvLockQueue( pxQueue );
  40285e:	47a8      	blx	r5
  402860:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402862:	f1b3 3fff 	cmp.w	r3, #4294967295
  402866:	bf04      	itt	eq
  402868:	2300      	moveq	r3, #0
  40286a:	6463      	streq	r3, [r4, #68]	; 0x44
  40286c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40286e:	f1b3 3fff 	cmp.w	r3, #4294967295
  402872:	bf04      	itt	eq
  402874:	2300      	moveq	r3, #0
  402876:	64a3      	streq	r3, [r4, #72]	; 0x48
  402878:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40287a:	a802      	add	r0, sp, #8
  40287c:	a901      	add	r1, sp, #4
  40287e:	4b1c      	ldr	r3, [pc, #112]	; (4028f0 <xQueueGenericSend+0x11c>)
  402880:	4798      	blx	r3
  402882:	b9d8      	cbnz	r0, 4028bc <xQueueGenericSend+0xe8>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402884:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  402886:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
  40288a:	6be7      	ldr	r7, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  40288c:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  40288e:	45b8      	cmp	r8, r7
  402890:	d10e      	bne.n	4028b0 <xQueueGenericSend+0xdc>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  402892:	f104 0010 	add.w	r0, r4, #16
  402896:	9901      	ldr	r1, [sp, #4]
  402898:	4b16      	ldr	r3, [pc, #88]	; (4028f4 <xQueueGenericSend+0x120>)
  40289a:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  40289c:	4620      	mov	r0, r4
  40289e:	4b16      	ldr	r3, [pc, #88]	; (4028f8 <xQueueGenericSend+0x124>)
  4028a0:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  4028a2:	4b16      	ldr	r3, [pc, #88]	; (4028fc <xQueueGenericSend+0x128>)
  4028a4:	4798      	blx	r3
  4028a6:	2800      	cmp	r0, #0
  4028a8:	d1b1      	bne.n	40280e <xQueueGenericSend+0x3a>
				{
					portYIELD_WITHIN_API();
  4028aa:	4b0f      	ldr	r3, [pc, #60]	; (4028e8 <xQueueGenericSend+0x114>)
  4028ac:	4798      	blx	r3
  4028ae:	e7ae      	b.n	40280e <xQueueGenericSend+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4028b0:	4620      	mov	r0, r4
  4028b2:	4b11      	ldr	r3, [pc, #68]	; (4028f8 <xQueueGenericSend+0x124>)
  4028b4:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4028b6:	4b11      	ldr	r3, [pc, #68]	; (4028fc <xQueueGenericSend+0x128>)
  4028b8:	4798      	blx	r3
  4028ba:	e7a8      	b.n	40280e <xQueueGenericSend+0x3a>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4028bc:	4620      	mov	r0, r4
  4028be:	4b0e      	ldr	r3, [pc, #56]	; (4028f8 <xQueueGenericSend+0x124>)
  4028c0:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4028c2:	4b0e      	ldr	r3, [pc, #56]	; (4028fc <xQueueGenericSend+0x128>)
  4028c4:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  4028c6:	2000      	movs	r0, #0
		}
	}
}
  4028c8:	b005      	add	sp, #20
  4028ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4028ce:	bf00      	nop
  4028d0:	0040aaa8 	.word	0x0040aaa8
  4028d4:	004041a5 	.word	0x004041a5
  4028d8:	00402325 	.word	0x00402325
  4028dc:	00402345 	.word	0x00402345
  4028e0:	004025a5 	.word	0x004025a5
  4028e4:	00403771 	.word	0x00403771
  4028e8:	00402305 	.word	0x00402305
  4028ec:	00403075 	.word	0x00403075
  4028f0:	00403829 	.word	0x00403829
  4028f4:	00403685 	.word	0x00403685
  4028f8:	00402631 	.word	0x00402631
  4028fc:	004031f1 	.word	0x004031f1
  402900:	004037f9 	.word	0x004037f9

00402904 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
  402904:	b570      	push	{r4, r5, r6, lr}
  402906:	4606      	mov	r6, r0
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  402908:	2050      	movs	r0, #80	; 0x50
  40290a:	4b13      	ldr	r3, [pc, #76]	; (402958 <xQueueCreateMutex+0x54>)
  40290c:	4798      	blx	r3
		if( pxNewQueue != NULL )
  40290e:	4604      	mov	r4, r0
  402910:	b1d8      	cbz	r0, 40294a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  402912:	2500      	movs	r5, #0
  402914:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  402916:	6005      	str	r5, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
  402918:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
  40291a:	60c5      	str	r5, [r0, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  40291c:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
  40291e:	2301      	movs	r3, #1
  402920:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
  402922:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
  402924:	f04f 33ff 	mov.w	r3, #4294967295
  402928:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
  40292a:	6483      	str	r3, [r0, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
  40292c:	f880 604d 	strb.w	r6, [r0, #77]	; 0x4d
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  402930:	3010      	adds	r0, #16
  402932:	4e0a      	ldr	r6, [pc, #40]	; (40295c <xQueueCreateMutex+0x58>)
  402934:	47b0      	blx	r6
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  402936:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40293a:	47b0      	blx	r6

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
  40293c:	4620      	mov	r0, r4
  40293e:	4629      	mov	r1, r5
  402940:	462a      	mov	r2, r5
  402942:	462b      	mov	r3, r5
  402944:	4d06      	ldr	r5, [pc, #24]	; (402960 <xQueueCreateMutex+0x5c>)
  402946:	47a8      	blx	r5
  402948:	e004      	b.n	402954 <xQueueCreateMutex+0x50>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
  40294a:	4806      	ldr	r0, [pc, #24]	; (402964 <xQueueCreateMutex+0x60>)
  40294c:	f240 11ab 	movw	r1, #427	; 0x1ab
  402950:	4b05      	ldr	r3, [pc, #20]	; (402968 <xQueueCreateMutex+0x64>)
  402952:	4798      	blx	r3
		return pxNewQueue;
	}
  402954:	4620      	mov	r0, r4
  402956:	bd70      	pop	{r4, r5, r6, pc}
  402958:	00402499 	.word	0x00402499
  40295c:	004021fd 	.word	0x004021fd
  402960:	004027d5 	.word	0x004027d5
  402964:	0040aaa8 	.word	0x0040aaa8
  402968:	004041a5 	.word	0x004041a5

0040296c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  40296c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402970:	460d      	mov	r5, r1
  402972:	4617      	mov	r7, r2
  402974:	4698      	mov	r8, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
  402976:	4604      	mov	r4, r0
  402978:	b920      	cbnz	r0, 402984 <xQueueGenericSendFromISR+0x18>
  40297a:	481d      	ldr	r0, [pc, #116]	; (4029f0 <xQueueGenericSendFromISR+0x84>)
  40297c:	f240 318f 	movw	r1, #911	; 0x38f
  402980:	4b1c      	ldr	r3, [pc, #112]	; (4029f4 <xQueueGenericSendFromISR+0x88>)
  402982:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402984:	b935      	cbnz	r5, 402994 <xQueueGenericSendFromISR+0x28>
  402986:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402988:	b123      	cbz	r3, 402994 <xQueueGenericSendFromISR+0x28>
  40298a:	4819      	ldr	r0, [pc, #100]	; (4029f0 <xQueueGenericSendFromISR+0x84>)
  40298c:	f44f 7164 	mov.w	r1, #912	; 0x390
  402990:	4b18      	ldr	r3, [pc, #96]	; (4029f4 <xQueueGenericSendFromISR+0x88>)
  402992:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  402994:	4b18      	ldr	r3, [pc, #96]	; (4029f8 <xQueueGenericSendFromISR+0x8c>)
  402996:	4798      	blx	r3
  402998:	4606      	mov	r6, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  40299a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  40299c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40299e:	429a      	cmp	r2, r3
  4029a0:	d218      	bcs.n	4029d4 <xQueueGenericSendFromISR+0x68>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4029a2:	4620      	mov	r0, r4
  4029a4:	4629      	mov	r1, r5
  4029a6:	4642      	mov	r2, r8
  4029a8:	4b14      	ldr	r3, [pc, #80]	; (4029fc <xQueueGenericSendFromISR+0x90>)
  4029aa:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  4029ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4029ae:	f1b3 3fff 	cmp.w	r3, #4294967295
  4029b2:	d10a      	bne.n	4029ca <xQueueGenericSendFromISR+0x5e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4029b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4029b6:	b17b      	cbz	r3, 4029d8 <xQueueGenericSendFromISR+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4029b8:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4029bc:	4b10      	ldr	r3, [pc, #64]	; (402a00 <xQueueGenericSendFromISR+0x94>)
  4029be:	4798      	blx	r3
  4029c0:	b160      	cbz	r0, 4029dc <xQueueGenericSendFromISR+0x70>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
  4029c2:	b16f      	cbz	r7, 4029e0 <xQueueGenericSendFromISR+0x74>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  4029c4:	2401      	movs	r4, #1
  4029c6:	603c      	str	r4, [r7, #0]
  4029c8:	e00b      	b.n	4029e2 <xQueueGenericSendFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  4029ca:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4029cc:	3301      	adds	r3, #1
  4029ce:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  4029d0:	2401      	movs	r4, #1
  4029d2:	e006      	b.n	4029e2 <xQueueGenericSendFromISR+0x76>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  4029d4:	2400      	movs	r4, #0
  4029d6:	e004      	b.n	4029e2 <xQueueGenericSendFromISR+0x76>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
  4029d8:	2401      	movs	r4, #1
  4029da:	e002      	b.n	4029e2 <xQueueGenericSendFromISR+0x76>
  4029dc:	2401      	movs	r4, #1
  4029de:	e000      	b.n	4029e2 <xQueueGenericSendFromISR+0x76>
  4029e0:	2401      	movs	r4, #1
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  4029e2:	4630      	mov	r0, r6
  4029e4:	4b07      	ldr	r3, [pc, #28]	; (402a04 <xQueueGenericSendFromISR+0x98>)
  4029e6:	4798      	blx	r3

	return xReturn;
}
  4029e8:	4620      	mov	r0, r4
  4029ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4029ee:	bf00      	nop
  4029f0:	0040aaa8 	.word	0x0040aaa8
  4029f4:	004041a5 	.word	0x004041a5
  4029f8:	00402315 	.word	0x00402315
  4029fc:	004025a5 	.word	0x004025a5
  402a00:	00403771 	.word	0x00403771
  402a04:	0040233d 	.word	0x0040233d

00402a08 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402a08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402a0c:	b085      	sub	sp, #20
  402a0e:	4689      	mov	r9, r1
  402a10:	9201      	str	r2, [sp, #4]
  402a12:	469a      	mov	sl, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;

	configASSERT( pxQueue );
  402a14:	4604      	mov	r4, r0
  402a16:	b920      	cbnz	r0, 402a22 <xQueueGenericReceive+0x1a>
  402a18:	4845      	ldr	r0, [pc, #276]	; (402b30 <xQueueGenericReceive+0x128>)
  402a1a:	f240 31cb 	movw	r1, #971	; 0x3cb
  402a1e:	4b45      	ldr	r3, [pc, #276]	; (402b34 <xQueueGenericReceive+0x12c>)
  402a20:	4798      	blx	r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
  402a22:	f1b9 0f00 	cmp.w	r9, #0
  402a26:	d106      	bne.n	402a36 <xQueueGenericReceive+0x2e>
  402a28:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402a2a:	b123      	cbz	r3, 402a36 <xQueueGenericReceive+0x2e>
  402a2c:	4840      	ldr	r0, [pc, #256]	; (402b30 <xQueueGenericReceive+0x128>)
  402a2e:	f44f 7173 	mov.w	r1, #972	; 0x3cc
  402a32:	4b40      	ldr	r3, [pc, #256]	; (402b34 <xQueueGenericReceive+0x12c>)
  402a34:	4798      	blx	r3
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  402a36:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  402a38:	4d3f      	ldr	r5, [pc, #252]	; (402b38 <xQueueGenericReceive+0x130>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402a3a:	f8df 812c 	ldr.w	r8, [pc, #300]	; 402b68 <xQueueGenericReceive+0x160>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  402a3e:	4e3f      	ldr	r6, [pc, #252]	; (402b3c <xQueueGenericReceive+0x134>)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  402a40:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  402a42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402a44:	b343      	cbz	r3, 402a98 <xQueueGenericReceive+0x90>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  402a46:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  402a48:	4620      	mov	r0, r4
  402a4a:	4649      	mov	r1, r9
  402a4c:	4b3c      	ldr	r3, [pc, #240]	; (402b40 <xQueueGenericReceive+0x138>)
  402a4e:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  402a50:	f1ba 0f00 	cmp.w	sl, #0
  402a54:	d112      	bne.n	402a7c <xQueueGenericReceive+0x74>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  402a56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402a58:	3b01      	subs	r3, #1
  402a5a:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  402a5c:	6823      	ldr	r3, [r4, #0]
  402a5e:	b913      	cbnz	r3, 402a66 <xQueueGenericReceive+0x5e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  402a60:	4b38      	ldr	r3, [pc, #224]	; (402b44 <xQueueGenericReceive+0x13c>)
  402a62:	4798      	blx	r3
  402a64:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  402a66:	6923      	ldr	r3, [r4, #16]
  402a68:	b193      	cbz	r3, 402a90 <xQueueGenericReceive+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  402a6a:	f104 0010 	add.w	r0, r4, #16
  402a6e:	4b36      	ldr	r3, [pc, #216]	; (402b48 <xQueueGenericReceive+0x140>)
  402a70:	4798      	blx	r3
  402a72:	2801      	cmp	r0, #1
  402a74:	d10c      	bne.n	402a90 <xQueueGenericReceive+0x88>
						{
							portYIELD_WITHIN_API();
  402a76:	4b35      	ldr	r3, [pc, #212]	; (402b4c <xQueueGenericReceive+0x144>)
  402a78:	4798      	blx	r3
  402a7a:	e009      	b.n	402a90 <xQueueGenericReceive+0x88>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  402a7c:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  402a7e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  402a80:	b133      	cbz	r3, 402a90 <xQueueGenericReceive+0x88>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  402a82:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402a86:	4b30      	ldr	r3, [pc, #192]	; (402b48 <xQueueGenericReceive+0x140>)
  402a88:	4798      	blx	r3
  402a8a:	b108      	cbz	r0, 402a90 <xQueueGenericReceive+0x88>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
  402a8c:	4b2f      	ldr	r3, [pc, #188]	; (402b4c <xQueueGenericReceive+0x144>)
  402a8e:	4798      	blx	r3
						}
					}
				}

				taskEXIT_CRITICAL();
  402a90:	4b2a      	ldr	r3, [pc, #168]	; (402b3c <xQueueGenericReceive+0x134>)
  402a92:	4798      	blx	r3
				return pdPASS;
  402a94:	2001      	movs	r0, #1
  402a96:	e048      	b.n	402b2a <xQueueGenericReceive+0x122>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  402a98:	9b01      	ldr	r3, [sp, #4]
  402a9a:	b91b      	cbnz	r3, 402aa4 <xQueueGenericReceive+0x9c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  402a9c:	4b27      	ldr	r3, [pc, #156]	; (402b3c <xQueueGenericReceive+0x134>)
  402a9e:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  402aa0:	2000      	movs	r0, #0
  402aa2:	e042      	b.n	402b2a <xQueueGenericReceive+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
  402aa4:	b917      	cbnz	r7, 402aac <xQueueGenericReceive+0xa4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  402aa6:	a802      	add	r0, sp, #8
  402aa8:	47c0      	blx	r8
					xEntryTimeSet = pdTRUE;
  402aaa:	2701      	movs	r7, #1
				}
			}
		}
		taskEXIT_CRITICAL();
  402aac:	47b0      	blx	r6

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  402aae:	4b28      	ldr	r3, [pc, #160]	; (402b50 <xQueueGenericReceive+0x148>)
  402ab0:	4798      	blx	r3
		prvLockQueue( pxQueue );
  402ab2:	47a8      	blx	r5
  402ab4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402ab6:	f1b3 3fff 	cmp.w	r3, #4294967295
  402aba:	bf04      	itt	eq
  402abc:	2300      	moveq	r3, #0
  402abe:	6463      	streq	r3, [r4, #68]	; 0x44
  402ac0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  402ac2:	f1b3 3fff 	cmp.w	r3, #4294967295
  402ac6:	bf04      	itt	eq
  402ac8:	2300      	moveq	r3, #0
  402aca:	64a3      	streq	r3, [r4, #72]	; 0x48
  402acc:	47b0      	blx	r6

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  402ace:	a802      	add	r0, sp, #8
  402ad0:	a901      	add	r1, sp, #4
  402ad2:	4b20      	ldr	r3, [pc, #128]	; (402b54 <xQueueGenericReceive+0x14c>)
  402ad4:	4798      	blx	r3
  402ad6:	bb10      	cbnz	r0, 402b1e <xQueueGenericReceive+0x116>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  402ad8:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  402ada:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  402ade:	47b0      	blx	r6
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  402ae0:	f1bb 0f00 	cmp.w	fp, #0
  402ae4:	d115      	bne.n	402b12 <xQueueGenericReceive+0x10a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  402ae6:	6823      	ldr	r3, [r4, #0]
  402ae8:	b923      	cbnz	r3, 402af4 <xQueueGenericReceive+0xec>
					{
						portENTER_CRITICAL();
  402aea:	47a8      	blx	r5
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  402aec:	6860      	ldr	r0, [r4, #4]
  402aee:	4b1a      	ldr	r3, [pc, #104]	; (402b58 <xQueueGenericReceive+0x150>)
  402af0:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  402af2:	47b0      	blx	r6
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402af4:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402af8:	9901      	ldr	r1, [sp, #4]
  402afa:	4b18      	ldr	r3, [pc, #96]	; (402b5c <xQueueGenericReceive+0x154>)
  402afc:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  402afe:	4620      	mov	r0, r4
  402b00:	4b17      	ldr	r3, [pc, #92]	; (402b60 <xQueueGenericReceive+0x158>)
  402b02:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
  402b04:	4b17      	ldr	r3, [pc, #92]	; (402b64 <xQueueGenericReceive+0x15c>)
  402b06:	4798      	blx	r3
  402b08:	2800      	cmp	r0, #0
  402b0a:	d199      	bne.n	402a40 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
  402b0c:	4b0f      	ldr	r3, [pc, #60]	; (402b4c <xQueueGenericReceive+0x144>)
  402b0e:	4798      	blx	r3
  402b10:	e796      	b.n	402a40 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  402b12:	4620      	mov	r0, r4
  402b14:	4b12      	ldr	r3, [pc, #72]	; (402b60 <xQueueGenericReceive+0x158>)
  402b16:	4798      	blx	r3
				( void ) xTaskResumeAll();
  402b18:	4b12      	ldr	r3, [pc, #72]	; (402b64 <xQueueGenericReceive+0x15c>)
  402b1a:	4798      	blx	r3
  402b1c:	e790      	b.n	402a40 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  402b1e:	4620      	mov	r0, r4
  402b20:	4b0f      	ldr	r3, [pc, #60]	; (402b60 <xQueueGenericReceive+0x158>)
  402b22:	4798      	blx	r3
			( void ) xTaskResumeAll();
  402b24:	4b0f      	ldr	r3, [pc, #60]	; (402b64 <xQueueGenericReceive+0x15c>)
  402b26:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  402b28:	2000      	movs	r0, #0
		}
	}
}
  402b2a:	b005      	add	sp, #20
  402b2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402b30:	0040aaa8 	.word	0x0040aaa8
  402b34:	004041a5 	.word	0x004041a5
  402b38:	00402325 	.word	0x00402325
  402b3c:	00402345 	.word	0x00402345
  402b40:	00402609 	.word	0x00402609
  402b44:	004038c1 	.word	0x004038c1
  402b48:	00403771 	.word	0x00403771
  402b4c:	00402305 	.word	0x00402305
  402b50:	00403075 	.word	0x00403075
  402b54:	00403829 	.word	0x00403829
  402b58:	004038ed 	.word	0x004038ed
  402b5c:	00403685 	.word	0x00403685
  402b60:	00402631 	.word	0x00402631
  402b64:	004031f1 	.word	0x004031f1
  402b68:	004037f9 	.word	0x004037f9

00402b6c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  402b6c:	b538      	push	{r3, r4, r5, lr}
  402b6e:	4604      	mov	r4, r0
  402b70:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  402b72:	4b0d      	ldr	r3, [pc, #52]	; (402ba8 <vQueueWaitForMessageRestricted+0x3c>)
  402b74:	4798      	blx	r3
  402b76:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402b78:	f1b3 3fff 	cmp.w	r3, #4294967295
  402b7c:	bf04      	itt	eq
  402b7e:	2300      	moveq	r3, #0
  402b80:	6463      	streq	r3, [r4, #68]	; 0x44
  402b82:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  402b84:	f1b3 3fff 	cmp.w	r3, #4294967295
  402b88:	bf04      	itt	eq
  402b8a:	2300      	moveq	r3, #0
  402b8c:	64a3      	streq	r3, [r4, #72]	; 0x48
  402b8e:	4b07      	ldr	r3, [pc, #28]	; (402bac <vQueueWaitForMessageRestricted+0x40>)
  402b90:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  402b92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402b94:	b923      	cbnz	r3, 402ba0 <vQueueWaitForMessageRestricted+0x34>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  402b96:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402b9a:	4629      	mov	r1, r5
  402b9c:	4b04      	ldr	r3, [pc, #16]	; (402bb0 <vQueueWaitForMessageRestricted+0x44>)
  402b9e:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  402ba0:	4620      	mov	r0, r4
  402ba2:	4b04      	ldr	r3, [pc, #16]	; (402bb4 <vQueueWaitForMessageRestricted+0x48>)
  402ba4:	4798      	blx	r3
  402ba6:	bd38      	pop	{r3, r4, r5, pc}
  402ba8:	00402325 	.word	0x00402325
  402bac:	00402345 	.word	0x00402345
  402bb0:	00403709 	.word	0x00403709
  402bb4:	00402631 	.word	0x00402631

00402bb8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  402bb8:	b510      	push	{r4, lr}
  402bba:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  402bbc:	4b0e      	ldr	r3, [pc, #56]	; (402bf8 <prvAddCurrentTaskToDelayedList+0x40>)
  402bbe:	681b      	ldr	r3, [r3, #0]
  402bc0:	6058      	str	r0, [r3, #4]

	if( xTimeToWake < xTickCount )
  402bc2:	4b0e      	ldr	r3, [pc, #56]	; (402bfc <prvAddCurrentTaskToDelayedList+0x44>)
  402bc4:	681b      	ldr	r3, [r3, #0]
  402bc6:	4298      	cmp	r0, r3
  402bc8:	d207      	bcs.n	402bda <prvAddCurrentTaskToDelayedList+0x22>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  402bca:	4b0d      	ldr	r3, [pc, #52]	; (402c00 <prvAddCurrentTaskToDelayedList+0x48>)
  402bcc:	6818      	ldr	r0, [r3, #0]
  402bce:	4b0a      	ldr	r3, [pc, #40]	; (402bf8 <prvAddCurrentTaskToDelayedList+0x40>)
  402bd0:	6819      	ldr	r1, [r3, #0]
  402bd2:	3104      	adds	r1, #4
  402bd4:	4b0b      	ldr	r3, [pc, #44]	; (402c04 <prvAddCurrentTaskToDelayedList+0x4c>)
  402bd6:	4798      	blx	r3
  402bd8:	bd10      	pop	{r4, pc}
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  402bda:	4b0b      	ldr	r3, [pc, #44]	; (402c08 <prvAddCurrentTaskToDelayedList+0x50>)
  402bdc:	6818      	ldr	r0, [r3, #0]
  402bde:	4b06      	ldr	r3, [pc, #24]	; (402bf8 <prvAddCurrentTaskToDelayedList+0x40>)
  402be0:	6819      	ldr	r1, [r3, #0]
  402be2:	3104      	adds	r1, #4
  402be4:	4b07      	ldr	r3, [pc, #28]	; (402c04 <prvAddCurrentTaskToDelayedList+0x4c>)
  402be6:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  402be8:	4b08      	ldr	r3, [pc, #32]	; (402c0c <prvAddCurrentTaskToDelayedList+0x54>)
  402bea:	681b      	ldr	r3, [r3, #0]
  402bec:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
  402bee:	bf3c      	itt	cc
  402bf0:	4b06      	ldrcc	r3, [pc, #24]	; (402c0c <prvAddCurrentTaskToDelayedList+0x54>)
  402bf2:	601c      	strcc	r4, [r3, #0]
  402bf4:	bd10      	pop	{r4, pc}
  402bf6:	bf00      	nop
  402bf8:	200050a4 	.word	0x200050a4
  402bfc:	20004ffc 	.word	0x20004ffc
  402c00:	20005064 	.word	0x20005064
  402c04:	00402239 	.word	0x00402239
  402c08:	2000507c 	.word	0x2000507c
  402c0c:	200001f0 	.word	0x200001f0

00402c10 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
  402c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402c14:	b087      	sub	sp, #28
  402c16:	9005      	str	r0, [sp, #20]
  402c18:	460d      	mov	r5, r1
  402c1a:	4693      	mov	fp, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;
	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  402c1c:	684b      	ldr	r3, [r1, #4]
  402c1e:	685b      	ldr	r3, [r3, #4]
  402c20:	604b      	str	r3, [r1, #4]
  402c22:	f101 0708 	add.w	r7, r1, #8
  402c26:	42bb      	cmp	r3, r7
  402c28:	bf04      	itt	eq
  402c2a:	685b      	ldreq	r3, [r3, #4]
  402c2c:	604b      	streq	r3, [r1, #4]
  402c2e:	684b      	ldr	r3, [r1, #4]
  402c30:	f8d3 900c 	ldr.w	r9, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
  402c34:	4e17      	ldr	r6, [pc, #92]	; (402c94 <prvListTaskWithinSingleList+0x84>)
  402c36:	f8df a064 	ldr.w	sl, [pc, #100]	; 402c9c <prvListTaskWithinSingleList+0x8c>
  402c3a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 402ca0 <prvListTaskWithinSingleList+0x90>

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  402c3e:	686b      	ldr	r3, [r5, #4]
  402c40:	685b      	ldr	r3, [r3, #4]
  402c42:	606b      	str	r3, [r5, #4]
  402c44:	429f      	cmp	r7, r3
  402c46:	bf04      	itt	eq
  402c48:	68eb      	ldreq	r3, [r5, #12]
  402c4a:	606b      	streq	r3, [r5, #4]
  402c4c:	686b      	ldr	r3, [r5, #4]
  402c4e:	68dc      	ldr	r4, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
  402c50:	6b22      	ldr	r2, [r4, #48]	; 0x30

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  402c52:	7813      	ldrb	r3, [r2, #0]
  402c54:	2ba5      	cmp	r3, #165	; 0xa5
  402c56:	d107      	bne.n	402c68 <prvListTaskWithinSingleList+0x58>
  402c58:	2300      	movs	r3, #0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  402c5a:	3301      	adds	r3, #1
  402c5c:	b29b      	uxth	r3, r3

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  402c5e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  402c62:	29a5      	cmp	r1, #165	; 0xa5
  402c64:	d0f9      	beq.n	402c5a <prvListTaskWithinSingleList+0x4a>
  402c66:	e000      	b.n	402c6a <prvListTaskWithinSingleList+0x5a>

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
  402c68:	2300      	movs	r3, #0
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
  402c6a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  402c6c:	6c22      	ldr	r2, [r4, #64]	; 0x40
  402c6e:	9100      	str	r1, [sp, #0]
  402c70:	089b      	lsrs	r3, r3, #2
  402c72:	9301      	str	r3, [sp, #4]
  402c74:	9202      	str	r2, [sp, #8]
  402c76:	4630      	mov	r0, r6
  402c78:	4651      	mov	r1, sl
  402c7a:	f104 0234 	add.w	r2, r4, #52	; 0x34
  402c7e:	465b      	mov	r3, fp
  402c80:	47c0      	blx	r8
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
  402c82:	9805      	ldr	r0, [sp, #20]
  402c84:	4631      	mov	r1, r6
  402c86:	4b04      	ldr	r3, [pc, #16]	; (402c98 <prvListTaskWithinSingleList+0x88>)
  402c88:	4798      	blx	r3

		} while( pxNextTCB != pxFirstTCB );
  402c8a:	454c      	cmp	r4, r9
  402c8c:	d1d7      	bne.n	402c3e <prvListTaskWithinSingleList+0x2e>
	}
  402c8e:	b007      	add	sp, #28
  402c90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402c94:	2000511c 	.word	0x2000511c
  402c98:	00404709 	.word	0x00404709
  402c9c:	0040aafc 	.word	0x0040aafc
  402ca0:	004046bd 	.word	0x004046bd

00402ca4 <prvGenerateRunTimeStatsForTasksInList>:
/*-----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
	{
  402ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402ca8:	b083      	sub	sp, #12
  402caa:	4683      	mov	fp, r0
  402cac:	460c      	mov	r4, r1
  402cae:	4616      	mov	r6, r2
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned long ulStatsAsPercentage;

		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  402cb0:	684b      	ldr	r3, [r1, #4]
  402cb2:	685b      	ldr	r3, [r3, #4]
  402cb4:	604b      	str	r3, [r1, #4]
  402cb6:	f101 0708 	add.w	r7, r1, #8
  402cba:	42bb      	cmp	r3, r7
  402cbc:	bf04      	itt	eq
  402cbe:	685b      	ldreq	r3, [r3, #4]
  402cc0:	604b      	streq	r3, [r1, #4]
  402cc2:	684b      	ldr	r3, [r1, #4]
  402cc4:	f8d3 800c 	ldr.w	r8, [r3, #12]
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
  402cc8:	f8df 9078 	ldr.w	r9, [pc, #120]	; 402d44 <prvGenerateRunTimeStatsForTasksInList+0xa0>
  402ccc:	f8df a078 	ldr.w	sl, [pc, #120]	; 402d48 <prvGenerateRunTimeStatsForTasksInList+0xa4>
		/* Write the run time stats of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			/* Get next TCB in from the list. */
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  402cd0:	6863      	ldr	r3, [r4, #4]
  402cd2:	685b      	ldr	r3, [r3, #4]
  402cd4:	6063      	str	r3, [r4, #4]
  402cd6:	429f      	cmp	r7, r3
  402cd8:	bf04      	itt	eq
  402cda:	68e3      	ldreq	r3, [r4, #12]
  402cdc:	6063      	streq	r3, [r4, #4]
  402cde:	6863      	ldr	r3, [r4, #4]
  402ce0:	68dd      	ldr	r5, [r3, #12]

			/* Divide by zero check. */
			if( ulTotalRunTime > 0UL )
  402ce2:	b30e      	cbz	r6, 402d28 <prvGenerateRunTimeStatsForTasksInList+0x84>
			{
				/* Has the task run at all? */
				if( pxNextTCB->ulRunTimeCounter == 0UL )
  402ce4:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402ce6:	b933      	cbnz	r3, 402cf6 <prvGenerateRunTimeStatsForTasksInList+0x52>
				{
					/* The task has used no CPU time at all. */
					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
  402ce8:	4648      	mov	r0, r9
  402cea:	4912      	ldr	r1, [pc, #72]	; (402d34 <prvGenerateRunTimeStatsForTasksInList+0x90>)
  402cec:	f105 0234 	add.w	r2, r5, #52	; 0x34
  402cf0:	4b11      	ldr	r3, [pc, #68]	; (402d38 <prvGenerateRunTimeStatsForTasksInList+0x94>)
  402cf2:	4798      	blx	r3
  402cf4:	e015      	b.n	402d22 <prvGenerateRunTimeStatsForTasksInList+0x7e>
				else
				{
					/* What percentage of the total run time has the task used?
					This will always be rounded down to the nearest integer.
					ulTotalRunTime has already been divided by 100. */
					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
  402cf6:	6cea      	ldr	r2, [r5, #76]	; 0x4c
  402cf8:	fbb2 f2f6 	udiv	r2, r2, r6

					if( ulStatsAsPercentage > 0UL )
  402cfc:	b14a      	cbz	r2, 402d12 <prvGenerateRunTimeStatsForTasksInList+0x6e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
  402cfe:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402d00:	9200      	str	r2, [sp, #0]
  402d02:	4648      	mov	r0, r9
  402d04:	490d      	ldr	r1, [pc, #52]	; (402d3c <prvGenerateRunTimeStatsForTasksInList+0x98>)
  402d06:	f105 0234 	add.w	r2, r5, #52	; 0x34
  402d0a:	f8df c02c 	ldr.w	ip, [pc, #44]	; 402d38 <prvGenerateRunTimeStatsForTasksInList+0x94>
  402d0e:	47e0      	blx	ip
  402d10:	e007      	b.n	402d22 <prvGenerateRunTimeStatsForTasksInList+0x7e>
						}
						#else
						{
							/* sizeof( int ) == sizeof( long ) so a smaller
							printf() library can be used. */
							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
  402d12:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  402d14:	4648      	mov	r0, r9
  402d16:	490a      	ldr	r1, [pc, #40]	; (402d40 <prvGenerateRunTimeStatsForTasksInList+0x9c>)
  402d18:	f105 0234 	add.w	r2, r5, #52	; 0x34
  402d1c:	f8df c018 	ldr.w	ip, [pc, #24]	; 402d38 <prvGenerateRunTimeStatsForTasksInList+0x94>
  402d20:	47e0      	blx	ip
						}
						#endif
					}
				}

				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
  402d22:	4658      	mov	r0, fp
  402d24:	4649      	mov	r1, r9
  402d26:	47d0      	blx	sl
			}

		} while( pxNextTCB != pxFirstTCB );
  402d28:	4545      	cmp	r5, r8
  402d2a:	d1d1      	bne.n	402cd0 <prvGenerateRunTimeStatsForTasksInList+0x2c>
	}
  402d2c:	b003      	add	sp, #12
  402d2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402d32:	bf00      	nop
  402d34:	0040ab10 	.word	0x0040ab10
  402d38:	004046bd 	.word	0x004046bd
  402d3c:	0040ab20 	.word	0x0040ab20
  402d40:	0040ab30 	.word	0x0040ab30
  402d44:	200050a8 	.word	0x200050a8
  402d48:	00404709 	.word	0x00404709

00402d4c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  402d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d50:	b083      	sub	sp, #12
  402d52:	4688      	mov	r8, r1
  402d54:	4615      	mov	r5, r2
  402d56:	9301      	str	r3, [sp, #4]
  402d58:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  402d5a:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  402d5e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
  402d60:	9000      	str	r0, [sp, #0]
  402d62:	b920      	cbnz	r0, 402d6e <xTaskGenericCreate+0x22>
  402d64:	485f      	ldr	r0, [pc, #380]	; (402ee4 <xTaskGenericCreate+0x198>)
  402d66:	f240 11eb 	movw	r1, #491	; 0x1eb
  402d6a:	4b5f      	ldr	r3, [pc, #380]	; (402ee8 <xTaskGenericCreate+0x19c>)
  402d6c:	4798      	blx	r3
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
  402d6e:	2f04      	cmp	r7, #4
  402d70:	d904      	bls.n	402d7c <xTaskGenericCreate+0x30>
  402d72:	485c      	ldr	r0, [pc, #368]	; (402ee4 <xTaskGenericCreate+0x198>)
  402d74:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
  402d78:	4b5b      	ldr	r3, [pc, #364]	; (402ee8 <xTaskGenericCreate+0x19c>)
  402d7a:	4798      	blx	r3
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  402d7c:	2050      	movs	r0, #80	; 0x50
  402d7e:	4b5b      	ldr	r3, [pc, #364]	; (402eec <xTaskGenericCreate+0x1a0>)
  402d80:	4798      	blx	r3

	if( pxNewTCB != NULL )
  402d82:	4604      	mov	r4, r0
  402d84:	2800      	cmp	r0, #0
  402d86:	f000 80a7 	beq.w	402ed8 <xTaskGenericCreate+0x18c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  402d8a:	2e00      	cmp	r6, #0
  402d8c:	f040 80a1 	bne.w	402ed2 <xTaskGenericCreate+0x186>
  402d90:	00a8      	lsls	r0, r5, #2
  402d92:	4b56      	ldr	r3, [pc, #344]	; (402eec <xTaskGenericCreate+0x1a0>)
  402d94:	4798      	blx	r3
  402d96:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  402d98:	b918      	cbnz	r0, 402da2 <xTaskGenericCreate+0x56>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  402d9a:	4620      	mov	r0, r4
  402d9c:	4b54      	ldr	r3, [pc, #336]	; (402ef0 <xTaskGenericCreate+0x1a4>)
  402d9e:	4798      	blx	r3
  402da0:	e09a      	b.n	402ed8 <xTaskGenericCreate+0x18c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
  402da2:	21a5      	movs	r1, #165	; 0xa5
  402da4:	00aa      	lsls	r2, r5, #2
  402da6:	4b53      	ldr	r3, [pc, #332]	; (402ef4 <xTaskGenericCreate+0x1a8>)
  402da8:	4798      	blx	r3
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  402daa:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
  402dae:	3d01      	subs	r5, #1
  402db0:	6b23      	ldr	r3, [r4, #48]	; 0x30
  402db2:	eb03 0585 	add.w	r5, r3, r5, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
  402db6:	f025 0507 	bic.w	r5, r5, #7
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  402dba:	f104 0034 	add.w	r0, r4, #52	; 0x34
  402dbe:	4641      	mov	r1, r8
  402dc0:	220a      	movs	r2, #10
  402dc2:	4b4d      	ldr	r3, [pc, #308]	; (402ef8 <xTaskGenericCreate+0x1ac>)
  402dc4:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  402dc6:	f04f 0a00 	mov.w	sl, #0
  402dca:	f884 a03d 	strb.w	sl, [r4, #61]	; 0x3d
  402dce:	463e      	mov	r6, r7
  402dd0:	2f04      	cmp	r7, #4
  402dd2:	bf28      	it	cs
  402dd4:	2604      	movcs	r6, #4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
  402dd6:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  402dd8:	64a6      	str	r6, [r4, #72]	; 0x48
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  402dda:	f104 0804 	add.w	r8, r4, #4
  402dde:	4640      	mov	r0, r8
  402de0:	f8df b164 	ldr.w	fp, [pc, #356]	; 402f48 <xTaskGenericCreate+0x1fc>
  402de4:	47d8      	blx	fp
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  402de6:	f104 0018 	add.w	r0, r4, #24
  402dea:	47d8      	blx	fp

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  402dec:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  402dee:	f1c6 0605 	rsb	r6, r6, #5
  402df2:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  402df4:	6264      	str	r4, [r4, #36]	; 0x24
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
  402df6:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  402dfa:	4628      	mov	r0, r5
  402dfc:	9900      	ldr	r1, [sp, #0]
  402dfe:	9a01      	ldr	r2, [sp, #4]
  402e00:	4b3e      	ldr	r3, [pc, #248]	; (402efc <xTaskGenericCreate+0x1b0>)
  402e02:	4798      	blx	r3
  402e04:	6020      	str	r0, [r4, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
  402e06:	f1b9 0f00 	cmp.w	r9, #0
  402e0a:	d001      	beq.n	402e10 <xTaskGenericCreate+0xc4>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  402e0c:	f8c9 4000 	str.w	r4, [r9]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
  402e10:	4b3b      	ldr	r3, [pc, #236]	; (402f00 <xTaskGenericCreate+0x1b4>)
  402e12:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
  402e14:	4a3b      	ldr	r2, [pc, #236]	; (402f04 <xTaskGenericCreate+0x1b8>)
  402e16:	6813      	ldr	r3, [r2, #0]
  402e18:	3301      	adds	r3, #1
  402e1a:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
  402e1c:	4b3a      	ldr	r3, [pc, #232]	; (402f08 <xTaskGenericCreate+0x1bc>)
  402e1e:	681b      	ldr	r3, [r3, #0]
  402e20:	bb0b      	cbnz	r3, 402e66 <xTaskGenericCreate+0x11a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  402e22:	4b39      	ldr	r3, [pc, #228]	; (402f08 <xTaskGenericCreate+0x1bc>)
  402e24:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  402e26:	6813      	ldr	r3, [r2, #0]
  402e28:	2b01      	cmp	r3, #1
  402e2a:	d126      	bne.n	402e7a <xTaskGenericCreate+0x12e>
  402e2c:	4d37      	ldr	r5, [pc, #220]	; (402f0c <xTaskGenericCreate+0x1c0>)
  402e2e:	f105 0964 	add.w	r9, r5, #100	; 0x64
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  402e32:	4e37      	ldr	r6, [pc, #220]	; (402f10 <xTaskGenericCreate+0x1c4>)
  402e34:	4628      	mov	r0, r5
  402e36:	47b0      	blx	r6
  402e38:	3514      	adds	r5, #20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  402e3a:	454d      	cmp	r5, r9
  402e3c:	d1fa      	bne.n	402e34 <xTaskGenericCreate+0xe8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  402e3e:	f8df 910c 	ldr.w	r9, [pc, #268]	; 402f4c <xTaskGenericCreate+0x200>
  402e42:	4648      	mov	r0, r9
  402e44:	4d32      	ldr	r5, [pc, #200]	; (402f10 <xTaskGenericCreate+0x1c4>)
  402e46:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  402e48:	4e32      	ldr	r6, [pc, #200]	; (402f14 <xTaskGenericCreate+0x1c8>)
  402e4a:	4630      	mov	r0, r6
  402e4c:	47a8      	blx	r5
	vListInitialise( ( xList * ) &xPendingReadyList );
  402e4e:	4832      	ldr	r0, [pc, #200]	; (402f18 <xTaskGenericCreate+0x1cc>)
  402e50:	47a8      	blx	r5

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  402e52:	4832      	ldr	r0, [pc, #200]	; (402f1c <xTaskGenericCreate+0x1d0>)
  402e54:	47a8      	blx	r5
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  402e56:	4832      	ldr	r0, [pc, #200]	; (402f20 <xTaskGenericCreate+0x1d4>)
  402e58:	47a8      	blx	r5
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  402e5a:	4b32      	ldr	r3, [pc, #200]	; (402f24 <xTaskGenericCreate+0x1d8>)
  402e5c:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  402e60:	4b31      	ldr	r3, [pc, #196]	; (402f28 <xTaskGenericCreate+0x1dc>)
  402e62:	601e      	str	r6, [r3, #0]
  402e64:	e009      	b.n	402e7a <xTaskGenericCreate+0x12e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  402e66:	4b31      	ldr	r3, [pc, #196]	; (402f2c <xTaskGenericCreate+0x1e0>)
  402e68:	681b      	ldr	r3, [r3, #0]
  402e6a:	b933      	cbnz	r3, 402e7a <xTaskGenericCreate+0x12e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  402e6c:	4b26      	ldr	r3, [pc, #152]	; (402f08 <xTaskGenericCreate+0x1bc>)
  402e6e:	681b      	ldr	r3, [r3, #0]
  402e70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402e72:	429f      	cmp	r7, r3
					{
						pxCurrentTCB = pxNewTCB;
  402e74:	bf24      	itt	cs
  402e76:	4b24      	ldrcs	r3, [pc, #144]	; (402f08 <xTaskGenericCreate+0x1bc>)
  402e78:	601c      	strcs	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  402e7a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402e7c:	4b2c      	ldr	r3, [pc, #176]	; (402f30 <xTaskGenericCreate+0x1e4>)
  402e7e:	681b      	ldr	r3, [r3, #0]
  402e80:	4298      	cmp	r0, r3
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
  402e82:	bf84      	itt	hi
  402e84:	4b2a      	ldrhi	r3, [pc, #168]	; (402f30 <xTaskGenericCreate+0x1e4>)
  402e86:	6018      	strhi	r0, [r3, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  402e88:	4a2a      	ldr	r2, [pc, #168]	; (402f34 <xTaskGenericCreate+0x1e8>)
  402e8a:	6813      	ldr	r3, [r2, #0]
  402e8c:	6423      	str	r3, [r4, #64]	; 0x40
			}
			#endif
			uxTaskNumber++;
  402e8e:	3301      	adds	r3, #1
  402e90:	6013      	str	r3, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
  402e92:	4929      	ldr	r1, [pc, #164]	; (402f38 <xTaskGenericCreate+0x1ec>)
  402e94:	680a      	ldr	r2, [r1, #0]
  402e96:	2301      	movs	r3, #1
  402e98:	4083      	lsls	r3, r0
  402e9a:	4313      	orrs	r3, r2
  402e9c:	600b      	str	r3, [r1, #0]
  402e9e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402ea2:	4b1a      	ldr	r3, [pc, #104]	; (402f0c <xTaskGenericCreate+0x1c0>)
  402ea4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402ea8:	4641      	mov	r1, r8
  402eaa:	4b24      	ldr	r3, [pc, #144]	; (402f3c <xTaskGenericCreate+0x1f0>)
  402eac:	4798      	blx	r3

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  402eae:	4b24      	ldr	r3, [pc, #144]	; (402f40 <xTaskGenericCreate+0x1f4>)
  402eb0:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
  402eb2:	4b1e      	ldr	r3, [pc, #120]	; (402f2c <xTaskGenericCreate+0x1e0>)
  402eb4:	681b      	ldr	r3, [r3, #0]
  402eb6:	b143      	cbz	r3, 402eca <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  402eb8:	4b13      	ldr	r3, [pc, #76]	; (402f08 <xTaskGenericCreate+0x1bc>)
  402eba:	681b      	ldr	r3, [r3, #0]
  402ebc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402ebe:	429f      	cmp	r7, r3
  402ec0:	d905      	bls.n	402ece <xTaskGenericCreate+0x182>
			{
				portYIELD_WITHIN_API();
  402ec2:	4b20      	ldr	r3, [pc, #128]	; (402f44 <xTaskGenericCreate+0x1f8>)
  402ec4:	4798      	blx	r3
  402ec6:	2001      	movs	r0, #1
  402ec8:	e008      	b.n	402edc <xTaskGenericCreate+0x190>
  402eca:	2001      	movs	r0, #1
  402ecc:	e006      	b.n	402edc <xTaskGenericCreate+0x190>
  402ece:	2001      	movs	r0, #1
  402ed0:	e004      	b.n	402edc <xTaskGenericCreate+0x190>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  402ed2:	6306      	str	r6, [r0, #48]	; 0x30
  402ed4:	4630      	mov	r0, r6
  402ed6:	e764      	b.n	402da2 <xTaskGenericCreate+0x56>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  402ed8:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
  402edc:	b003      	add	sp, #12
  402ede:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402ee2:	bf00      	nop
  402ee4:	0040ab40 	.word	0x0040ab40
  402ee8:	004041a5 	.word	0x004041a5
  402eec:	00402499 	.word	0x00402499
  402ef0:	0040256d 	.word	0x0040256d
  402ef4:	00404621 	.word	0x00404621
  402ef8:	00404c49 	.word	0x00404c49
  402efc:	004022c5 	.word	0x004022c5
  402f00:	00402325 	.word	0x00402325
  402f04:	200050f0 	.word	0x200050f0
  402f08:	200050a4 	.word	0x200050a4
  402f0c:	20005000 	.word	0x20005000
  402f10:	004021fd 	.word	0x004021fd
  402f14:	20005108 	.word	0x20005108
  402f18:	20005080 	.word	0x20005080
  402f1c:	20005068 	.word	0x20005068
  402f20:	200050dc 	.word	0x200050dc
  402f24:	2000507c 	.word	0x2000507c
  402f28:	20005064 	.word	0x20005064
  402f2c:	20005094 	.word	0x20005094
  402f30:	20005150 	.word	0x20005150
  402f34:	200050a0 	.word	0x200050a0
  402f38:	20004ff4 	.word	0x20004ff4
  402f3c:	0040221d 	.word	0x0040221d
  402f40:	00402345 	.word	0x00402345
  402f44:	00402305 	.word	0x00402305
  402f48:	00402215 	.word	0x00402215
  402f4c:	200050f4 	.word	0x200050f4

00402f50 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
  402f50:	b570      	push	{r4, r5, r6, lr}
  402f52:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  402f54:	4b1c      	ldr	r3, [pc, #112]	; (402fc8 <vTaskDelete+0x78>)
  402f56:	4798      	blx	r3
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
  402f58:	4b1c      	ldr	r3, [pc, #112]	; (402fcc <vTaskDelete+0x7c>)
  402f5a:	681b      	ldr	r3, [r3, #0]
  402f5c:	429c      	cmp	r4, r3
  402f5e:	d001      	beq.n	402f64 <vTaskDelete+0x14>
  402f60:	4625      	mov	r5, r4
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  402f62:	b91c      	cbnz	r4, 402f6c <vTaskDelete+0x1c>
  402f64:	4b19      	ldr	r3, [pc, #100]	; (402fcc <vTaskDelete+0x7c>)
  402f66:	681c      	ldr	r4, [r3, #0]
  402f68:	2500      	movs	r5, #0
  402f6a:	e7ff      	b.n	402f6c <vTaskDelete+0x1c>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  402f6c:	1d26      	adds	r6, r4, #4
  402f6e:	4630      	mov	r0, r6
  402f70:	4b17      	ldr	r3, [pc, #92]	; (402fd0 <vTaskDelete+0x80>)
  402f72:	4798      	blx	r3
  402f74:	b968      	cbnz	r0, 402f92 <vTaskDelete+0x42>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  402f76:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402f78:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  402f7c:	009b      	lsls	r3, r3, #2
  402f7e:	4915      	ldr	r1, [pc, #84]	; (402fd4 <vTaskDelete+0x84>)
  402f80:	58cb      	ldr	r3, [r1, r3]
  402f82:	b933      	cbnz	r3, 402f92 <vTaskDelete+0x42>
  402f84:	4814      	ldr	r0, [pc, #80]	; (402fd8 <vTaskDelete+0x88>)
  402f86:	6801      	ldr	r1, [r0, #0]
  402f88:	2301      	movs	r3, #1
  402f8a:	4093      	lsls	r3, r2
  402f8c:	ea21 0303 	bic.w	r3, r1, r3
  402f90:	6003      	str	r3, [r0, #0]
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
  402f92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402f94:	b11b      	cbz	r3, 402f9e <vTaskDelete+0x4e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
  402f96:	f104 0018 	add.w	r0, r4, #24
  402f9a:	4b0d      	ldr	r3, [pc, #52]	; (402fd0 <vTaskDelete+0x80>)
  402f9c:	4798      	blx	r3
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  402f9e:	480f      	ldr	r0, [pc, #60]	; (402fdc <vTaskDelete+0x8c>)
  402fa0:	4631      	mov	r1, r6
  402fa2:	4b0f      	ldr	r3, [pc, #60]	; (402fe0 <vTaskDelete+0x90>)
  402fa4:	4798      	blx	r3

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  402fa6:	4a0f      	ldr	r2, [pc, #60]	; (402fe4 <vTaskDelete+0x94>)
  402fa8:	6813      	ldr	r3, [r2, #0]
  402faa:	3301      	adds	r3, #1
  402fac:	6013      	str	r3, [r2, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  402fae:	4a0e      	ldr	r2, [pc, #56]	; (402fe8 <vTaskDelete+0x98>)
  402fb0:	6813      	ldr	r3, [r2, #0]
  402fb2:	3301      	adds	r3, #1
  402fb4:	6013      	str	r3, [r2, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  402fb6:	4b0d      	ldr	r3, [pc, #52]	; (402fec <vTaskDelete+0x9c>)
  402fb8:	4798      	blx	r3

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  402fba:	4b0d      	ldr	r3, [pc, #52]	; (402ff0 <vTaskDelete+0xa0>)
  402fbc:	681b      	ldr	r3, [r3, #0]
  402fbe:	b113      	cbz	r3, 402fc6 <vTaskDelete+0x76>
		{
			if( ( void * ) pxTaskToDelete == NULL )
  402fc0:	b90d      	cbnz	r5, 402fc6 <vTaskDelete+0x76>
			{
				portYIELD_WITHIN_API();
  402fc2:	4b0c      	ldr	r3, [pc, #48]	; (402ff4 <vTaskDelete+0xa4>)
  402fc4:	4798      	blx	r3
  402fc6:	bd70      	pop	{r4, r5, r6, pc}
  402fc8:	00402325 	.word	0x00402325
  402fcc:	200050a4 	.word	0x200050a4
  402fd0:	00402275 	.word	0x00402275
  402fd4:	20005000 	.word	0x20005000
  402fd8:	20004ff4 	.word	0x20004ff4
  402fdc:	20005068 	.word	0x20005068
  402fe0:	0040221d 	.word	0x0040221d
  402fe4:	20004ff8 	.word	0x20004ff8
  402fe8:	200050a0 	.word	0x200050a0
  402fec:	00402345 	.word	0x00402345
  402ff0:	20005094 	.word	0x20005094
  402ff4:	00402305 	.word	0x00402305

00402ff8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
  402ff8:	b510      	push	{r4, lr}
  402ffa:	b084      	sub	sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
  402ffc:	2300      	movs	r3, #0
  402ffe:	9300      	str	r3, [sp, #0]
  403000:	9301      	str	r3, [sp, #4]
  403002:	9302      	str	r3, [sp, #8]
  403004:	9303      	str	r3, [sp, #12]
  403006:	4810      	ldr	r0, [pc, #64]	; (403048 <vTaskStartScheduler+0x50>)
  403008:	4910      	ldr	r1, [pc, #64]	; (40304c <vTaskStartScheduler+0x54>)
  40300a:	22a0      	movs	r2, #160	; 0xa0
  40300c:	4c10      	ldr	r4, [pc, #64]	; (403050 <vTaskStartScheduler+0x58>)
  40300e:	47a0      	blx	r4
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  403010:	2801      	cmp	r0, #1
  403012:	d110      	bne.n	403036 <vTaskStartScheduler+0x3e>
		{
			xReturn = xTimerCreateTimerTask();
  403014:	4b0f      	ldr	r3, [pc, #60]	; (403054 <vTaskStartScheduler+0x5c>)
  403016:	4798      	blx	r3
		}
	}
	#endif

	if( xReturn == pdPASS )
  403018:	2801      	cmp	r0, #1
  40301a:	d10c      	bne.n	403036 <vTaskStartScheduler+0x3e>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  40301c:	4b0e      	ldr	r3, [pc, #56]	; (403058 <vTaskStartScheduler+0x60>)
  40301e:	4798      	blx	r3

		xSchedulerRunning = pdTRUE;
  403020:	2201      	movs	r2, #1
  403022:	4b0e      	ldr	r3, [pc, #56]	; (40305c <vTaskStartScheduler+0x64>)
  403024:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
  403026:	2200      	movs	r2, #0
  403028:	4b0d      	ldr	r3, [pc, #52]	; (403060 <vTaskStartScheduler+0x68>)
  40302a:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
  40302c:	4b0d      	ldr	r3, [pc, #52]	; (403064 <vTaskStartScheduler+0x6c>)
  40302e:	4798      	blx	r3

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  403030:	4b0d      	ldr	r3, [pc, #52]	; (403068 <vTaskStartScheduler+0x70>)
  403032:	4798      	blx	r3
  403034:	e005      	b.n	403042 <vTaskStartScheduler+0x4a>
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
  403036:	b920      	cbnz	r0, 403042 <vTaskStartScheduler+0x4a>
  403038:	480c      	ldr	r0, [pc, #48]	; (40306c <vTaskStartScheduler+0x74>)
  40303a:	f240 5113 	movw	r1, #1299	; 0x513
  40303e:	4b0c      	ldr	r3, [pc, #48]	; (403070 <vTaskStartScheduler+0x78>)
  403040:	4798      	blx	r3
}
  403042:	b004      	add	sp, #16
  403044:	bd10      	pop	{r4, pc}
  403046:	bf00      	nop
  403048:	00403361 	.word	0x00403361
  40304c:	0040ab80 	.word	0x0040ab80
  403050:	00402d4d 	.word	0x00402d4d
  403054:	00403aa1 	.word	0x00403aa1
  403058:	00402315 	.word	0x00402315
  40305c:	20005094 	.word	0x20005094
  403060:	20004ffc 	.word	0x20004ffc
  403064:	004043cd 	.word	0x004043cd
  403068:	004023f5 	.word	0x004023f5
  40306c:	0040ab40 	.word	0x0040ab40
  403070:	004041a5 	.word	0x004041a5

00403074 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  403074:	4a02      	ldr	r2, [pc, #8]	; (403080 <vTaskSuspendAll+0xc>)
  403076:	6813      	ldr	r3, [r2, #0]
  403078:	3301      	adds	r3, #1
  40307a:	6013      	str	r3, [r2, #0]
  40307c:	4770      	bx	lr
  40307e:	bf00      	nop
  403080:	20005144 	.word	0x20005144

00403084 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
  403084:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  403086:	4b04      	ldr	r3, [pc, #16]	; (403098 <xTaskGetTickCount+0x14>)
  403088:	4798      	blx	r3
	{
		xTicks = xTickCount;
  40308a:	4b04      	ldr	r3, [pc, #16]	; (40309c <xTaskGetTickCount+0x18>)
  40308c:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
  40308e:	4b04      	ldr	r3, [pc, #16]	; (4030a0 <xTaskGetTickCount+0x1c>)
  403090:	4798      	blx	r3

	return xTicks;
}
  403092:	4620      	mov	r0, r4
  403094:	bd10      	pop	{r4, pc}
  403096:	bf00      	nop
  403098:	00402325 	.word	0x00402325
  40309c:	20004ffc 	.word	0x20004ffc
  4030a0:	00402345 	.word	0x00402345

004030a4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
  4030a4:	b510      	push	{r4, lr}
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  4030a6:	4b04      	ldr	r3, [pc, #16]	; (4030b8 <xTaskGetTickCountFromISR+0x14>)
  4030a8:	4798      	blx	r3
	xReturn = xTickCount;
  4030aa:	4b04      	ldr	r3, [pc, #16]	; (4030bc <xTaskGetTickCountFromISR+0x18>)
  4030ac:	681c      	ldr	r4, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  4030ae:	4b04      	ldr	r3, [pc, #16]	; (4030c0 <xTaskGetTickCountFromISR+0x1c>)
  4030b0:	4798      	blx	r3

	return xReturn;
}
  4030b2:	4620      	mov	r0, r4
  4030b4:	bd10      	pop	{r4, pc}
  4030b6:	bf00      	nop
  4030b8:	00402315 	.word	0x00402315
  4030bc:	20004ffc 	.word	0x20004ffc
  4030c0:	0040233d 	.word	0x0040233d

004030c4 <vTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4030c4:	4b3d      	ldr	r3, [pc, #244]	; (4031bc <vTaskIncrementTick+0xf8>)
  4030c6:	681b      	ldr	r3, [r3, #0]
  4030c8:	2b00      	cmp	r3, #0
  4030ca:	d16f      	bne.n	4031ac <vTaskIncrementTick+0xe8>
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
  4030cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		++xTickCount;
  4030d0:	4b3b      	ldr	r3, [pc, #236]	; (4031c0 <vTaskIncrementTick+0xfc>)
  4030d2:	681a      	ldr	r2, [r3, #0]
  4030d4:	3201      	adds	r2, #1
  4030d6:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
  4030d8:	681b      	ldr	r3, [r3, #0]
  4030da:	bb0b      	cbnz	r3, 403120 <vTaskIncrementTick+0x5c>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  4030dc:	4b39      	ldr	r3, [pc, #228]	; (4031c4 <vTaskIncrementTick+0x100>)
  4030de:	681b      	ldr	r3, [r3, #0]
  4030e0:	681b      	ldr	r3, [r3, #0]
  4030e2:	b123      	cbz	r3, 4030ee <vTaskIncrementTick+0x2a>
  4030e4:	4838      	ldr	r0, [pc, #224]	; (4031c8 <vTaskIncrementTick+0x104>)
  4030e6:	f240 618c 	movw	r1, #1676	; 0x68c
  4030ea:	4b38      	ldr	r3, [pc, #224]	; (4031cc <vTaskIncrementTick+0x108>)
  4030ec:	4798      	blx	r3

			pxTemp = pxDelayedTaskList;
  4030ee:	4b35      	ldr	r3, [pc, #212]	; (4031c4 <vTaskIncrementTick+0x100>)
  4030f0:	6819      	ldr	r1, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  4030f2:	4a37      	ldr	r2, [pc, #220]	; (4031d0 <vTaskIncrementTick+0x10c>)
  4030f4:	6810      	ldr	r0, [r2, #0]
  4030f6:	6018      	str	r0, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  4030f8:	6011      	str	r1, [r2, #0]
			xNumOfOverflows++;
  4030fa:	4936      	ldr	r1, [pc, #216]	; (4031d4 <vTaskIncrementTick+0x110>)
  4030fc:	680a      	ldr	r2, [r1, #0]
  4030fe:	3201      	adds	r2, #1
  403100:	600a      	str	r2, [r1, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  403102:	681b      	ldr	r3, [r3, #0]
  403104:	681b      	ldr	r3, [r3, #0]
  403106:	b923      	cbnz	r3, 403112 <vTaskIncrementTick+0x4e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  403108:	f04f 32ff 	mov.w	r2, #4294967295
  40310c:	4b32      	ldr	r3, [pc, #200]	; (4031d8 <vTaskIncrementTick+0x114>)
  40310e:	601a      	str	r2, [r3, #0]
  403110:	e006      	b.n	403120 <vTaskIncrementTick+0x5c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  403112:	4b2c      	ldr	r3, [pc, #176]	; (4031c4 <vTaskIncrementTick+0x100>)
  403114:	681b      	ldr	r3, [r3, #0]
  403116:	68db      	ldr	r3, [r3, #12]
  403118:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40311a:	685a      	ldr	r2, [r3, #4]
  40311c:	4b2e      	ldr	r3, [pc, #184]	; (4031d8 <vTaskIncrementTick+0x114>)
  40311e:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  403120:	4b27      	ldr	r3, [pc, #156]	; (4031c0 <vTaskIncrementTick+0xfc>)
  403122:	681a      	ldr	r2, [r3, #0]
  403124:	4b2c      	ldr	r3, [pc, #176]	; (4031d8 <vTaskIncrementTick+0x114>)
  403126:	681b      	ldr	r3, [r3, #0]
  403128:	429a      	cmp	r2, r3
  40312a:	d344      	bcc.n	4031b6 <vTaskIncrementTick+0xf2>
  40312c:	4b25      	ldr	r3, [pc, #148]	; (4031c4 <vTaskIncrementTick+0x100>)
  40312e:	681b      	ldr	r3, [r3, #0]
  403130:	681b      	ldr	r3, [r3, #0]
  403132:	b16b      	cbz	r3, 403150 <vTaskIncrementTick+0x8c>
  403134:	4b23      	ldr	r3, [pc, #140]	; (4031c4 <vTaskIncrementTick+0x100>)
  403136:	681b      	ldr	r3, [r3, #0]
  403138:	68db      	ldr	r3, [r3, #12]
  40313a:	68dc      	ldr	r4, [r3, #12]
  40313c:	6863      	ldr	r3, [r4, #4]
  40313e:	4a20      	ldr	r2, [pc, #128]	; (4031c0 <vTaskIncrementTick+0xfc>)
  403140:	6812      	ldr	r2, [r2, #0]
  403142:	4293      	cmp	r3, r2
  403144:	d813      	bhi.n	40316e <vTaskIncrementTick+0xaa>
  403146:	4f25      	ldr	r7, [pc, #148]	; (4031dc <vTaskIncrementTick+0x118>)
  403148:	4e25      	ldr	r6, [pc, #148]	; (4031e0 <vTaskIncrementTick+0x11c>)
  40314a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 4031ec <vTaskIncrementTick+0x128>
  40314e:	e012      	b.n	403176 <vTaskIncrementTick+0xb2>
  403150:	f04f 32ff 	mov.w	r2, #4294967295
  403154:	4b20      	ldr	r3, [pc, #128]	; (4031d8 <vTaskIncrementTick+0x114>)
  403156:	601a      	str	r2, [r3, #0]
  403158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40315c:	4b19      	ldr	r3, [pc, #100]	; (4031c4 <vTaskIncrementTick+0x100>)
  40315e:	681b      	ldr	r3, [r3, #0]
  403160:	68db      	ldr	r3, [r3, #12]
  403162:	68dc      	ldr	r4, [r3, #12]
  403164:	6863      	ldr	r3, [r4, #4]
  403166:	4a16      	ldr	r2, [pc, #88]	; (4031c0 <vTaskIncrementTick+0xfc>)
  403168:	6812      	ldr	r2, [r2, #0]
  40316a:	4293      	cmp	r3, r2
  40316c:	d903      	bls.n	403176 <vTaskIncrementTick+0xb2>
  40316e:	4a1a      	ldr	r2, [pc, #104]	; (4031d8 <vTaskIncrementTick+0x114>)
  403170:	6013      	str	r3, [r2, #0]
  403172:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403176:	1d25      	adds	r5, r4, #4
  403178:	4628      	mov	r0, r5
  40317a:	47b8      	blx	r7
  40317c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  40317e:	b113      	cbz	r3, 403186 <vTaskIncrementTick+0xc2>
  403180:	f104 0018 	add.w	r0, r4, #24
  403184:	47b8      	blx	r7
  403186:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  403188:	6832      	ldr	r2, [r6, #0]
  40318a:	2301      	movs	r3, #1
  40318c:	4083      	lsls	r3, r0
  40318e:	4313      	orrs	r3, r2
  403190:	6033      	str	r3, [r6, #0]
  403192:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403196:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  40319a:	4629      	mov	r1, r5
  40319c:	4b11      	ldr	r3, [pc, #68]	; (4031e4 <vTaskIncrementTick+0x120>)
  40319e:	4798      	blx	r3
  4031a0:	4b08      	ldr	r3, [pc, #32]	; (4031c4 <vTaskIncrementTick+0x100>)
  4031a2:	681b      	ldr	r3, [r3, #0]
  4031a4:	681b      	ldr	r3, [r3, #0]
  4031a6:	2b00      	cmp	r3, #0
  4031a8:	d1d8      	bne.n	40315c <vTaskIncrementTick+0x98>
  4031aa:	e7d1      	b.n	403150 <vTaskIncrementTick+0x8c>
	}
	else
	{
		++uxMissedTicks;
  4031ac:	4a0e      	ldr	r2, [pc, #56]	; (4031e8 <vTaskIncrementTick+0x124>)
  4031ae:	6813      	ldr	r3, [r2, #0]
  4031b0:	3301      	adds	r3, #1
  4031b2:	6013      	str	r3, [r2, #0]
  4031b4:	4770      	bx	lr
  4031b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4031ba:	bf00      	nop
  4031bc:	20005144 	.word	0x20005144
  4031c0:	20004ffc 	.word	0x20004ffc
  4031c4:	2000507c 	.word	0x2000507c
  4031c8:	0040ab40 	.word	0x0040ab40
  4031cc:	004041a5 	.word	0x004041a5
  4031d0:	20005064 	.word	0x20005064
  4031d4:	2000514c 	.word	0x2000514c
  4031d8:	200001f0 	.word	0x200001f0
  4031dc:	00402275 	.word	0x00402275
  4031e0:	20004ff4 	.word	0x20004ff4
  4031e4:	0040221d 	.word	0x0040221d
  4031e8:	20005148 	.word	0x20005148
  4031ec:	20005000 	.word	0x20005000

004031f0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  4031f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  4031f4:	4b31      	ldr	r3, [pc, #196]	; (4032bc <xTaskResumeAll+0xcc>)
  4031f6:	681b      	ldr	r3, [r3, #0]
  4031f8:	b923      	cbnz	r3, 403204 <xTaskResumeAll+0x14>
  4031fa:	4831      	ldr	r0, [pc, #196]	; (4032c0 <xTaskResumeAll+0xd0>)
  4031fc:	f240 514d 	movw	r1, #1357	; 0x54d
  403200:	4b30      	ldr	r3, [pc, #192]	; (4032c4 <xTaskResumeAll+0xd4>)
  403202:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  403204:	4b30      	ldr	r3, [pc, #192]	; (4032c8 <xTaskResumeAll+0xd8>)
  403206:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  403208:	4b2c      	ldr	r3, [pc, #176]	; (4032bc <xTaskResumeAll+0xcc>)
  40320a:	681a      	ldr	r2, [r3, #0]
  40320c:	3a01      	subs	r2, #1
  40320e:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  403210:	681b      	ldr	r3, [r3, #0]
  403212:	2b00      	cmp	r3, #0
  403214:	d14a      	bne.n	4032ac <xTaskResumeAll+0xbc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  403216:	4b2d      	ldr	r3, [pc, #180]	; (4032cc <xTaskResumeAll+0xdc>)
  403218:	681b      	ldr	r3, [r3, #0]
  40321a:	bb0b      	cbnz	r3, 403260 <xTaskResumeAll+0x70>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  40321c:	2400      	movs	r4, #0
  40321e:	e048      	b.n	4032b2 <xTaskResumeAll+0xc2>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  403220:	68f3      	ldr	r3, [r6, #12]
  403222:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  403224:	f104 0018 	add.w	r0, r4, #24
  403228:	47c8      	blx	r9
					uxListRemove( &( pxTCB->xGenericListItem ) );
  40322a:	1d25      	adds	r5, r4, #4
  40322c:	4628      	mov	r0, r5
  40322e:	47c8      	blx	r9
					prvAddTaskToReadyQueue( pxTCB );
  403230:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  403232:	f8d8 2000 	ldr.w	r2, [r8]
  403236:	2301      	movs	r3, #1
  403238:	4083      	lsls	r3, r0
  40323a:	4313      	orrs	r3, r2
  40323c:	f8c8 3000 	str.w	r3, [r8]
  403240:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403244:	4b22      	ldr	r3, [pc, #136]	; (4032d0 <xTaskResumeAll+0xe0>)
  403246:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  40324a:	4629      	mov	r1, r5
  40324c:	4b21      	ldr	r3, [pc, #132]	; (4032d4 <xTaskResumeAll+0xe4>)
  40324e:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  403250:	4b21      	ldr	r3, [pc, #132]	; (4032d8 <xTaskResumeAll+0xe8>)
  403252:	681b      	ldr	r3, [r3, #0]
  403254:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  403256:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  403258:	429a      	cmp	r2, r3
  40325a:	bf28      	it	cs
  40325c:	2701      	movcs	r7, #1
  40325e:	e005      	b.n	40326c <xTaskResumeAll+0x7c>
  403260:	2700      	movs	r7, #0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  403262:	4e1e      	ldr	r6, [pc, #120]	; (4032dc <xTaskResumeAll+0xec>)
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
  403264:	f8df 908c 	ldr.w	r9, [pc, #140]	; 4032f4 <xTaskResumeAll+0x104>
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  403268:	f8df 808c 	ldr.w	r8, [pc, #140]	; 4032f8 <xTaskResumeAll+0x108>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  40326c:	6833      	ldr	r3, [r6, #0]
  40326e:	2b00      	cmp	r3, #0
  403270:	d1d6      	bne.n	403220 <xTaskResumeAll+0x30>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  403272:	4b1b      	ldr	r3, [pc, #108]	; (4032e0 <xTaskResumeAll+0xf0>)
  403274:	681b      	ldr	r3, [r3, #0]
  403276:	b163      	cbz	r3, 403292 <xTaskResumeAll+0xa2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  403278:	4b19      	ldr	r3, [pc, #100]	; (4032e0 <xTaskResumeAll+0xf0>)
  40327a:	681b      	ldr	r3, [r3, #0]
  40327c:	b17b      	cbz	r3, 40329e <xTaskResumeAll+0xae>
					{
						vTaskIncrementTick();
  40327e:	4d19      	ldr	r5, [pc, #100]	; (4032e4 <xTaskResumeAll+0xf4>)
						--uxMissedTicks;
  403280:	4c17      	ldr	r4, [pc, #92]	; (4032e0 <xTaskResumeAll+0xf0>)
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
  403282:	47a8      	blx	r5
						--uxMissedTicks;
  403284:	6823      	ldr	r3, [r4, #0]
  403286:	3b01      	subs	r3, #1
  403288:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  40328a:	6823      	ldr	r3, [r4, #0]
  40328c:	2b00      	cmp	r3, #0
  40328e:	d1f8      	bne.n	403282 <xTaskResumeAll+0x92>
  403290:	e005      	b.n	40329e <xTaskResumeAll+0xae>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  403292:	2f01      	cmp	r7, #1
  403294:	d003      	beq.n	40329e <xTaskResumeAll+0xae>
  403296:	4b14      	ldr	r3, [pc, #80]	; (4032e8 <xTaskResumeAll+0xf8>)
  403298:	681b      	ldr	r3, [r3, #0]
  40329a:	2b01      	cmp	r3, #1
  40329c:	d108      	bne.n	4032b0 <xTaskResumeAll+0xc0>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  40329e:	2200      	movs	r2, #0
  4032a0:	4b11      	ldr	r3, [pc, #68]	; (4032e8 <xTaskResumeAll+0xf8>)
  4032a2:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  4032a4:	4b11      	ldr	r3, [pc, #68]	; (4032ec <xTaskResumeAll+0xfc>)
  4032a6:	4798      	blx	r3
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  4032a8:	2401      	movs	r4, #1
  4032aa:	e002      	b.n	4032b2 <xTaskResumeAll+0xc2>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  4032ac:	2400      	movs	r4, #0
  4032ae:	e000      	b.n	4032b2 <xTaskResumeAll+0xc2>
  4032b0:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  4032b2:	4b0f      	ldr	r3, [pc, #60]	; (4032f0 <xTaskResumeAll+0x100>)
  4032b4:	4798      	blx	r3

	return xAlreadyYielded;
}
  4032b6:	4620      	mov	r0, r4
  4032b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4032bc:	20005144 	.word	0x20005144
  4032c0:	0040ab40 	.word	0x0040ab40
  4032c4:	004041a5 	.word	0x004041a5
  4032c8:	00402325 	.word	0x00402325
  4032cc:	200050f0 	.word	0x200050f0
  4032d0:	20005000 	.word	0x20005000
  4032d4:	0040221d 	.word	0x0040221d
  4032d8:	200050a4 	.word	0x200050a4
  4032dc:	20005080 	.word	0x20005080
  4032e0:	20005148 	.word	0x20005148
  4032e4:	004030c5 	.word	0x004030c5
  4032e8:	2000509c 	.word	0x2000509c
  4032ec:	00402305 	.word	0x00402305
  4032f0:	00402345 	.word	0x00402345
  4032f4:	00402275 	.word	0x00402275
  4032f8:	20004ff4 	.word	0x20004ff4

004032fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
  4032fc:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
  4032fe:	b1d8      	cbz	r0, 403338 <vTaskDelay+0x3c>
  403300:	4604      	mov	r4, r0
		{
			vTaskSuspendAll();
  403302:	4b0f      	ldr	r3, [pc, #60]	; (403340 <vTaskDelay+0x44>)
  403304:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  403306:	4b0f      	ldr	r3, [pc, #60]	; (403344 <vTaskDelay+0x48>)
  403308:	681b      	ldr	r3, [r3, #0]
  40330a:	441c      	add	r4, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  40330c:	4b0e      	ldr	r3, [pc, #56]	; (403348 <vTaskDelay+0x4c>)
  40330e:	6818      	ldr	r0, [r3, #0]
  403310:	3004      	adds	r0, #4
  403312:	4b0e      	ldr	r3, [pc, #56]	; (40334c <vTaskDelay+0x50>)
  403314:	4798      	blx	r3
  403316:	b948      	cbnz	r0, 40332c <vTaskDelay+0x30>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403318:	4b0b      	ldr	r3, [pc, #44]	; (403348 <vTaskDelay+0x4c>)
  40331a:	681b      	ldr	r3, [r3, #0]
  40331c:	490c      	ldr	r1, [pc, #48]	; (403350 <vTaskDelay+0x54>)
  40331e:	680a      	ldr	r2, [r1, #0]
  403320:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  403322:	2301      	movs	r3, #1
  403324:	4083      	lsls	r3, r0
  403326:	ea22 0303 	bic.w	r3, r2, r3
  40332a:	600b      	str	r3, [r1, #0]
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  40332c:	4620      	mov	r0, r4
  40332e:	4b09      	ldr	r3, [pc, #36]	; (403354 <vTaskDelay+0x58>)
  403330:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  403332:	4b09      	ldr	r3, [pc, #36]	; (403358 <vTaskDelay+0x5c>)
  403334:	4798      	blx	r3
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  403336:	b908      	cbnz	r0, 40333c <vTaskDelay+0x40>
		{
			portYIELD_WITHIN_API();
  403338:	4b08      	ldr	r3, [pc, #32]	; (40335c <vTaskDelay+0x60>)
  40333a:	4798      	blx	r3
  40333c:	bd10      	pop	{r4, pc}
  40333e:	bf00      	nop
  403340:	00403075 	.word	0x00403075
  403344:	20004ffc 	.word	0x20004ffc
  403348:	200050a4 	.word	0x200050a4
  40334c:	00402275 	.word	0x00402275
  403350:	20004ff4 	.word	0x20004ff4
  403354:	00402bb9 	.word	0x00402bb9
  403358:	004031f1 	.word	0x004031f1
  40335c:	00402305 	.word	0x00402305

00403360 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  403360:	b580      	push	{r7, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  403362:	4d15      	ldr	r5, [pc, #84]	; (4033b8 <prvIdleTask+0x58>)
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  403364:	4e15      	ldr	r6, [pc, #84]	; (4033bc <prvIdleTask+0x5c>)

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
  403366:	f8df 8074 	ldr.w	r8, [pc, #116]	; 4033dc <prvIdleTask+0x7c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
			xTaskResumeAll();
  40336a:	4f15      	ldr	r7, [pc, #84]	; (4033c0 <prvIdleTask+0x60>)
  40336c:	e019      	b.n	4033a2 <prvIdleTask+0x42>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
  40336e:	47c0      	blx	r8
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  403370:	6834      	ldr	r4, [r6, #0]
			xTaskResumeAll();
  403372:	47b8      	blx	r7

			if( xListIsEmpty == pdFALSE )
  403374:	b1ac      	cbz	r4, 4033a2 <prvIdleTask+0x42>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  403376:	4b13      	ldr	r3, [pc, #76]	; (4033c4 <prvIdleTask+0x64>)
  403378:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  40337a:	68f3      	ldr	r3, [r6, #12]
  40337c:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
  40337e:	1d20      	adds	r0, r4, #4
  403380:	4b11      	ldr	r3, [pc, #68]	; (4033c8 <prvIdleTask+0x68>)
  403382:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  403384:	4a11      	ldr	r2, [pc, #68]	; (4033cc <prvIdleTask+0x6c>)
  403386:	6813      	ldr	r3, [r2, #0]
  403388:	3b01      	subs	r3, #1
  40338a:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
  40338c:	682b      	ldr	r3, [r5, #0]
  40338e:	3b01      	subs	r3, #1
  403390:	602b      	str	r3, [r5, #0]
				}
				taskEXIT_CRITICAL();
  403392:	4b0f      	ldr	r3, [pc, #60]	; (4033d0 <prvIdleTask+0x70>)
  403394:	4798      	blx	r3
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  403396:	6b20      	ldr	r0, [r4, #48]	; 0x30
  403398:	f8df 9044 	ldr.w	r9, [pc, #68]	; 4033e0 <prvIdleTask+0x80>
  40339c:	47c8      	blx	r9
		vPortFree( pxTCB );
  40339e:	4620      	mov	r0, r4
  4033a0:	47c8      	blx	r9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
  4033a2:	682b      	ldr	r3, [r5, #0]
  4033a4:	2b00      	cmp	r3, #0
  4033a6:	d1e2      	bne.n	40336e <prvIdleTask+0xe>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4033a8:	4b0a      	ldr	r3, [pc, #40]	; (4033d4 <prvIdleTask+0x74>)
  4033aa:	681b      	ldr	r3, [r3, #0]
  4033ac:	2b01      	cmp	r3, #1
  4033ae:	d9f8      	bls.n	4033a2 <prvIdleTask+0x42>
			{
				taskYIELD();
  4033b0:	4b09      	ldr	r3, [pc, #36]	; (4033d8 <prvIdleTask+0x78>)
  4033b2:	4798      	blx	r3
  4033b4:	e7d7      	b.n	403366 <prvIdleTask+0x6>
  4033b6:	bf00      	nop
  4033b8:	20004ff8 	.word	0x20004ff8
  4033bc:	20005068 	.word	0x20005068
  4033c0:	004031f1 	.word	0x004031f1
  4033c4:	00402325 	.word	0x00402325
  4033c8:	00402275 	.word	0x00402275
  4033cc:	200050f0 	.word	0x200050f0
  4033d0:	00402345 	.word	0x00402345
  4033d4:	20005000 	.word	0x20005000
  4033d8:	00402305 	.word	0x00402305
  4033dc:	00403075 	.word	0x00403075
  4033e0:	0040256d 	.word	0x0040256d

004033e4 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
  4033e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4033e8:	4606      	mov	r6, r0
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
  4033ea:	4b28      	ldr	r3, [pc, #160]	; (40348c <vTaskList+0xa8>)
  4033ec:	4798      	blx	r3
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
  4033ee:	2300      	movs	r3, #0
  4033f0:	7033      	strb	r3, [r6, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  4033f2:	4630      	mov	r0, r6
  4033f4:	4b26      	ldr	r3, [pc, #152]	; (403490 <vTaskList+0xac>)
  4033f6:	4798      	blx	r3
  4033f8:	1832      	adds	r2, r6, r0
  4033fa:	4b26      	ldr	r3, [pc, #152]	; (403494 <vTaskList+0xb0>)
  4033fc:	8819      	ldrh	r1, [r3, #0]
  4033fe:	789b      	ldrb	r3, [r3, #2]
  403400:	5231      	strh	r1, [r6, r0]
  403402:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  403404:	4b24      	ldr	r3, [pc, #144]	; (403498 <vTaskList+0xb4>)
  403406:	681c      	ldr	r4, [r3, #0]
  403408:	3401      	adds	r4, #1
  40340a:	eb04 0584 	add.w	r5, r4, r4, lsl #2
  40340e:	4b23      	ldr	r3, [pc, #140]	; (40349c <vTaskList+0xb8>)
  403410:	eb03 0585 	add.w	r5, r3, r5, lsl #2
  403414:	3d14      	subs	r5, #20

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  403416:	461f      	mov	r7, r3
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  403418:	f04f 0952 	mov.w	r9, #82	; 0x52
  40341c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 4034a4 <vTaskList+0xc0>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
  403420:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  403422:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403426:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
  40342a:	b11b      	cbz	r3, 403434 <vTaskList+0x50>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  40342c:	4630      	mov	r0, r6
  40342e:	4629      	mov	r1, r5
  403430:	464a      	mov	r2, r9
  403432:	47c0      	blx	r8
  403434:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  403436:	2c00      	cmp	r4, #0
  403438:	d1f2      	bne.n	403420 <vTaskList+0x3c>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
  40343a:	4b19      	ldr	r3, [pc, #100]	; (4034a0 <vTaskList+0xbc>)
  40343c:	681b      	ldr	r3, [r3, #0]
  40343e:	681b      	ldr	r3, [r3, #0]
  403440:	b12b      	cbz	r3, 40344e <vTaskList+0x6a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
  403442:	4b17      	ldr	r3, [pc, #92]	; (4034a0 <vTaskList+0xbc>)
  403444:	6819      	ldr	r1, [r3, #0]
  403446:	4630      	mov	r0, r6
  403448:	2242      	movs	r2, #66	; 0x42
  40344a:	4b16      	ldr	r3, [pc, #88]	; (4034a4 <vTaskList+0xc0>)
  40344c:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
  40344e:	4b16      	ldr	r3, [pc, #88]	; (4034a8 <vTaskList+0xc4>)
  403450:	681b      	ldr	r3, [r3, #0]
  403452:	681b      	ldr	r3, [r3, #0]
  403454:	b12b      	cbz	r3, 403462 <vTaskList+0x7e>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
  403456:	4b14      	ldr	r3, [pc, #80]	; (4034a8 <vTaskList+0xc4>)
  403458:	6819      	ldr	r1, [r3, #0]
  40345a:	4630      	mov	r0, r6
  40345c:	2242      	movs	r2, #66	; 0x42
  40345e:	4b11      	ldr	r3, [pc, #68]	; (4034a4 <vTaskList+0xc0>)
  403460:	4798      	blx	r3
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
  403462:	4b12      	ldr	r3, [pc, #72]	; (4034ac <vTaskList+0xc8>)
  403464:	681b      	ldr	r3, [r3, #0]
  403466:	b123      	cbz	r3, 403472 <vTaskList+0x8e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
  403468:	4630      	mov	r0, r6
  40346a:	4910      	ldr	r1, [pc, #64]	; (4034ac <vTaskList+0xc8>)
  40346c:	2244      	movs	r2, #68	; 0x44
  40346e:	4b0d      	ldr	r3, [pc, #52]	; (4034a4 <vTaskList+0xc0>)
  403470:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
  403472:	4b0f      	ldr	r3, [pc, #60]	; (4034b0 <vTaskList+0xcc>)
  403474:	681b      	ldr	r3, [r3, #0]
  403476:	b123      	cbz	r3, 403482 <vTaskList+0x9e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
  403478:	4630      	mov	r0, r6
  40347a:	490d      	ldr	r1, [pc, #52]	; (4034b0 <vTaskList+0xcc>)
  40347c:	2253      	movs	r2, #83	; 0x53
  40347e:	4b09      	ldr	r3, [pc, #36]	; (4034a4 <vTaskList+0xc0>)
  403480:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
  403482:	4b0c      	ldr	r3, [pc, #48]	; (4034b4 <vTaskList+0xd0>)
  403484:	4798      	blx	r3
  403486:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40348a:	bf00      	nop
  40348c:	00403075 	.word	0x00403075
  403490:	00404af9 	.word	0x00404af9
  403494:	0040984c 	.word	0x0040984c
  403498:	20005150 	.word	0x20005150
  40349c:	20005000 	.word	0x20005000
  4034a0:	2000507c 	.word	0x2000507c
  4034a4:	00402c11 	.word	0x00402c11
  4034a8:	20005064 	.word	0x20005064
  4034ac:	20005068 	.word	0x20005068
  4034b0:	200050dc 	.word	0x200050dc
  4034b4:	004031f1 	.word	0x004031f1

004034b8 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( configGENERATE_RUN_TIME_STATS == 1 )

	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
	{
  4034b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4034bc:	4607      	mov	r7, r0
	unsigned long ulTotalRunTime;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
  4034be:	4b2a      	ldr	r3, [pc, #168]	; (403568 <vTaskGetRunTimeStats+0xb0>)
  4034c0:	4798      	blx	r3
		{
			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
			#else
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
  4034c2:	4b2a      	ldr	r3, [pc, #168]	; (40356c <vTaskGetRunTimeStats+0xb4>)
  4034c4:	4798      	blx	r3
			#endif

			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
			ulTotalRunTime /= 100UL;
  4034c6:	4e2a      	ldr	r6, [pc, #168]	; (403570 <vTaskGetRunTimeStats+0xb8>)
  4034c8:	fba6 3600 	umull	r3, r6, r6, r0
  4034cc:	0976      	lsrs	r6, r6, #5

			/* Run through all the lists that could potentially contain a TCB,
			generating a table of run timer percentages in the provided
			buffer. */

			*pcWriteBuffer = ( signed char ) 0x00;
  4034ce:	2300      	movs	r3, #0
  4034d0:	703b      	strb	r3, [r7, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  4034d2:	4638      	mov	r0, r7
  4034d4:	4b27      	ldr	r3, [pc, #156]	; (403574 <vTaskGetRunTimeStats+0xbc>)
  4034d6:	4798      	blx	r3
  4034d8:	183a      	adds	r2, r7, r0
  4034da:	4b27      	ldr	r3, [pc, #156]	; (403578 <vTaskGetRunTimeStats+0xc0>)
  4034dc:	8819      	ldrh	r1, [r3, #0]
  4034de:	789b      	ldrb	r3, [r3, #2]
  4034e0:	5239      	strh	r1, [r7, r0]
  4034e2:	7093      	strb	r3, [r2, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  4034e4:	4b25      	ldr	r3, [pc, #148]	; (40357c <vTaskGetRunTimeStats+0xc4>)
  4034e6:	681c      	ldr	r4, [r3, #0]
  4034e8:	3401      	adds	r4, #1
  4034ea:	eb04 0584 	add.w	r5, r4, r4, lsl #2
  4034ee:	4b24      	ldr	r3, [pc, #144]	; (403580 <vTaskGetRunTimeStats+0xc8>)
  4034f0:	eb03 0585 	add.w	r5, r3, r5, lsl #2
  4034f4:	3d14      	subs	r5, #20

			do
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  4034f6:	4698      	mov	r8, r3
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
  4034f8:	f8df 908c 	ldr.w	r9, [pc, #140]	; 403588 <vTaskGetRunTimeStats+0xd0>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
  4034fc:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  4034fe:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403502:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
  403506:	b11b      	cbz	r3, 403510 <vTaskGetRunTimeStats+0x58>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
  403508:	4638      	mov	r0, r7
  40350a:	4629      	mov	r1, r5
  40350c:	4632      	mov	r2, r6
  40350e:	47c8      	blx	r9
  403510:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  403512:	2c00      	cmp	r4, #0
  403514:	d1f2      	bne.n	4034fc <vTaskGetRunTimeStats+0x44>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
  403516:	4b1b      	ldr	r3, [pc, #108]	; (403584 <vTaskGetRunTimeStats+0xcc>)
  403518:	681b      	ldr	r3, [r3, #0]
  40351a:	681b      	ldr	r3, [r3, #0]
  40351c:	b12b      	cbz	r3, 40352a <vTaskGetRunTimeStats+0x72>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
  40351e:	4b19      	ldr	r3, [pc, #100]	; (403584 <vTaskGetRunTimeStats+0xcc>)
  403520:	6819      	ldr	r1, [r3, #0]
  403522:	4638      	mov	r0, r7
  403524:	4632      	mov	r2, r6
  403526:	4b18      	ldr	r3, [pc, #96]	; (403588 <vTaskGetRunTimeStats+0xd0>)
  403528:	4798      	blx	r3
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
  40352a:	4b18      	ldr	r3, [pc, #96]	; (40358c <vTaskGetRunTimeStats+0xd4>)
  40352c:	681b      	ldr	r3, [r3, #0]
  40352e:	681b      	ldr	r3, [r3, #0]
  403530:	b12b      	cbz	r3, 40353e <vTaskGetRunTimeStats+0x86>
			{
				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
  403532:	4b16      	ldr	r3, [pc, #88]	; (40358c <vTaskGetRunTimeStats+0xd4>)
  403534:	6819      	ldr	r1, [r3, #0]
  403536:	4638      	mov	r0, r7
  403538:	4632      	mov	r2, r6
  40353a:	4b13      	ldr	r3, [pc, #76]	; (403588 <vTaskGetRunTimeStats+0xd0>)
  40353c:	4798      	blx	r3
			}

			#if ( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
  40353e:	4b14      	ldr	r3, [pc, #80]	; (403590 <vTaskGetRunTimeStats+0xd8>)
  403540:	681b      	ldr	r3, [r3, #0]
  403542:	b123      	cbz	r3, 40354e <vTaskGetRunTimeStats+0x96>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
  403544:	4638      	mov	r0, r7
  403546:	4912      	ldr	r1, [pc, #72]	; (403590 <vTaskGetRunTimeStats+0xd8>)
  403548:	4632      	mov	r2, r6
  40354a:	4b0f      	ldr	r3, [pc, #60]	; (403588 <vTaskGetRunTimeStats+0xd0>)
  40354c:	4798      	blx	r3
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
  40354e:	4b11      	ldr	r3, [pc, #68]	; (403594 <vTaskGetRunTimeStats+0xdc>)
  403550:	681b      	ldr	r3, [r3, #0]
  403552:	b123      	cbz	r3, 40355e <vTaskGetRunTimeStats+0xa6>
				{
					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
  403554:	4638      	mov	r0, r7
  403556:	490f      	ldr	r1, [pc, #60]	; (403594 <vTaskGetRunTimeStats+0xdc>)
  403558:	4632      	mov	r2, r6
  40355a:	4b0b      	ldr	r3, [pc, #44]	; (403588 <vTaskGetRunTimeStats+0xd0>)
  40355c:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
  40355e:	4b0e      	ldr	r3, [pc, #56]	; (403598 <vTaskGetRunTimeStats+0xe0>)
  403560:	4798      	blx	r3
  403562:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403566:	bf00      	nop
  403568:	00403075 	.word	0x00403075
  40356c:	004043dd 	.word	0x004043dd
  403570:	51eb851f 	.word	0x51eb851f
  403574:	00404af9 	.word	0x00404af9
  403578:	0040984c 	.word	0x0040984c
  40357c:	20005150 	.word	0x20005150
  403580:	20005000 	.word	0x20005000
  403584:	2000507c 	.word	0x2000507c
  403588:	00402ca5 	.word	0x00402ca5
  40358c:	20005064 	.word	0x20005064
  403590:	20005068 	.word	0x20005068
  403594:	200050dc 	.word	0x200050dc
  403598:	004031f1 	.word	0x004031f1

0040359c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  40359c:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  40359e:	4b2d      	ldr	r3, [pc, #180]	; (403654 <vTaskSwitchContext+0xb8>)
  4035a0:	681b      	ldr	r3, [r3, #0]
  4035a2:	b11b      	cbz	r3, 4035ac <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  4035a4:	2201      	movs	r2, #1
  4035a6:	4b2c      	ldr	r3, [pc, #176]	; (403658 <vTaskSwitchContext+0xbc>)
  4035a8:	601a      	str	r2, [r3, #0]
  4035aa:	bd38      	pop	{r3, r4, r5, pc}
			unsigned long ulTempCounter;

				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
  4035ac:	4b2b      	ldr	r3, [pc, #172]	; (40365c <vTaskSwitchContext+0xc0>)
  4035ae:	4798      	blx	r3
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
  4035b0:	4a2b      	ldr	r2, [pc, #172]	; (403660 <vTaskSwitchContext+0xc4>)
  4035b2:	6814      	ldr	r4, [r2, #0]
  4035b4:	492b      	ldr	r1, [pc, #172]	; (403664 <vTaskSwitchContext+0xc8>)
  4035b6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  4035b8:	680d      	ldr	r5, [r1, #0]
  4035ba:	1b5b      	subs	r3, r3, r5
  4035bc:	4403      	add	r3, r0
  4035be:	64e3      	str	r3, [r4, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
  4035c0:	6008      	str	r0, [r1, #0]
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
  4035c2:	6811      	ldr	r1, [r2, #0]
  4035c4:	6813      	ldr	r3, [r2, #0]
  4035c6:	680a      	ldr	r2, [r1, #0]
  4035c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4035ca:	429a      	cmp	r2, r3
  4035cc:	d805      	bhi.n	4035da <vTaskSwitchContext+0x3e>
  4035ce:	4b24      	ldr	r3, [pc, #144]	; (403660 <vTaskSwitchContext+0xc4>)
  4035d0:	6818      	ldr	r0, [r3, #0]
  4035d2:	6819      	ldr	r1, [r3, #0]
  4035d4:	3134      	adds	r1, #52	; 0x34
  4035d6:	4b24      	ldr	r3, [pc, #144]	; (403668 <vTaskSwitchContext+0xcc>)
  4035d8:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
  4035da:	4b21      	ldr	r3, [pc, #132]	; (403660 <vTaskSwitchContext+0xc4>)
  4035dc:	681b      	ldr	r3, [r3, #0]
  4035de:	6b18      	ldr	r0, [r3, #48]	; 0x30
  4035e0:	4922      	ldr	r1, [pc, #136]	; (40366c <vTaskSwitchContext+0xd0>)
  4035e2:	2214      	movs	r2, #20
  4035e4:	4b22      	ldr	r3, [pc, #136]	; (403670 <vTaskSwitchContext+0xd4>)
  4035e6:	4798      	blx	r3
  4035e8:	b128      	cbz	r0, 4035f6 <vTaskSwitchContext+0x5a>
  4035ea:	4b1d      	ldr	r3, [pc, #116]	; (403660 <vTaskSwitchContext+0xc4>)
  4035ec:	6818      	ldr	r0, [r3, #0]
  4035ee:	6819      	ldr	r1, [r3, #0]
  4035f0:	3134      	adds	r1, #52	; 0x34
  4035f2:	4b1d      	ldr	r3, [pc, #116]	; (403668 <vTaskSwitchContext+0xcc>)
  4035f4:	4798      	blx	r3

		taskSELECT_HIGHEST_PRIORITY_TASK();
  4035f6:	4b1f      	ldr	r3, [pc, #124]	; (403674 <vTaskSwitchContext+0xd8>)
  4035f8:	681c      	ldr	r4, [r3, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline unsigned char ucPortCountLeadingZeros( unsigned long ulBitmap )
	{
	unsigned char ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
  4035fa:	fab4 f484 	clz	r4, r4
  4035fe:	b2e4      	uxtb	r4, r4
  403600:	f1c4 041f 	rsb	r4, r4, #31
  403604:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403608:	009b      	lsls	r3, r3, #2
  40360a:	4a1b      	ldr	r2, [pc, #108]	; (403678 <vTaskSwitchContext+0xdc>)
  40360c:	58d3      	ldr	r3, [r2, r3]
  40360e:	b923      	cbnz	r3, 40361a <vTaskSwitchContext+0x7e>
  403610:	481a      	ldr	r0, [pc, #104]	; (40367c <vTaskSwitchContext+0xe0>)
  403612:	f240 713e 	movw	r1, #1854	; 0x73e
  403616:	4b1a      	ldr	r3, [pc, #104]	; (403680 <vTaskSwitchContext+0xe4>)
  403618:	4798      	blx	r3
  40361a:	4b17      	ldr	r3, [pc, #92]	; (403678 <vTaskSwitchContext+0xdc>)
  40361c:	00a2      	lsls	r2, r4, #2
  40361e:	1911      	adds	r1, r2, r4
  403620:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  403624:	6848      	ldr	r0, [r1, #4]
  403626:	6840      	ldr	r0, [r0, #4]
  403628:	6048      	str	r0, [r1, #4]
  40362a:	460b      	mov	r3, r1
  40362c:	3308      	adds	r3, #8
  40362e:	4298      	cmp	r0, r3
  403630:	d106      	bne.n	403640 <vTaskSwitchContext+0xa4>
  403632:	6841      	ldr	r1, [r0, #4]
  403634:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  403638:	4a0f      	ldr	r2, [pc, #60]	; (403678 <vTaskSwitchContext+0xdc>)
  40363a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  40363e:	6059      	str	r1, [r3, #4]
  403640:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  403644:	4b0c      	ldr	r3, [pc, #48]	; (403678 <vTaskSwitchContext+0xdc>)
  403646:	eb03 0484 	add.w	r4, r3, r4, lsl #2
  40364a:	6863      	ldr	r3, [r4, #4]
  40364c:	68da      	ldr	r2, [r3, #12]
  40364e:	4b04      	ldr	r3, [pc, #16]	; (403660 <vTaskSwitchContext+0xc4>)
  403650:	601a      	str	r2, [r3, #0]
  403652:	bd38      	pop	{r3, r4, r5, pc}
  403654:	20005144 	.word	0x20005144
  403658:	2000509c 	.word	0x2000509c
  40365c:	004043dd 	.word	0x004043dd
  403660:	200050a4 	.word	0x200050a4
  403664:	20005098 	.word	0x20005098
  403668:	00404199 	.word	0x00404199
  40366c:	0040aae8 	.word	0x0040aae8
  403670:	00404489 	.word	0x00404489
  403674:	20004ff4 	.word	0x20004ff4
  403678:	20005000 	.word	0x20005000
  40367c:	0040ab40 	.word	0x0040ab40
  403680:	004041a5 	.word	0x004041a5

00403684 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  403684:	b570      	push	{r4, r5, r6, lr}
  403686:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
  403688:	4606      	mov	r6, r0
  40368a:	b920      	cbnz	r0, 403696 <vTaskPlaceOnEventList+0x12>
  40368c:	4814      	ldr	r0, [pc, #80]	; (4036e0 <vTaskPlaceOnEventList+0x5c>)
  40368e:	f240 7149 	movw	r1, #1865	; 0x749
  403692:	4b14      	ldr	r3, [pc, #80]	; (4036e4 <vTaskPlaceOnEventList+0x60>)
  403694:	4798      	blx	r3
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  403696:	4c14      	ldr	r4, [pc, #80]	; (4036e8 <vTaskPlaceOnEventList+0x64>)
  403698:	6821      	ldr	r1, [r4, #0]
  40369a:	4630      	mov	r0, r6
  40369c:	3118      	adds	r1, #24
  40369e:	4b13      	ldr	r3, [pc, #76]	; (4036ec <vTaskPlaceOnEventList+0x68>)
  4036a0:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  4036a2:	6820      	ldr	r0, [r4, #0]
  4036a4:	3004      	adds	r0, #4
  4036a6:	4b12      	ldr	r3, [pc, #72]	; (4036f0 <vTaskPlaceOnEventList+0x6c>)
  4036a8:	4798      	blx	r3
  4036aa:	b940      	cbnz	r0, 4036be <vTaskPlaceOnEventList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  4036ac:	6823      	ldr	r3, [r4, #0]
  4036ae:	4911      	ldr	r1, [pc, #68]	; (4036f4 <vTaskPlaceOnEventList+0x70>)
  4036b0:	680a      	ldr	r2, [r1, #0]
  4036b2:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  4036b4:	2301      	movs	r3, #1
  4036b6:	4083      	lsls	r3, r0
  4036b8:	ea22 0303 	bic.w	r3, r2, r3
  4036bc:	600b      	str	r3, [r1, #0]
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  4036be:	f1b5 3fff 	cmp.w	r5, #4294967295
  4036c2:	d106      	bne.n	4036d2 <vTaskPlaceOnEventList+0x4e>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4036c4:	4b08      	ldr	r3, [pc, #32]	; (4036e8 <vTaskPlaceOnEventList+0x64>)
  4036c6:	6819      	ldr	r1, [r3, #0]
  4036c8:	480b      	ldr	r0, [pc, #44]	; (4036f8 <vTaskPlaceOnEventList+0x74>)
  4036ca:	3104      	adds	r1, #4
  4036cc:	4b0b      	ldr	r3, [pc, #44]	; (4036fc <vTaskPlaceOnEventList+0x78>)
  4036ce:	4798      	blx	r3
  4036d0:	bd70      	pop	{r4, r5, r6, pc}
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  4036d2:	4b0b      	ldr	r3, [pc, #44]	; (403700 <vTaskPlaceOnEventList+0x7c>)
  4036d4:	6818      	ldr	r0, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  4036d6:	4428      	add	r0, r5
  4036d8:	4b0a      	ldr	r3, [pc, #40]	; (403704 <vTaskPlaceOnEventList+0x80>)
  4036da:	4798      	blx	r3
  4036dc:	bd70      	pop	{r4, r5, r6, pc}
  4036de:	bf00      	nop
  4036e0:	0040ab40 	.word	0x0040ab40
  4036e4:	004041a5 	.word	0x004041a5
  4036e8:	200050a4 	.word	0x200050a4
  4036ec:	00402239 	.word	0x00402239
  4036f0:	00402275 	.word	0x00402275
  4036f4:	20004ff4 	.word	0x20004ff4
  4036f8:	200050dc 	.word	0x200050dc
  4036fc:	0040221d 	.word	0x0040221d
  403700:	20004ffc 	.word	0x20004ffc
  403704:	00402bb9 	.word	0x00402bb9

00403708 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
  403708:	b570      	push	{r4, r5, r6, lr}
  40370a:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
  40370c:	4606      	mov	r6, r0
  40370e:	b920      	cbnz	r0, 40371a <vTaskPlaceOnEventListRestricted+0x12>
  403710:	480f      	ldr	r0, [pc, #60]	; (403750 <vTaskPlaceOnEventListRestricted+0x48>)
  403712:	f240 717f 	movw	r1, #1919	; 0x77f
  403716:	4b0f      	ldr	r3, [pc, #60]	; (403754 <vTaskPlaceOnEventListRestricted+0x4c>)
  403718:	4798      	blx	r3

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40371a:	4c0f      	ldr	r4, [pc, #60]	; (403758 <vTaskPlaceOnEventListRestricted+0x50>)
  40371c:	6821      	ldr	r1, [r4, #0]
  40371e:	4630      	mov	r0, r6
  403720:	3118      	adds	r1, #24
  403722:	4b0e      	ldr	r3, [pc, #56]	; (40375c <vTaskPlaceOnEventListRestricted+0x54>)
  403724:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
  403726:	6820      	ldr	r0, [r4, #0]
  403728:	3004      	adds	r0, #4
  40372a:	4b0d      	ldr	r3, [pc, #52]	; (403760 <vTaskPlaceOnEventListRestricted+0x58>)
  40372c:	4798      	blx	r3
  40372e:	b940      	cbnz	r0, 403742 <vTaskPlaceOnEventListRestricted+0x3a>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
  403730:	6823      	ldr	r3, [r4, #0]
  403732:	490c      	ldr	r1, [pc, #48]	; (403764 <vTaskPlaceOnEventListRestricted+0x5c>)
  403734:	680a      	ldr	r2, [r1, #0]
  403736:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  403738:	2301      	movs	r3, #1
  40373a:	4083      	lsls	r3, r0
  40373c:	ea22 0303 	bic.w	r3, r2, r3
  403740:	600b      	str	r3, [r1, #0]
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  403742:	4b09      	ldr	r3, [pc, #36]	; (403768 <vTaskPlaceOnEventListRestricted+0x60>)
  403744:	6818      	ldr	r0, [r3, #0]
		
		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  403746:	4428      	add	r0, r5
  403748:	4b08      	ldr	r3, [pc, #32]	; (40376c <vTaskPlaceOnEventListRestricted+0x64>)
  40374a:	4798      	blx	r3
  40374c:	bd70      	pop	{r4, r5, r6, pc}
  40374e:	bf00      	nop
  403750:	0040ab40 	.word	0x0040ab40
  403754:	004041a5 	.word	0x004041a5
  403758:	200050a4 	.word	0x200050a4
  40375c:	0040221d 	.word	0x0040221d
  403760:	00402275 	.word	0x00402275
  403764:	20004ff4 	.word	0x20004ff4
  403768:	20004ffc 	.word	0x20004ffc
  40376c:	00402bb9 	.word	0x00402bb9

00403770 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  403770:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  403772:	68c3      	ldr	r3, [r0, #12]
  403774:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  403776:	b924      	cbnz	r4, 403782 <xTaskRemoveFromEventList+0x12>
  403778:	4816      	ldr	r0, [pc, #88]	; (4037d4 <xTaskRemoveFromEventList+0x64>)
  40377a:	f240 71b5 	movw	r1, #1973	; 0x7b5
  40377e:	4b16      	ldr	r3, [pc, #88]	; (4037d8 <xTaskRemoveFromEventList+0x68>)
  403780:	4798      	blx	r3
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  403782:	f104 0518 	add.w	r5, r4, #24
  403786:	4628      	mov	r0, r5
  403788:	4b14      	ldr	r3, [pc, #80]	; (4037dc <xTaskRemoveFromEventList+0x6c>)
  40378a:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40378c:	4b14      	ldr	r3, [pc, #80]	; (4037e0 <xTaskRemoveFromEventList+0x70>)
  40378e:	681b      	ldr	r3, [r3, #0]
  403790:	b99b      	cbnz	r3, 4037ba <xTaskRemoveFromEventList+0x4a>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  403792:	1d25      	adds	r5, r4, #4
  403794:	4628      	mov	r0, r5
  403796:	4b11      	ldr	r3, [pc, #68]	; (4037dc <xTaskRemoveFromEventList+0x6c>)
  403798:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  40379a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  40379c:	4911      	ldr	r1, [pc, #68]	; (4037e4 <xTaskRemoveFromEventList+0x74>)
  40379e:	680a      	ldr	r2, [r1, #0]
  4037a0:	2301      	movs	r3, #1
  4037a2:	4083      	lsls	r3, r0
  4037a4:	4313      	orrs	r3, r2
  4037a6:	600b      	str	r3, [r1, #0]
  4037a8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4037ac:	4b0e      	ldr	r3, [pc, #56]	; (4037e8 <xTaskRemoveFromEventList+0x78>)
  4037ae:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4037b2:	4629      	mov	r1, r5
  4037b4:	4b0d      	ldr	r3, [pc, #52]	; (4037ec <xTaskRemoveFromEventList+0x7c>)
  4037b6:	4798      	blx	r3
  4037b8:	e003      	b.n	4037c2 <xTaskRemoveFromEventList+0x52>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4037ba:	480d      	ldr	r0, [pc, #52]	; (4037f0 <xTaskRemoveFromEventList+0x80>)
  4037bc:	4629      	mov	r1, r5
  4037be:	4b0b      	ldr	r3, [pc, #44]	; (4037ec <xTaskRemoveFromEventList+0x7c>)
  4037c0:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4037c2:	4b0c      	ldr	r3, [pc, #48]	; (4037f4 <xTaskRemoveFromEventList+0x84>)
  4037c4:	681b      	ldr	r3, [r3, #0]
  4037c6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4037c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4037ca:	4298      	cmp	r0, r3
  4037cc:	bf34      	ite	cc
  4037ce:	2000      	movcc	r0, #0
  4037d0:	2001      	movcs	r0, #1
  4037d2:	bd38      	pop	{r3, r4, r5, pc}
  4037d4:	0040ab40 	.word	0x0040ab40
  4037d8:	004041a5 	.word	0x004041a5
  4037dc:	00402275 	.word	0x00402275
  4037e0:	20005144 	.word	0x20005144
  4037e4:	20004ff4 	.word	0x20004ff4
  4037e8:	20005000 	.word	0x20005000
  4037ec:	0040221d 	.word	0x0040221d
  4037f0:	20005080 	.word	0x20005080
  4037f4:	200050a4 	.word	0x200050a4

004037f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
  4037f8:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
  4037fa:	4604      	mov	r4, r0
  4037fc:	b920      	cbnz	r0, 403808 <vTaskSetTimeOutState+0x10>
  4037fe:	4806      	ldr	r0, [pc, #24]	; (403818 <vTaskSetTimeOutState+0x20>)
  403800:	f240 71d7 	movw	r1, #2007	; 0x7d7
  403804:	4b05      	ldr	r3, [pc, #20]	; (40381c <vTaskSetTimeOutState+0x24>)
  403806:	4798      	blx	r3
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  403808:	4b05      	ldr	r3, [pc, #20]	; (403820 <vTaskSetTimeOutState+0x28>)
  40380a:	681b      	ldr	r3, [r3, #0]
  40380c:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  40380e:	4b05      	ldr	r3, [pc, #20]	; (403824 <vTaskSetTimeOutState+0x2c>)
  403810:	681b      	ldr	r3, [r3, #0]
  403812:	6063      	str	r3, [r4, #4]
  403814:	bd10      	pop	{r4, pc}
  403816:	bf00      	nop
  403818:	0040ab40 	.word	0x0040ab40
  40381c:	004041a5 	.word	0x004041a5
  403820:	2000514c 	.word	0x2000514c
  403824:	20004ffc 	.word	0x20004ffc

00403828 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  403828:	b538      	push	{r3, r4, r5, lr}
  40382a:	460c      	mov	r4, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
  40382c:	4605      	mov	r5, r0
  40382e:	b920      	cbnz	r0, 40383a <xTaskCheckForTimeOut+0x12>
  403830:	4819      	ldr	r0, [pc, #100]	; (403898 <xTaskCheckForTimeOut+0x70>)
  403832:	f240 71e1 	movw	r1, #2017	; 0x7e1
  403836:	4b19      	ldr	r3, [pc, #100]	; (40389c <xTaskCheckForTimeOut+0x74>)
  403838:	4798      	blx	r3
	configASSERT( pxTicksToWait );
  40383a:	b924      	cbnz	r4, 403846 <xTaskCheckForTimeOut+0x1e>
  40383c:	4816      	ldr	r0, [pc, #88]	; (403898 <xTaskCheckForTimeOut+0x70>)
  40383e:	f240 71e2 	movw	r1, #2018	; 0x7e2
  403842:	4b16      	ldr	r3, [pc, #88]	; (40389c <xTaskCheckForTimeOut+0x74>)
  403844:	4798      	blx	r3

	taskENTER_CRITICAL();
  403846:	4b16      	ldr	r3, [pc, #88]	; (4038a0 <xTaskCheckForTimeOut+0x78>)
  403848:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  40384a:	6823      	ldr	r3, [r4, #0]
  40384c:	f1b3 3fff 	cmp.w	r3, #4294967295
  403850:	d019      	beq.n	403886 <xTaskCheckForTimeOut+0x5e>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  403852:	4a14      	ldr	r2, [pc, #80]	; (4038a4 <xTaskCheckForTimeOut+0x7c>)
  403854:	6812      	ldr	r2, [r2, #0]
  403856:	6829      	ldr	r1, [r5, #0]
  403858:	4291      	cmp	r1, r2
  40385a:	d004      	beq.n	403866 <xTaskCheckForTimeOut+0x3e>
  40385c:	4a12      	ldr	r2, [pc, #72]	; (4038a8 <xTaskCheckForTimeOut+0x80>)
  40385e:	6812      	ldr	r2, [r2, #0]
  403860:	6869      	ldr	r1, [r5, #4]
  403862:	4291      	cmp	r1, r2
  403864:	d911      	bls.n	40388a <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  403866:	4a10      	ldr	r2, [pc, #64]	; (4038a8 <xTaskCheckForTimeOut+0x80>)
  403868:	6812      	ldr	r2, [r2, #0]
  40386a:	6869      	ldr	r1, [r5, #4]
  40386c:	1a52      	subs	r2, r2, r1
  40386e:	4293      	cmp	r3, r2
  403870:	d90d      	bls.n	40388e <xTaskCheckForTimeOut+0x66>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  403872:	4a0d      	ldr	r2, [pc, #52]	; (4038a8 <xTaskCheckForTimeOut+0x80>)
  403874:	6812      	ldr	r2, [r2, #0]
  403876:	1a51      	subs	r1, r2, r1
  403878:	1a5b      	subs	r3, r3, r1
  40387a:	6023      	str	r3, [r4, #0]
			vTaskSetTimeOutState( pxTimeOut );
  40387c:	4628      	mov	r0, r5
  40387e:	4b0b      	ldr	r3, [pc, #44]	; (4038ac <xTaskCheckForTimeOut+0x84>)
  403880:	4798      	blx	r3
			xReturn = pdFALSE;
  403882:	2400      	movs	r4, #0
  403884:	e004      	b.n	403890 <xTaskCheckForTimeOut+0x68>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  403886:	2400      	movs	r4, #0
  403888:	e002      	b.n	403890 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  40388a:	2401      	movs	r4, #1
  40388c:	e000      	b.n	403890 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
  40388e:	2401      	movs	r4, #1
		}
	}
	taskEXIT_CRITICAL();
  403890:	4b07      	ldr	r3, [pc, #28]	; (4038b0 <xTaskCheckForTimeOut+0x88>)
  403892:	4798      	blx	r3

	return xReturn;
}
  403894:	4620      	mov	r0, r4
  403896:	bd38      	pop	{r3, r4, r5, pc}
  403898:	0040ab40 	.word	0x0040ab40
  40389c:	004041a5 	.word	0x004041a5
  4038a0:	00402325 	.word	0x00402325
  4038a4:	2000514c 	.word	0x2000514c
  4038a8:	20004ffc 	.word	0x20004ffc
  4038ac:	004037f9 	.word	0x004037f9
  4038b0:	00402345 	.word	0x00402345

004038b4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  4038b4:	2201      	movs	r2, #1
  4038b6:	4b01      	ldr	r3, [pc, #4]	; (4038bc <vTaskMissedYield+0x8>)
  4038b8:	601a      	str	r2, [r3, #0]
  4038ba:	4770      	bx	lr
  4038bc:	2000509c 	.word	0x2000509c

004038c0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  4038c0:	4b01      	ldr	r3, [pc, #4]	; (4038c8 <xTaskGetCurrentTaskHandle+0x8>)
  4038c2:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  4038c4:	4770      	bx	lr
  4038c6:	bf00      	nop
  4038c8:	200050a4 	.word	0x200050a4

004038cc <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  4038cc:	4b05      	ldr	r3, [pc, #20]	; (4038e4 <xTaskGetSchedulerState+0x18>)
  4038ce:	681b      	ldr	r3, [r3, #0]
  4038d0:	b133      	cbz	r3, 4038e0 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4038d2:	4b05      	ldr	r3, [pc, #20]	; (4038e8 <xTaskGetSchedulerState+0x1c>)
  4038d4:	681b      	ldr	r3, [r3, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  4038d6:	2b00      	cmp	r3, #0
  4038d8:	bf0c      	ite	eq
  4038da:	2001      	moveq	r0, #1
  4038dc:	2002      	movne	r0, #2
  4038de:	4770      	bx	lr
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  4038e0:	2000      	movs	r0, #0
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
  4038e2:	4770      	bx	lr
  4038e4:	20005094 	.word	0x20005094
  4038e8:	20005144 	.word	0x20005144

004038ec <vTaskPriorityInherit>:
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
  4038ec:	2800      	cmp	r0, #0
  4038ee:	d040      	beq.n	403972 <vTaskPriorityInherit+0x86>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4038f0:	b538      	push	{r3, r4, r5, lr}

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4038f2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  4038f4:	491f      	ldr	r1, [pc, #124]	; (403974 <vTaskPriorityInherit+0x88>)
  4038f6:	6809      	ldr	r1, [r1, #0]
  4038f8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  4038fa:	428b      	cmp	r3, r1
  4038fc:	d238      	bcs.n	403970 <vTaskPriorityInherit+0x84>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4038fe:	491d      	ldr	r1, [pc, #116]	; (403974 <vTaskPriorityInherit+0x88>)
  403900:	6809      	ldr	r1, [r1, #0]
  403902:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  403904:	f1c1 0105 	rsb	r1, r1, #5
  403908:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
  40390a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40390e:	491a      	ldr	r1, [pc, #104]	; (403978 <vTaskPriorityInherit+0x8c>)
  403910:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  403914:	6941      	ldr	r1, [r0, #20]
  403916:	4299      	cmp	r1, r3
  403918:	d126      	bne.n	403968 <vTaskPriorityInherit+0x7c>
  40391a:	4604      	mov	r4, r0
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  40391c:	1d05      	adds	r5, r0, #4
  40391e:	4628      	mov	r0, r5
  403920:	4b16      	ldr	r3, [pc, #88]	; (40397c <vTaskPriorityInherit+0x90>)
  403922:	4798      	blx	r3
  403924:	b968      	cbnz	r0, 403942 <vTaskPriorityInherit+0x56>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  403926:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  403928:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  40392c:	009b      	lsls	r3, r3, #2
  40392e:	4912      	ldr	r1, [pc, #72]	; (403978 <vTaskPriorityInherit+0x8c>)
  403930:	58cb      	ldr	r3, [r1, r3]
  403932:	b933      	cbnz	r3, 403942 <vTaskPriorityInherit+0x56>
  403934:	4812      	ldr	r0, [pc, #72]	; (403980 <vTaskPriorityInherit+0x94>)
  403936:	6801      	ldr	r1, [r0, #0]
  403938:	2301      	movs	r3, #1
  40393a:	4093      	lsls	r3, r2
  40393c:	ea21 0303 	bic.w	r3, r1, r3
  403940:	6003      	str	r3, [r0, #0]
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403942:	4b0c      	ldr	r3, [pc, #48]	; (403974 <vTaskPriorityInherit+0x88>)
  403944:	681b      	ldr	r3, [r3, #0]
  403946:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  403948:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
  40394a:	490d      	ldr	r1, [pc, #52]	; (403980 <vTaskPriorityInherit+0x94>)
  40394c:	680a      	ldr	r2, [r1, #0]
  40394e:	2301      	movs	r3, #1
  403950:	4083      	lsls	r3, r0
  403952:	4313      	orrs	r3, r2
  403954:	600b      	str	r3, [r1, #0]
  403956:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40395a:	4b07      	ldr	r3, [pc, #28]	; (403978 <vTaskPriorityInherit+0x8c>)
  40395c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  403960:	4629      	mov	r1, r5
  403962:	4b08      	ldr	r3, [pc, #32]	; (403984 <vTaskPriorityInherit+0x98>)
  403964:	4798      	blx	r3
  403966:	bd38      	pop	{r3, r4, r5, pc}
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  403968:	4b02      	ldr	r3, [pc, #8]	; (403974 <vTaskPriorityInherit+0x88>)
  40396a:	681b      	ldr	r3, [r3, #0]
  40396c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40396e:	62c3      	str	r3, [r0, #44]	; 0x2c
  403970:	bd38      	pop	{r3, r4, r5, pc}
  403972:	4770      	bx	lr
  403974:	200050a4 	.word	0x200050a4
  403978:	20005000 	.word	0x20005000
  40397c:	00402275 	.word	0x00402275
  403980:	20004ff4 	.word	0x20004ff4
  403984:	0040221d 	.word	0x0040221d

00403988 <vTaskPriorityDisinherit>:

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  403988:	2800      	cmp	r0, #0
  40398a:	d02c      	beq.n	4039e6 <vTaskPriorityDisinherit+0x5e>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  40398c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  40398e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  403990:	6c82      	ldr	r2, [r0, #72]	; 0x48
  403992:	4291      	cmp	r1, r2
  403994:	d026      	beq.n	4039e4 <vTaskPriorityDisinherit+0x5c>
  403996:	4604      	mov	r4, r0
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
  403998:	1d05      	adds	r5, r0, #4
  40399a:	4628      	mov	r0, r5
  40399c:	4b12      	ldr	r3, [pc, #72]	; (4039e8 <vTaskPriorityDisinherit+0x60>)
  40399e:	4798      	blx	r3
  4039a0:	b968      	cbnz	r0, 4039be <vTaskPriorityDisinherit+0x36>
				{
					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  4039a2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4039a4:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  4039a8:	009b      	lsls	r3, r3, #2
  4039aa:	4910      	ldr	r1, [pc, #64]	; (4039ec <vTaskPriorityDisinherit+0x64>)
  4039ac:	58cb      	ldr	r3, [r1, r3]
  4039ae:	b933      	cbnz	r3, 4039be <vTaskPriorityDisinherit+0x36>
  4039b0:	480f      	ldr	r0, [pc, #60]	; (4039f0 <vTaskPriorityDisinherit+0x68>)
  4039b2:	6801      	ldr	r1, [r0, #0]
  4039b4:	2301      	movs	r3, #1
  4039b6:	4093      	lsls	r3, r2
  4039b8:	ea21 0303 	bic.w	r3, r1, r3
  4039bc:	6003      	str	r3, [r0, #0]
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  4039be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4039c0:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  4039c2:	f1c3 0205 	rsb	r2, r3, #5
  4039c6:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  4039c8:	4809      	ldr	r0, [pc, #36]	; (4039f0 <vTaskPriorityDisinherit+0x68>)
  4039ca:	6801      	ldr	r1, [r0, #0]
  4039cc:	2201      	movs	r2, #1
  4039ce:	409a      	lsls	r2, r3
  4039d0:	430a      	orrs	r2, r1
  4039d2:	6002      	str	r2, [r0, #0]
  4039d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4039d8:	4804      	ldr	r0, [pc, #16]	; (4039ec <vTaskPriorityDisinherit+0x64>)
  4039da:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  4039de:	4629      	mov	r1, r5
  4039e0:	4b04      	ldr	r3, [pc, #16]	; (4039f4 <vTaskPriorityDisinherit+0x6c>)
  4039e2:	4798      	blx	r3
  4039e4:	bd38      	pop	{r3, r4, r5, pc}
  4039e6:	4770      	bx	lr
  4039e8:	00402275 	.word	0x00402275
  4039ec:	20005000 	.word	0x20005000
  4039f0:	20004ff4 	.word	0x20004ff4
  4039f4:	0040221d 	.word	0x0040221d

004039f8 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  4039f8:	b510      	push	{r4, lr}
  4039fa:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  4039fc:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  4039fe:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
  403a00:	4291      	cmp	r1, r2
  403a02:	d80a      	bhi.n	403a1a <prvInsertTimerInActiveList+0x22>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
  403a04:	1ad2      	subs	r2, r2, r3
  403a06:	6983      	ldr	r3, [r0, #24]
  403a08:	429a      	cmp	r2, r3
  403a0a:	d211      	bcs.n	403a30 <prvInsertTimerInActiveList+0x38>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  403a0c:	4b0a      	ldr	r3, [pc, #40]	; (403a38 <prvInsertTimerInActiveList+0x40>)
  403a0e:	6818      	ldr	r0, [r3, #0]
  403a10:	1d21      	adds	r1, r4, #4
  403a12:	4b0a      	ldr	r3, [pc, #40]	; (403a3c <prvInsertTimerInActiveList+0x44>)
  403a14:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  403a16:	2000      	movs	r0, #0
  403a18:	bd10      	pop	{r4, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  403a1a:	429a      	cmp	r2, r3
  403a1c:	d201      	bcs.n	403a22 <prvInsertTimerInActiveList+0x2a>
  403a1e:	4299      	cmp	r1, r3
  403a20:	d208      	bcs.n	403a34 <prvInsertTimerInActiveList+0x3c>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  403a22:	4b07      	ldr	r3, [pc, #28]	; (403a40 <prvInsertTimerInActiveList+0x48>)
  403a24:	6818      	ldr	r0, [r3, #0]
  403a26:	1d21      	adds	r1, r4, #4
  403a28:	4b04      	ldr	r3, [pc, #16]	; (403a3c <prvInsertTimerInActiveList+0x44>)
  403a2a:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  403a2c:	2000      	movs	r0, #0
  403a2e:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  403a30:	2001      	movs	r0, #1
  403a32:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  403a34:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
  403a36:	bd10      	pop	{r4, pc}
  403a38:	20005188 	.word	0x20005188
  403a3c:	00402239 	.word	0x00402239
  403a40:	20005154 	.word	0x20005154

00403a44 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  403a44:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  403a46:	4b0d      	ldr	r3, [pc, #52]	; (403a7c <prvCheckForValidListAndQueue+0x38>)
  403a48:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  403a4a:	4b0d      	ldr	r3, [pc, #52]	; (403a80 <prvCheckForValidListAndQueue+0x3c>)
  403a4c:	681b      	ldr	r3, [r3, #0]
  403a4e:	b98b      	cbnz	r3, 403a74 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
  403a50:	4d0c      	ldr	r5, [pc, #48]	; (403a84 <prvCheckForValidListAndQueue+0x40>)
  403a52:	4628      	mov	r0, r5
  403a54:	4e0c      	ldr	r6, [pc, #48]	; (403a88 <prvCheckForValidListAndQueue+0x44>)
  403a56:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
  403a58:	4c0c      	ldr	r4, [pc, #48]	; (403a8c <prvCheckForValidListAndQueue+0x48>)
  403a5a:	4620      	mov	r0, r4
  403a5c:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
  403a5e:	4b0c      	ldr	r3, [pc, #48]	; (403a90 <prvCheckForValidListAndQueue+0x4c>)
  403a60:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  403a62:	4b0c      	ldr	r3, [pc, #48]	; (403a94 <prvCheckForValidListAndQueue+0x50>)
  403a64:	601c      	str	r4, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  403a66:	2005      	movs	r0, #5
  403a68:	210c      	movs	r1, #12
  403a6a:	2200      	movs	r2, #0
  403a6c:	4b0a      	ldr	r3, [pc, #40]	; (403a98 <prvCheckForValidListAndQueue+0x54>)
  403a6e:	4798      	blx	r3
  403a70:	4b03      	ldr	r3, [pc, #12]	; (403a80 <prvCheckForValidListAndQueue+0x3c>)
  403a72:	6018      	str	r0, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
  403a74:	4b09      	ldr	r3, [pc, #36]	; (403a9c <prvCheckForValidListAndQueue+0x58>)
  403a76:	4798      	blx	r3
  403a78:	bd70      	pop	{r4, r5, r6, pc}
  403a7a:	bf00      	nop
  403a7c:	00402325 	.word	0x00402325
  403a80:	20005184 	.word	0x20005184
  403a84:	20005158 	.word	0x20005158
  403a88:	004021fd 	.word	0x004021fd
  403a8c:	2000516c 	.word	0x2000516c
  403a90:	20005154 	.word	0x20005154
  403a94:	20005188 	.word	0x20005188
  403a98:	00402745 	.word	0x00402745
  403a9c:	00402345 	.word	0x00402345

00403aa0 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  403aa0:	b510      	push	{r4, lr}
  403aa2:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  403aa4:	4b0d      	ldr	r3, [pc, #52]	; (403adc <xTimerCreateTimerTask+0x3c>)
  403aa6:	4798      	blx	r3

	if( xTimerQueue != NULL )
  403aa8:	4b0d      	ldr	r3, [pc, #52]	; (403ae0 <xTimerCreateTimerTask+0x40>)
  403aaa:	681b      	ldr	r3, [r3, #0]
  403aac:	b16b      	cbz	r3, 403aca <xTimerCreateTimerTask+0x2a>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
  403aae:	2304      	movs	r3, #4
  403ab0:	9300      	str	r3, [sp, #0]
  403ab2:	2300      	movs	r3, #0
  403ab4:	9301      	str	r3, [sp, #4]
  403ab6:	9302      	str	r3, [sp, #8]
  403ab8:	9303      	str	r3, [sp, #12]
  403aba:	480a      	ldr	r0, [pc, #40]	; (403ae4 <xTimerCreateTimerTask+0x44>)
  403abc:	490a      	ldr	r1, [pc, #40]	; (403ae8 <xTimerCreateTimerTask+0x48>)
  403abe:	f44f 72a0 	mov.w	r2, #320	; 0x140
  403ac2:	4c0a      	ldr	r4, [pc, #40]	; (403aec <xTimerCreateTimerTask+0x4c>)
  403ac4:	47a0      	blx	r4
		}
		#endif
	}

	configASSERT( xReturn );
  403ac6:	4603      	mov	r3, r0
  403ac8:	b920      	cbnz	r0, 403ad4 <xTimerCreateTimerTask+0x34>
  403aca:	4809      	ldr	r0, [pc, #36]	; (403af0 <xTimerCreateTimerTask+0x50>)
  403acc:	21d7      	movs	r1, #215	; 0xd7
  403ace:	4b09      	ldr	r3, [pc, #36]	; (403af4 <xTimerCreateTimerTask+0x54>)
  403ad0:	4798      	blx	r3
  403ad2:	2300      	movs	r3, #0
	return xReturn;
}
  403ad4:	4618      	mov	r0, r3
  403ad6:	b004      	add	sp, #16
  403ad8:	bd10      	pop	{r4, pc}
  403ada:	bf00      	nop
  403adc:	00403a45 	.word	0x00403a45
  403ae0:	20005184 	.word	0x20005184
  403ae4:	00403c61 	.word	0x00403c61
  403ae8:	0040ab88 	.word	0x0040ab88
  403aec:	00402d4d 	.word	0x00402d4d
  403af0:	0040ab90 	.word	0x0040ab90
  403af4:	004041a5 	.word	0x004041a5

00403af8 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
  403af8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
  403afc:	b929      	cbnz	r1, 403b0a <xTimerCreate+0x12>
	{
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
  403afe:	480f      	ldr	r0, [pc, #60]	; (403b3c <xTimerCreate+0x44>)
  403b00:	21e4      	movs	r1, #228	; 0xe4
  403b02:	4b0f      	ldr	r3, [pc, #60]	; (403b40 <xTimerCreate+0x48>)
  403b04:	4798      	blx	r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
	{
		pxNewTimer = NULL;
  403b06:	2400      	movs	r4, #0
  403b08:	e014      	b.n	403b34 <xTimerCreate+0x3c>
  403b0a:	4680      	mov	r8, r0
  403b0c:	4616      	mov	r6, r2
  403b0e:	461d      	mov	r5, r3
  403b10:	460f      	mov	r7, r1
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
  403b12:	2028      	movs	r0, #40	; 0x28
  403b14:	4b0b      	ldr	r3, [pc, #44]	; (403b44 <xTimerCreate+0x4c>)
  403b16:	4798      	blx	r3
		if( pxNewTimer != NULL )
  403b18:	4604      	mov	r4, r0
  403b1a:	b158      	cbz	r0, 403b34 <xTimerCreate+0x3c>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
  403b1c:	4b0a      	ldr	r3, [pc, #40]	; (403b48 <xTimerCreate+0x50>)
  403b1e:	4798      	blx	r3

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
  403b20:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
  403b24:	61a7      	str	r7, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
  403b26:	61e6      	str	r6, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
  403b28:	6225      	str	r5, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
  403b2a:	9b06      	ldr	r3, [sp, #24]
  403b2c:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
  403b2e:	1d20      	adds	r0, r4, #4
  403b30:	4b06      	ldr	r3, [pc, #24]	; (403b4c <xTimerCreate+0x54>)
  403b32:	4798      	blx	r3
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
  403b34:	4620      	mov	r0, r4
  403b36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403b3a:	bf00      	nop
  403b3c:	0040ab90 	.word	0x0040ab90
  403b40:	004041a5 	.word	0x004041a5
  403b44:	00402499 	.word	0x00402499
  403b48:	00403a45 	.word	0x00403a45
  403b4c:	00402215 	.word	0x00402215

00403b50 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  403b50:	b530      	push	{r4, r5, lr}
  403b52:	b085      	sub	sp, #20
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  403b54:	4c0f      	ldr	r4, [pc, #60]	; (403b94 <xTimerGenericCommand+0x44>)
  403b56:	6825      	ldr	r5, [r4, #0]
  403b58:	b1c5      	cbz	r5, 403b8c <xTimerGenericCommand+0x3c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  403b5a:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
  403b5c:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  403b5e:	9003      	str	r0, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
  403b60:	b96b      	cbnz	r3, 403b7e <xTimerGenericCommand+0x2e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  403b62:	4b0d      	ldr	r3, [pc, #52]	; (403b98 <xTimerGenericCommand+0x48>)
  403b64:	4798      	blx	r3
  403b66:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  403b68:	4b0a      	ldr	r3, [pc, #40]	; (403b94 <xTimerGenericCommand+0x44>)
  403b6a:	6818      	ldr	r0, [r3, #0]
  403b6c:	a901      	add	r1, sp, #4
  403b6e:	bf07      	ittee	eq
  403b70:	9a08      	ldreq	r2, [sp, #32]
  403b72:	2300      	moveq	r3, #0
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  403b74:	2200      	movne	r2, #0
  403b76:	4613      	movne	r3, r2
  403b78:	4c08      	ldr	r4, [pc, #32]	; (403b9c <xTimerGenericCommand+0x4c>)
  403b7a:	47a0      	blx	r4
  403b7c:	e007      	b.n	403b8e <xTimerGenericCommand+0x3e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  403b7e:	4628      	mov	r0, r5
  403b80:	a901      	add	r1, sp, #4
  403b82:	461a      	mov	r2, r3
  403b84:	2300      	movs	r3, #0
  403b86:	4c06      	ldr	r4, [pc, #24]	; (403ba0 <xTimerGenericCommand+0x50>)
  403b88:	47a0      	blx	r4
  403b8a:	e000      	b.n	403b8e <xTimerGenericCommand+0x3e>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
  403b8c:	2000      	movs	r0, #0

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
  403b8e:	b005      	add	sp, #20
  403b90:	bd30      	pop	{r4, r5, pc}
  403b92:	bf00      	nop
  403b94:	20005184 	.word	0x20005184
  403b98:	004038cd 	.word	0x004038cd
  403b9c:	004027d5 	.word	0x004027d5
  403ba0:	0040296d 	.word	0x0040296d

00403ba4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
  403ba4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  403ba8:	b082      	sub	sp, #8
  403baa:	4681      	mov	r9, r0
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  403bac:	4b23      	ldr	r3, [pc, #140]	; (403c3c <prvSampleTimeNow+0x98>)
  403bae:	4798      	blx	r3
  403bb0:	4680      	mov	r8, r0

	if( xTimeNow < xLastTime )
  403bb2:	4b23      	ldr	r3, [pc, #140]	; (403c40 <prvSampleTimeNow+0x9c>)
  403bb4:	681b      	ldr	r3, [r3, #0]
  403bb6:	4298      	cmp	r0, r3
  403bb8:	d236      	bcs.n	403c28 <prvSampleTimeNow+0x84>
  403bba:	e026      	b.n	403c0a <prvSampleTimeNow+0x66>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  403bbc:	68da      	ldr	r2, [r3, #12]
  403bbe:	f8d2 a000 	ldr.w	sl, [r2]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  403bc2:	68db      	ldr	r3, [r3, #12]
  403bc4:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
  403bc6:	1d25      	adds	r5, r4, #4
  403bc8:	4628      	mov	r0, r5
  403bca:	47b8      	blx	r7

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  403bcc:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403bce:	4620      	mov	r0, r4
  403bd0:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  403bd2:	69e3      	ldr	r3, [r4, #28]
  403bd4:	2b01      	cmp	r3, #1
  403bd6:	d11a      	bne.n	403c0e <prvSampleTimeNow+0x6a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  403bd8:	69a3      	ldr	r3, [r4, #24]
  403bda:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
  403bdc:	4553      	cmp	r3, sl
  403bde:	d906      	bls.n	403bee <prvSampleTimeNow+0x4a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  403be0:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  403be2:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  403be4:	6830      	ldr	r0, [r6, #0]
  403be6:	4629      	mov	r1, r5
  403be8:	4b16      	ldr	r3, [pc, #88]	; (403c44 <prvSampleTimeNow+0xa0>)
  403bea:	4798      	blx	r3
  403bec:	e00f      	b.n	403c0e <prvSampleTimeNow+0x6a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  403bee:	2300      	movs	r3, #0
  403bf0:	9300      	str	r3, [sp, #0]
  403bf2:	4620      	mov	r0, r4
  403bf4:	4619      	mov	r1, r3
  403bf6:	4652      	mov	r2, sl
  403bf8:	4c13      	ldr	r4, [pc, #76]	; (403c48 <prvSampleTimeNow+0xa4>)
  403bfa:	47a0      	blx	r4
				configASSERT( xResult );
  403bfc:	b938      	cbnz	r0, 403c0e <prvSampleTimeNow+0x6a>
  403bfe:	4813      	ldr	r0, [pc, #76]	; (403c4c <prvSampleTimeNow+0xa8>)
  403c00:	f240 2172 	movw	r1, #626	; 0x272
  403c04:	4b12      	ldr	r3, [pc, #72]	; (403c50 <prvSampleTimeNow+0xac>)
  403c06:	4798      	blx	r3
  403c08:	e001      	b.n	403c0e <prvSampleTimeNow+0x6a>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  403c0a:	4e12      	ldr	r6, [pc, #72]	; (403c54 <prvSampleTimeNow+0xb0>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		uxListRemove( &( pxTimer->xTimerListItem ) );
  403c0c:	4f12      	ldr	r7, [pc, #72]	; (403c58 <prvSampleTimeNow+0xb4>)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  403c0e:	6833      	ldr	r3, [r6, #0]
  403c10:	681a      	ldr	r2, [r3, #0]
  403c12:	2a00      	cmp	r2, #0
  403c14:	d1d2      	bne.n	403bbc <prvSampleTimeNow+0x18>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
  403c16:	4a11      	ldr	r2, [pc, #68]	; (403c5c <prvSampleTimeNow+0xb8>)
  403c18:	6810      	ldr	r0, [r2, #0]
  403c1a:	490e      	ldr	r1, [pc, #56]	; (403c54 <prvSampleTimeNow+0xb0>)
  403c1c:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  403c1e:	6013      	str	r3, [r2, #0]
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
  403c20:	2301      	movs	r3, #1
  403c22:	f8c9 3000 	str.w	r3, [r9]
  403c26:	e002      	b.n	403c2e <prvSampleTimeNow+0x8a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
  403c28:	2300      	movs	r3, #0
  403c2a:	f8c9 3000 	str.w	r3, [r9]
	}

	xLastTime = xTimeNow;
  403c2e:	4b04      	ldr	r3, [pc, #16]	; (403c40 <prvSampleTimeNow+0x9c>)
  403c30:	f8c3 8000 	str.w	r8, [r3]

	return xTimeNow;
}
  403c34:	4640      	mov	r0, r8
  403c36:	b002      	add	sp, #8
  403c38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403c3c:	00403085 	.word	0x00403085
  403c40:	20005180 	.word	0x20005180
  403c44:	00402239 	.word	0x00402239
  403c48:	00403b51 	.word	0x00403b51
  403c4c:	0040ab90 	.word	0x0040ab90
  403c50:	004041a5 	.word	0x004041a5
  403c54:	20005154 	.word	0x20005154
  403c58:	00402275 	.word	0x00402275
  403c5c:	20005188 	.word	0x20005188

00403c60 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  403c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403c64:	b087      	sub	sp, #28
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  403c66:	f8df a16c 	ldr.w	sl, [pc, #364]	; 403dd4 <prvTimerTask+0x174>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  403c6a:	f8df b16c 	ldr.w	fp, [pc, #364]	; 403dd8 <prvTimerTask+0x178>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  403c6e:	4e4e      	ldr	r6, [pc, #312]	; (403da8 <prvTimerTask+0x148>)
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
	uxListRemove( &( pxTimer->xTimerListItem ) );
  403c70:	f8df 8168 	ldr.w	r8, [pc, #360]	; 403ddc <prvTimerTask+0x17c>
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  403c74:	f8da 3000 	ldr.w	r3, [sl]
  403c78:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
  403c7a:	2a00      	cmp	r2, #0
  403c7c:	f000 808b 	beq.w	403d96 <prvTimerTask+0x136>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  403c80:	68db      	ldr	r3, [r3, #12]
  403c82:	681d      	ldr	r5, [r3, #0]
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  403c84:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  403c86:	a803      	add	r0, sp, #12
  403c88:	4b48      	ldr	r3, [pc, #288]	; (403dac <prvTimerTask+0x14c>)
  403c8a:	4798      	blx	r3
  403c8c:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
  403c8e:	9b03      	ldr	r3, [sp, #12]
  403c90:	2b00      	cmp	r3, #0
  403c92:	d131      	bne.n	403cf8 <prvTimerTask+0x98>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  403c94:	4285      	cmp	r5, r0
  403c96:	d825      	bhi.n	403ce4 <prvTimerTask+0x84>
			{
				xTaskResumeAll();
  403c98:	4b45      	ldr	r3, [pc, #276]	; (403db0 <prvTimerTask+0x150>)
  403c9a:	4798      	blx	r3
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  403c9c:	f8da 3000 	ldr.w	r3, [sl]
  403ca0:	68db      	ldr	r3, [r3, #12]
  403ca2:	68df      	ldr	r7, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
  403ca4:	1d38      	adds	r0, r7, #4
  403ca6:	47c0      	blx	r8
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  403ca8:	69fb      	ldr	r3, [r7, #28]
  403caa:	2b01      	cmp	r3, #1
  403cac:	d115      	bne.n	403cda <prvTimerTask+0x7a>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  403cae:	69b9      	ldr	r1, [r7, #24]
  403cb0:	4638      	mov	r0, r7
  403cb2:	4429      	add	r1, r5
  403cb4:	4622      	mov	r2, r4
  403cb6:	462b      	mov	r3, r5
  403cb8:	4c3e      	ldr	r4, [pc, #248]	; (403db4 <prvTimerTask+0x154>)
  403cba:	47a0      	blx	r4
  403cbc:	2801      	cmp	r0, #1
  403cbe:	d10c      	bne.n	403cda <prvTimerTask+0x7a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  403cc0:	2300      	movs	r3, #0
  403cc2:	9300      	str	r3, [sp, #0]
  403cc4:	4638      	mov	r0, r7
  403cc6:	4619      	mov	r1, r3
  403cc8:	462a      	mov	r2, r5
  403cca:	4c3b      	ldr	r4, [pc, #236]	; (403db8 <prvTimerTask+0x158>)
  403ccc:	47a0      	blx	r4
			configASSERT( xResult );
  403cce:	b920      	cbnz	r0, 403cda <prvTimerTask+0x7a>
  403cd0:	483a      	ldr	r0, [pc, #232]	; (403dbc <prvTimerTask+0x15c>)
  403cd2:	f240 114f 	movw	r1, #335	; 0x14f
  403cd6:	4b3a      	ldr	r3, [pc, #232]	; (403dc0 <prvTimerTask+0x160>)
  403cd8:	4798      	blx	r3
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  403cda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403cdc:	4638      	mov	r0, r7
  403cde:	4798      	blx	r3
  403ce0:	e00c      	b.n	403cfc <prvTimerTask+0x9c>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  403ce2:	2500      	movs	r5, #0
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  403ce4:	6830      	ldr	r0, [r6, #0]
  403ce6:	1b29      	subs	r1, r5, r4
  403ce8:	4b36      	ldr	r3, [pc, #216]	; (403dc4 <prvTimerTask+0x164>)
  403cea:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
  403cec:	4b30      	ldr	r3, [pc, #192]	; (403db0 <prvTimerTask+0x150>)
  403cee:	4798      	blx	r3
  403cf0:	b920      	cbnz	r0, 403cfc <prvTimerTask+0x9c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  403cf2:	4b35      	ldr	r3, [pc, #212]	; (403dc8 <prvTimerTask+0x168>)
  403cf4:	4798      	blx	r3
  403cf6:	e001      	b.n	403cfc <prvTimerTask+0x9c>
				}
			}
		}
		else
		{
			xTaskResumeAll();
  403cf8:	4b2d      	ldr	r3, [pc, #180]	; (403db0 <prvTimerTask+0x150>)
  403cfa:	4798      	blx	r3
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  403cfc:	a802      	add	r0, sp, #8
  403cfe:	4b2b      	ldr	r3, [pc, #172]	; (403dac <prvTimerTask+0x14c>)
  403d00:	4798      	blx	r3
  403d02:	4607      	mov	r7, r0

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  403d04:	4d31      	ldr	r5, [pc, #196]	; (403dcc <prvTimerTask+0x16c>)
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  403d06:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 403db4 <prvTimerTask+0x154>
  403d0a:	e03c      	b.n	403d86 <prvTimerTask+0x126>
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
  403d0c:	9c05      	ldr	r4, [sp, #20]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
  403d0e:	b11c      	cbz	r4, 403d18 <prvTimerTask+0xb8>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  403d10:	6963      	ldr	r3, [r4, #20]
  403d12:	b10b      	cbz	r3, 403d18 <prvTimerTask+0xb8>
			{
				/* The timer is in a list, remove it. */
				uxListRemove( &( pxTimer->xTimerListItem ) );
  403d14:	1d20      	adds	r0, r4, #4
  403d16:	47c0      	blx	r8
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
  403d18:	9b03      	ldr	r3, [sp, #12]
  403d1a:	2b02      	cmp	r3, #2
  403d1c:	d021      	beq.n	403d62 <prvTimerTask+0x102>
  403d1e:	2b03      	cmp	r3, #3
  403d20:	d02e      	beq.n	403d80 <prvTimerTask+0x120>
  403d22:	2b00      	cmp	r3, #0
  403d24:	d12f      	bne.n	403d86 <prvTimerTask+0x126>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  403d26:	9b04      	ldr	r3, [sp, #16]
  403d28:	69a1      	ldr	r1, [r4, #24]
  403d2a:	4620      	mov	r0, r4
  403d2c:	4419      	add	r1, r3
  403d2e:	463a      	mov	r2, r7
  403d30:	47c8      	blx	r9
  403d32:	2801      	cmp	r0, #1
  403d34:	d127      	bne.n	403d86 <prvTimerTask+0x126>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  403d36:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403d38:	4620      	mov	r0, r4
  403d3a:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  403d3c:	69e3      	ldr	r3, [r4, #28]
  403d3e:	2b01      	cmp	r3, #1
  403d40:	d121      	bne.n	403d86 <prvTimerTask+0x126>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  403d42:	69a2      	ldr	r2, [r4, #24]
  403d44:	2300      	movs	r3, #0
  403d46:	9300      	str	r3, [sp, #0]
  403d48:	4620      	mov	r0, r4
  403d4a:	4619      	mov	r1, r3
  403d4c:	9c04      	ldr	r4, [sp, #16]
  403d4e:	4422      	add	r2, r4
  403d50:	4c19      	ldr	r4, [pc, #100]	; (403db8 <prvTimerTask+0x158>)
  403d52:	47a0      	blx	r4
						configASSERT( xResult );
  403d54:	b9b8      	cbnz	r0, 403d86 <prvTimerTask+0x126>
  403d56:	4819      	ldr	r0, [pc, #100]	; (403dbc <prvTimerTask+0x15c>)
  403d58:	f240 2126 	movw	r1, #550	; 0x226
  403d5c:	4b18      	ldr	r3, [pc, #96]	; (403dc0 <prvTimerTask+0x160>)
  403d5e:	4798      	blx	r3
  403d60:	e011      	b.n	403d86 <prvTimerTask+0x126>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  403d62:	9b04      	ldr	r3, [sp, #16]
  403d64:	61a3      	str	r3, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  403d66:	b923      	cbnz	r3, 403d72 <prvTimerTask+0x112>
  403d68:	4814      	ldr	r0, [pc, #80]	; (403dbc <prvTimerTask+0x15c>)
  403d6a:	f240 2133 	movw	r1, #563	; 0x233
  403d6e:	4b14      	ldr	r3, [pc, #80]	; (403dc0 <prvTimerTask+0x160>)
  403d70:	4798      	blx	r3
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  403d72:	69a1      	ldr	r1, [r4, #24]
  403d74:	4620      	mov	r0, r4
  403d76:	4439      	add	r1, r7
  403d78:	463a      	mov	r2, r7
  403d7a:	463b      	mov	r3, r7
  403d7c:	47c8      	blx	r9
  403d7e:	e002      	b.n	403d86 <prvTimerTask+0x126>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  403d80:	4620      	mov	r0, r4
  403d82:	4b13      	ldr	r3, [pc, #76]	; (403dd0 <prvTimerTask+0x170>)
  403d84:	4798      	blx	r3

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  403d86:	6830      	ldr	r0, [r6, #0]
  403d88:	a903      	add	r1, sp, #12
  403d8a:	2200      	movs	r2, #0
  403d8c:	4613      	mov	r3, r2
  403d8e:	47a8      	blx	r5
  403d90:	2800      	cmp	r0, #0
  403d92:	d1bb      	bne.n	403d0c <prvTimerTask+0xac>
  403d94:	e76e      	b.n	403c74 <prvTimerTask+0x14>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  403d96:	47d8      	blx	fp
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
  403d98:	a803      	add	r0, sp, #12
  403d9a:	4b04      	ldr	r3, [pc, #16]	; (403dac <prvTimerTask+0x14c>)
  403d9c:	4798      	blx	r3
  403d9e:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
  403da0:	9b03      	ldr	r3, [sp, #12]
  403da2:	2b00      	cmp	r3, #0
  403da4:	d09d      	beq.n	403ce2 <prvTimerTask+0x82>
  403da6:	e7a7      	b.n	403cf8 <prvTimerTask+0x98>
  403da8:	20005184 	.word	0x20005184
  403dac:	00403ba5 	.word	0x00403ba5
  403db0:	004031f1 	.word	0x004031f1
  403db4:	004039f9 	.word	0x004039f9
  403db8:	00403b51 	.word	0x00403b51
  403dbc:	0040ab90 	.word	0x0040ab90
  403dc0:	004041a5 	.word	0x004041a5
  403dc4:	00402b6d 	.word	0x00402b6d
  403dc8:	00402305 	.word	0x00402305
  403dcc:	00402a09 	.word	0x00402a09
  403dd0:	0040256d 	.word	0x0040256d
  403dd4:	20005154 	.word	0x20005154
  403dd8:	00403075 	.word	0x00403075
  403ddc:	00402275 	.word	0x00402275

00403de0 <delete_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE delete_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403de0:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403de2:	4604      	mov	r4, r0
  403de4:	b920      	cbnz	r0, 403df0 <delete_task_command+0x10>
  403de6:	480f      	ldr	r0, [pc, #60]	; (403e24 <delete_task_command+0x44>)
  403de8:	f240 11b1 	movw	r1, #433	; 0x1b1
  403dec:	4b0e      	ldr	r3, [pc, #56]	; (403e28 <delete_task_command+0x48>)
  403dee:	4798      	blx	r3

	/* See if the task is running. */
	if (created_task_handle != NULL) {
  403df0:	4b0e      	ldr	r3, [pc, #56]	; (403e2c <delete_task_command+0x4c>)
  403df2:	6818      	ldr	r0, [r3, #0]
  403df4:	b170      	cbz	r0, 403e14 <delete_task_command+0x34>
		vTaskDelete(created_task_handle);
  403df6:	4b0e      	ldr	r3, [pc, #56]	; (403e30 <delete_task_command+0x50>)
  403df8:	4798      	blx	r3
		created_task_handle = NULL;
  403dfa:	2200      	movs	r2, #0
  403dfc:	4b0b      	ldr	r3, [pc, #44]	; (403e2c <delete_task_command+0x4c>)
  403dfe:	601a      	str	r2, [r3, #0]
		strcpy((char *) pcWriteBuffer, (const char *) success_message);
  403e00:	4b0c      	ldr	r3, [pc, #48]	; (403e34 <delete_task_command+0x54>)
  403e02:	cb07      	ldmia	r3!, {r0, r1, r2}
  403e04:	6020      	str	r0, [r4, #0]
  403e06:	6061      	str	r1, [r4, #4]
  403e08:	60a2      	str	r2, [r4, #8]
  403e0a:	881a      	ldrh	r2, [r3, #0]
  403e0c:	789b      	ldrb	r3, [r3, #2]
  403e0e:	81a2      	strh	r2, [r4, #12]
  403e10:	73a3      	strb	r3, [r4, #14]
  403e12:	e004      	b.n	403e1e <delete_task_command+0x3e>
	} else {
		strcpy((char *) pcWriteBuffer, (const char *) failure_message);
  403e14:	4620      	mov	r0, r4
  403e16:	4908      	ldr	r1, [pc, #32]	; (403e38 <delete_task_command+0x58>)
  403e18:	2244      	movs	r2, #68	; 0x44
  403e1a:	4b08      	ldr	r3, [pc, #32]	; (403e3c <delete_task_command+0x5c>)
  403e1c:	4798      	blx	r3
	}

	/* There is no more data to return after this single string, so return
	 * pdFALSE. */
	return pdFALSE;
}
  403e1e:	2000      	movs	r0, #0
  403e20:	bd10      	pop	{r4, pc}
  403e22:	bf00      	nop
  403e24:	0040ac10 	.word	0x0040ac10
  403e28:	004041a5 	.word	0x004041a5
  403e2c:	2000518c 	.word	0x2000518c
  403e30:	00402f51 	.word	0x00402f51
  403e34:	0040ac34 	.word	0x0040ac34
  403e38:	0040ac44 	.word	0x0040ac44
  403e3c:	004044ed 	.word	0x004044ed

00403e40 <create_task_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE create_task_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403e40:	b530      	push	{r4, r5, lr}
  403e42:	b087      	sub	sp, #28
  403e44:	4615      	mov	r5, r2

	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403e46:	4604      	mov	r4, r0
  403e48:	b920      	cbnz	r0, 403e54 <create_task_command+0x14>
  403e4a:	481d      	ldr	r0, [pc, #116]	; (403ec0 <create_task_command+0x80>)
  403e4c:	f240 1181 	movw	r1, #385	; 0x181
  403e50:	4b1c      	ldr	r3, [pc, #112]	; (403ec4 <create_task_command+0x84>)
  403e52:	4798      	blx	r3

	/* Obtain the parameter string. */
	parameter_string = (int8_t *) FreeRTOS_CLIGetParameter(
  403e54:	4628      	mov	r0, r5
  403e56:	2101      	movs	r1, #1
  403e58:	aa05      	add	r2, sp, #20
  403e5a:	4b1b      	ldr	r3, [pc, #108]	; (403ec8 <create_task_command+0x88>)
  403e5c:	4798      	blx	r3
									1,						/* Return the first parameter. */
									&parameter_string_length	/* Store the parameter string length. */
								);

	/* Turn the parameter into a number. */
	parameter_value = (int32_t) atol((const char *) parameter_string);
  403e5e:	4b1b      	ldr	r3, [pc, #108]	; (403ecc <create_task_command+0x8c>)
  403e60:	4798      	blx	r3
  403e62:	4603      	mov	r3, r0

	/* Attempt to create the task. */
	if (created_task_handle != NULL) {
  403e64:	4a1a      	ldr	r2, [pc, #104]	; (403ed0 <create_task_command+0x90>)
  403e66:	6812      	ldr	r2, [r2, #0]
  403e68:	b12a      	cbz	r2, 403e76 <create_task_command+0x36>
		strcpy((char *) pcWriteBuffer,
  403e6a:	4620      	mov	r0, r4
  403e6c:	4919      	ldr	r1, [pc, #100]	; (403ed4 <create_task_command+0x94>)
  403e6e:	224c      	movs	r2, #76	; 0x4c
  403e70:	4b19      	ldr	r3, [pc, #100]	; (403ed8 <create_task_command+0x98>)
  403e72:	4798      	blx	r3
  403e74:	e020      	b.n	403eb8 <create_task_command+0x78>
				(const char *) task_already_created_message);
	} else {
		if (xTaskCreate(created_task, (const signed char *) "Created",
  403e76:	2200      	movs	r2, #0
  403e78:	9200      	str	r2, [sp, #0]
  403e7a:	4915      	ldr	r1, [pc, #84]	; (403ed0 <create_task_command+0x90>)
  403e7c:	9101      	str	r1, [sp, #4]
  403e7e:	9202      	str	r2, [sp, #8]
  403e80:	9203      	str	r2, [sp, #12]
  403e82:	4816      	ldr	r0, [pc, #88]	; (403edc <create_task_command+0x9c>)
  403e84:	4916      	ldr	r1, [pc, #88]	; (403ee0 <create_task_command+0xa0>)
  403e86:	22a0      	movs	r2, #160	; 0xa0
  403e88:	4d16      	ldr	r5, [pc, #88]	; (403ee4 <create_task_command+0xa4>)
  403e8a:	47a8      	blx	r5
  403e8c:	2801      	cmp	r0, #1
  403e8e:	d109      	bne.n	403ea4 <create_task_command+0x64>
				configMINIMAL_STACK_SIZE,
				(void *) parameter_value, tskIDLE_PRIORITY,
				&created_task_handle) == pdPASS) {
			strcpy((char *) pcWriteBuffer,
  403e90:	4b15      	ldr	r3, [pc, #84]	; (403ee8 <create_task_command+0xa8>)
  403e92:	cb07      	ldmia	r3!, {r0, r1, r2}
  403e94:	6020      	str	r0, [r4, #0]
  403e96:	6061      	str	r1, [r4, #4]
  403e98:	60a2      	str	r2, [r4, #8]
  403e9a:	881a      	ldrh	r2, [r3, #0]
  403e9c:	789b      	ldrb	r3, [r3, #2]
  403e9e:	81a2      	strh	r2, [r4, #12]
  403ea0:	73a3      	strb	r3, [r4, #14]
  403ea2:	e009      	b.n	403eb8 <create_task_command+0x78>
					(const char *) success_message);
		} else {
			strcpy((char *) pcWriteBuffer,
  403ea4:	4d11      	ldr	r5, [pc, #68]	; (403eec <create_task_command+0xac>)
  403ea6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403ea8:	6020      	str	r0, [r4, #0]
  403eaa:	6061      	str	r1, [r4, #4]
  403eac:	60a2      	str	r2, [r4, #8]
  403eae:	60e3      	str	r3, [r4, #12]
  403eb0:	882a      	ldrh	r2, [r5, #0]
  403eb2:	78ab      	ldrb	r3, [r5, #2]
  403eb4:	8222      	strh	r2, [r4, #16]
  403eb6:	74a3      	strb	r3, [r4, #18]
	}

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  403eb8:	2000      	movs	r0, #0
  403eba:	b007      	add	sp, #28
  403ebc:	bd30      	pop	{r4, r5, pc}
  403ebe:	bf00      	nop
  403ec0:	0040ac10 	.word	0x0040ac10
  403ec4:	004041a5 	.word	0x004041a5
  403ec8:	0040218d 	.word	0x0040218d
  403ecc:	00404431 	.word	0x00404431
  403ed0:	2000518c 	.word	0x2000518c
  403ed4:	0040ac88 	.word	0x0040ac88
  403ed8:	004044ed 	.word	0x004044ed
  403edc:	004040e5 	.word	0x004040e5
  403ee0:	0040acd4 	.word	0x0040acd4
  403ee4:	00402d4d 	.word	0x00402d4d
  403ee8:	0040acdc 	.word	0x0040acdc
  403eec:	0040acec 	.word	0x0040acec

00403ef0 <multi_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE multi_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403ef0:	b5f0      	push	{r4, r5, r6, r7, lr}
  403ef2:	b083      	sub	sp, #12
  403ef4:	460e      	mov	r6, r1
  403ef6:	4615      	mov	r5, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403ef8:	4604      	mov	r4, r0
  403efa:	b920      	cbnz	r0, 403f06 <multi_parameter_echo_command+0x16>
  403efc:	4820      	ldr	r0, [pc, #128]	; (403f80 <multi_parameter_echo_command+0x90>)
  403efe:	f240 113f 	movw	r1, #319	; 0x13f
  403f02:	4b20      	ldr	r3, [pc, #128]	; (403f84 <multi_parameter_echo_command+0x94>)
  403f04:	4798      	blx	r3

	if (parameter_number == 0) {
  403f06:	4b20      	ldr	r3, [pc, #128]	; (403f88 <multi_parameter_echo_command+0x98>)
  403f08:	6819      	ldr	r1, [r3, #0]
  403f0a:	b979      	cbnz	r1, 403f2c <multi_parameter_echo_command+0x3c>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer, "The parameters were:\r\n");
  403f0c:	4d1f      	ldr	r5, [pc, #124]	; (403f8c <multi_parameter_echo_command+0x9c>)
  403f0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403f10:	6020      	str	r0, [r4, #0]
  403f12:	6061      	str	r1, [r4, #4]
  403f14:	60a2      	str	r2, [r4, #8]
  403f16:	60e3      	str	r3, [r4, #12]
  403f18:	6828      	ldr	r0, [r5, #0]
  403f1a:	6120      	str	r0, [r4, #16]
  403f1c:	88aa      	ldrh	r2, [r5, #4]
  403f1e:	79ab      	ldrb	r3, [r5, #6]
  403f20:	82a2      	strh	r2, [r4, #20]
  403f22:	75a3      	strb	r3, [r4, #22]

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
  403f24:	2001      	movs	r0, #1
  403f26:	4b18      	ldr	r3, [pc, #96]	; (403f88 <multi_parameter_echo_command+0x98>)
  403f28:	6018      	str	r0, [r3, #0]
  403f2a:	e027      	b.n	403f7c <multi_parameter_echo_command+0x8c>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
  403f2c:	4628      	mov	r0, r5
  403f2e:	aa01      	add	r2, sp, #4
  403f30:	4b17      	ldr	r3, [pc, #92]	; (403f90 <multi_parameter_echo_command+0xa0>)
  403f32:	4798      	blx	r3
										pcCommandString,		/* The command string itself. */
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		if (parameter_string != NULL) {
  403f34:	4607      	mov	r7, r0
  403f36:	b1e8      	cbz	r0, 403f74 <multi_parameter_echo_command+0x84>
			/* Return the parameter string. */
			memset(pcWriteBuffer, 0x00, xWriteBufferLen);
  403f38:	4620      	mov	r0, r4
  403f3a:	2100      	movs	r1, #0
  403f3c:	4632      	mov	r2, r6
  403f3e:	4b15      	ldr	r3, [pc, #84]	; (403f94 <multi_parameter_echo_command+0xa4>)
  403f40:	4798      	blx	r3
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
  403f42:	4d11      	ldr	r5, [pc, #68]	; (403f88 <multi_parameter_echo_command+0x98>)
  403f44:	4620      	mov	r0, r4
  403f46:	4914      	ldr	r1, [pc, #80]	; (403f98 <multi_parameter_echo_command+0xa8>)
  403f48:	682a      	ldr	r2, [r5, #0]
  403f4a:	4b14      	ldr	r3, [pc, #80]	; (403f9c <multi_parameter_echo_command+0xac>)
  403f4c:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
  403f4e:	4620      	mov	r0, r4
  403f50:	4639      	mov	r1, r7
  403f52:	9a01      	ldr	r2, [sp, #4]
  403f54:	4b12      	ldr	r3, [pc, #72]	; (403fa0 <multi_parameter_echo_command+0xb0>)
  403f56:	4798      	blx	r3
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
  403f58:	4620      	mov	r0, r4
  403f5a:	4b12      	ldr	r3, [pc, #72]	; (403fa4 <multi_parameter_echo_command+0xb4>)
  403f5c:	4798      	blx	r3
  403f5e:	1822      	adds	r2, r4, r0
  403f60:	4b11      	ldr	r3, [pc, #68]	; (403fa8 <multi_parameter_echo_command+0xb8>)
  403f62:	8819      	ldrh	r1, [r3, #0]
  403f64:	789b      	ldrb	r3, [r3, #2]
  403f66:	5221      	strh	r1, [r4, r0]
  403f68:	7093      	strb	r3, [r2, #2]

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
  403f6a:	682b      	ldr	r3, [r5, #0]
  403f6c:	3301      	adds	r3, #1
  403f6e:	602b      	str	r3, [r5, #0]
			sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
			strncat((char *) pcWriteBuffer, (const char *) parameter_string, parameter_string_length);
			strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));

			/* There might be more parameters to return after this one. */
			return_value = pdTRUE;
  403f70:	2001      	movs	r0, #1
  403f72:	e003      	b.n	403f7c <multi_parameter_echo_command+0x8c>
			parameter_number++;
		} else {
			/* No more parameters were found.  Make sure the write buffer does
			not contain a valid string. */
			pcWriteBuffer[0] = 0x00;
  403f74:	2000      	movs	r0, #0
  403f76:	7020      	strb	r0, [r4, #0]

			/* No more data to return. */
			return_value = pdFALSE;

			/* Start over the next time this command is executed. */
			parameter_number = 0;
  403f78:	4b03      	ldr	r3, [pc, #12]	; (403f88 <multi_parameter_echo_command+0x98>)
  403f7a:	6018      	str	r0, [r3, #0]
		}
	}

	return return_value;
}
  403f7c:	b003      	add	sp, #12
  403f7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  403f80:	0040ac10 	.word	0x0040ac10
  403f84:	004041a5 	.word	0x004041a5
  403f88:	20005190 	.word	0x20005190
  403f8c:	0040ad00 	.word	0x0040ad00
  403f90:	0040218d 	.word	0x0040218d
  403f94:	00404621 	.word	0x00404621
  403f98:	0040ad18 	.word	0x0040ad18
  403f9c:	004046bd 	.word	0x004046bd
  403fa0:	00404b55 	.word	0x00404b55
  403fa4:	00404af9 	.word	0x00404af9
  403fa8:	0040984c 	.word	0x0040984c

00403fac <three_parameter_echo_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE three_parameter_echo_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  403fac:	b570      	push	{r4, r5, r6, lr}
  403fae:	b082      	sub	sp, #8
  403fb0:	460d      	mov	r5, r1
  403fb2:	4616      	mov	r6, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  403fb4:	4604      	mov	r4, r0
  403fb6:	b918      	cbnz	r0, 403fc0 <three_parameter_echo_command+0x14>
  403fb8:	4823      	ldr	r0, [pc, #140]	; (404048 <three_parameter_echo_command+0x9c>)
  403fba:	21fd      	movs	r1, #253	; 0xfd
  403fbc:	4b23      	ldr	r3, [pc, #140]	; (40404c <three_parameter_echo_command+0xa0>)
  403fbe:	4798      	blx	r3

	if (parameter_number == 0) {
  403fc0:	4b23      	ldr	r3, [pc, #140]	; (404050 <three_parameter_echo_command+0xa4>)
  403fc2:	6819      	ldr	r1, [r3, #0]
  403fc4:	b979      	cbnz	r1, 403fe6 <three_parameter_echo_command+0x3a>
		/* The first time the function is called after the command has been
		entered just a header string is returned. */
		sprintf((char *) pcWriteBuffer,
  403fc6:	4d23      	ldr	r5, [pc, #140]	; (404054 <three_parameter_echo_command+0xa8>)
  403fc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  403fca:	6020      	str	r0, [r4, #0]
  403fcc:	6061      	str	r1, [r4, #4]
  403fce:	60a2      	str	r2, [r4, #8]
  403fd0:	60e3      	str	r3, [r4, #12]
  403fd2:	cd07      	ldmia	r5!, {r0, r1, r2}
  403fd4:	6120      	str	r0, [r4, #16]
  403fd6:	6161      	str	r1, [r4, #20]
  403fd8:	61a2      	str	r2, [r4, #24]
  403fda:	782b      	ldrb	r3, [r5, #0]
  403fdc:	7723      	strb	r3, [r4, #28]
				"The three parameters were:\r\n");

		/* Next time the function is called the first parameter will be echoed
		back. */
		parameter_number = 1L;
  403fde:	2001      	movs	r0, #1
  403fe0:	4b1b      	ldr	r3, [pc, #108]	; (404050 <three_parameter_echo_command+0xa4>)
  403fe2:	6018      	str	r0, [r3, #0]
  403fe4:	e02d      	b.n	404042 <three_parameter_echo_command+0x96>
		/* There is more data to be returned as no parameters have been echoed
		back yet. */
		return_value = pdPASS;
	} else {
		/* Obtain the parameter string. */
		parameter_string = (int8_t *) FreeRTOS_CLIGetParameter
  403fe6:	4630      	mov	r0, r6
  403fe8:	aa01      	add	r2, sp, #4
  403fea:	4b1b      	ldr	r3, [pc, #108]	; (404058 <three_parameter_echo_command+0xac>)
  403fec:	4798      	blx	r3
										parameter_number,		/* Return the next parameter. */
										&parameter_string_length	/* Store the parameter string length. */
									);

		/* Sanity check something was returned. */
		configASSERT(parameter_string);
  403fee:	4606      	mov	r6, r0
  403ff0:	b920      	cbnz	r0, 403ffc <three_parameter_echo_command+0x50>
  403ff2:	4815      	ldr	r0, [pc, #84]	; (404048 <three_parameter_echo_command+0x9c>)
  403ff4:	f44f 718b 	mov.w	r1, #278	; 0x116
  403ff8:	4b14      	ldr	r3, [pc, #80]	; (40404c <three_parameter_echo_command+0xa0>)
  403ffa:	4798      	blx	r3

		/* Return the parameter string. */
		memset(pcWriteBuffer, 0x00, xWriteBufferLen);
  403ffc:	4620      	mov	r0, r4
  403ffe:	2100      	movs	r1, #0
  404000:	462a      	mov	r2, r5
  404002:	4b16      	ldr	r3, [pc, #88]	; (40405c <three_parameter_echo_command+0xb0>)
  404004:	4798      	blx	r3
		sprintf((char *) pcWriteBuffer, "%ld: ", parameter_number);
  404006:	4d12      	ldr	r5, [pc, #72]	; (404050 <three_parameter_echo_command+0xa4>)
  404008:	4620      	mov	r0, r4
  40400a:	4915      	ldr	r1, [pc, #84]	; (404060 <three_parameter_echo_command+0xb4>)
  40400c:	682a      	ldr	r2, [r5, #0]
  40400e:	4b15      	ldr	r3, [pc, #84]	; (404064 <three_parameter_echo_command+0xb8>)
  404010:	4798      	blx	r3
		strncat((char *) pcWriteBuffer, (const char *) parameter_string,
  404012:	4620      	mov	r0, r4
  404014:	4631      	mov	r1, r6
  404016:	9a01      	ldr	r2, [sp, #4]
  404018:	4b13      	ldr	r3, [pc, #76]	; (404068 <three_parameter_echo_command+0xbc>)
  40401a:	4798      	blx	r3
				parameter_string_length);
		strncat((char *) pcWriteBuffer, "\r\n", strlen("\r\n"));
  40401c:	4620      	mov	r0, r4
  40401e:	4b13      	ldr	r3, [pc, #76]	; (40406c <three_parameter_echo_command+0xc0>)
  404020:	4798      	blx	r3
  404022:	1822      	adds	r2, r4, r0
  404024:	4b12      	ldr	r3, [pc, #72]	; (404070 <three_parameter_echo_command+0xc4>)
  404026:	8819      	ldrh	r1, [r3, #0]
  404028:	789b      	ldrb	r3, [r3, #2]
  40402a:	5221      	strh	r1, [r4, r0]
  40402c:	7093      	strb	r3, [r2, #2]

		/* If this is the last of the three parameters then there are no more
		strings to return after this one. */
		if (parameter_number == 3L) {
  40402e:	682b      	ldr	r3, [r5, #0]
  404030:	2b03      	cmp	r3, #3
  404032:	d102      	bne.n	40403a <three_parameter_echo_command+0x8e>
			/* If this is the last of the three parameters then there are no more
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
  404034:	2000      	movs	r0, #0
  404036:	6028      	str	r0, [r5, #0]
  404038:	e003      	b.n	404042 <three_parameter_echo_command+0x96>
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
			parameter_number++;
  40403a:	3301      	adds	r3, #1
  40403c:	4a04      	ldr	r2, [pc, #16]	; (404050 <three_parameter_echo_command+0xa4>)
  40403e:	6013      	str	r3, [r2, #0]
			strings to return after this one. */
			return_value = pdFALSE;
			parameter_number = 0L;
		} else {
			/* There are more parameters to return after this one. */
			return_value = pdTRUE;
  404040:	2001      	movs	r0, #1
			parameter_number++;
		}
	}

	return return_value;
}
  404042:	b002      	add	sp, #8
  404044:	bd70      	pop	{r4, r5, r6, pc}
  404046:	bf00      	nop
  404048:	0040ac10 	.word	0x0040ac10
  40404c:	004041a5 	.word	0x004041a5
  404050:	20005194 	.word	0x20005194
  404054:	0040ad20 	.word	0x0040ad20
  404058:	0040218d 	.word	0x0040218d
  40405c:	00404621 	.word	0x00404621
  404060:	0040ad18 	.word	0x0040ad18
  404064:	004046bd 	.word	0x004046bd
  404068:	00404b55 	.word	0x00404b55
  40406c:	00404af9 	.word	0x00404af9
  404070:	0040984c 	.word	0x0040984c

00404074 <run_time_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE run_time_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  404074:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  404076:	4604      	mov	r4, r0
  404078:	b918      	cbnz	r0, 404082 <run_time_stats_command+0xe>
  40407a:	4807      	ldr	r0, [pc, #28]	; (404098 <run_time_stats_command+0x24>)
  40407c:	21e2      	movs	r1, #226	; 0xe2
  40407e:	4b07      	ldr	r3, [pc, #28]	; (40409c <run_time_stats_command+0x28>)
  404080:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) stats_table_header);
  404082:	4620      	mov	r0, r4
  404084:	4906      	ldr	r1, [pc, #24]	; (4040a0 <run_time_stats_command+0x2c>)
  404086:	2251      	movs	r2, #81	; 0x51
  404088:	4b06      	ldr	r3, [pc, #24]	; (4040a4 <run_time_stats_command+0x30>)
  40408a:	4798      	blx	r3
	vTaskGetRunTimeStats(pcWriteBuffer + strlen(
  40408c:	f104 0050 	add.w	r0, r4, #80	; 0x50
  404090:	4b05      	ldr	r3, [pc, #20]	; (4040a8 <run_time_stats_command+0x34>)
  404092:	4798      	blx	r3
			(char *) stats_table_header));

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  404094:	2000      	movs	r0, #0
  404096:	bd10      	pop	{r4, pc}
  404098:	0040ac10 	.word	0x0040ac10
  40409c:	004041a5 	.word	0x004041a5
  4040a0:	0040ad40 	.word	0x0040ad40
  4040a4:	004044ed 	.word	0x004044ed
  4040a8:	004034b9 	.word	0x004034b9

004040ac <task_stats_command>:
/*-----------------------------------------------------------*/

static portBASE_TYPE task_stats_command(int8_t *pcWriteBuffer,
		size_t xWriteBufferLen,
		const int8_t *pcCommandString)
{
  4040ac:	b510      	push	{r4, lr}
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	(void) pcCommandString;
	(void) xWriteBufferLen;
	configASSERT(pcWriteBuffer);
  4040ae:	4604      	mov	r4, r0
  4040b0:	b918      	cbnz	r0, 4040ba <task_stats_command+0xe>
  4040b2:	4807      	ldr	r0, [pc, #28]	; (4040d0 <task_stats_command+0x24>)
  4040b4:	21ca      	movs	r1, #202	; 0xca
  4040b6:	4b07      	ldr	r3, [pc, #28]	; (4040d4 <task_stats_command+0x28>)
  4040b8:	4798      	blx	r3

	/* Generate a table of task stats. */
	strcpy((char *) pcWriteBuffer, (char *) task_table_header);
  4040ba:	4620      	mov	r0, r4
  4040bc:	4906      	ldr	r1, [pc, #24]	; (4040d8 <task_stats_command+0x2c>)
  4040be:	225b      	movs	r2, #91	; 0x5b
  4040c0:	4b06      	ldr	r3, [pc, #24]	; (4040dc <task_stats_command+0x30>)
  4040c2:	4798      	blx	r3
	vTaskList(pcWriteBuffer + strlen((char *) task_table_header));
  4040c4:	f104 005a 	add.w	r0, r4, #90	; 0x5a
  4040c8:	4b05      	ldr	r3, [pc, #20]	; (4040e0 <task_stats_command+0x34>)
  4040ca:	4798      	blx	r3

	/* There is no more data to return after this single string, so return
	pdFALSE. */
	return pdFALSE;
}
  4040cc:	2000      	movs	r0, #0
  4040ce:	bd10      	pop	{r4, pc}
  4040d0:	0040ac10 	.word	0x0040ac10
  4040d4:	004041a5 	.word	0x004041a5
  4040d8:	0040ad94 	.word	0x0040ad94
  4040dc:	004044ed 	.word	0x004044ed
  4040e0:	004033e5 	.word	0x004033e5

004040e4 <created_task>:
}

/*-----------------------------------------------------------*/

void created_task(void *pvParameters)
{
  4040e4:	b538      	push	{r3, r4, r5, lr}
  4040e6:	4605      	mov	r5, r0
	static uint8_t local_buffer[60];

	/* Cast the parameter to an appropriate type. */
	parameter_value = (int32_t)pvParameters;

	memset((void *) local_buffer, 0x00, sizeof(local_buffer));
  4040e8:	4c09      	ldr	r4, [pc, #36]	; (404110 <created_task+0x2c>)
  4040ea:	4620      	mov	r0, r4
  4040ec:	2100      	movs	r1, #0
  4040ee:	223c      	movs	r2, #60	; 0x3c
  4040f0:	4b08      	ldr	r3, [pc, #32]	; (404114 <created_task+0x30>)
  4040f2:	4798      	blx	r3
	sprintf((char *) local_buffer,
  4040f4:	4620      	mov	r0, r4
  4040f6:	4908      	ldr	r1, [pc, #32]	; (404118 <created_task+0x34>)
  4040f8:	462a      	mov	r2, r5
  4040fa:	4b08      	ldr	r3, [pc, #32]	; (40411c <created_task+0x38>)
  4040fc:	4798      	blx	r3
			(long) parameter_value);

	/* Cannot yet tell which CLI interface is in use, but both output functions
	guard check the port is initialised before it is used. */
#if (defined confINCLUDE_USART_CLI)
	usart_cli_output(local_buffer);
  4040fe:	4620      	mov	r0, r4
  404100:	4b07      	ldr	r3, [pc, #28]	; (404120 <created_task+0x3c>)
  404102:	4798      	blx	r3
#if (defined confINCLUDE_CDC_CLI)
	cdc_cli_output(local_buffer);
#endif

	for (;;) {
		vTaskDelay(portMAX_DELAY);
  404104:	f04f 35ff 	mov.w	r5, #4294967295
  404108:	4c06      	ldr	r4, [pc, #24]	; (404124 <created_task+0x40>)
  40410a:	4628      	mov	r0, r5
  40410c:	47a0      	blx	r4
	}
  40410e:	e7fc      	b.n	40410a <created_task+0x26>
  404110:	20005198 	.word	0x20005198
  404114:	00404621 	.word	0x00404621
  404118:	0040adf0 	.word	0x0040adf0
  40411c:	004046bd 	.word	0x004046bd
  404120:	00401db1 	.word	0x00401db1
  404124:	004032fd 	.word	0x004032fd

00404128 <vRegisterCLICommands>:
};

/*-----------------------------------------------------------*/

void vRegisterCLICommands(void)
{
  404128:	b510      	push	{r4, lr}
	/* Register all the command line commands defined immediately above. */
	FreeRTOS_CLIRegisterCommand(&task_stats_command_definition);
  40412a:	4807      	ldr	r0, [pc, #28]	; (404148 <vRegisterCLICommands+0x20>)
  40412c:	4c07      	ldr	r4, [pc, #28]	; (40414c <vRegisterCLICommands+0x24>)
  40412e:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&run_time_stats_command_definition);
  404130:	4807      	ldr	r0, [pc, #28]	; (404150 <vRegisterCLICommands+0x28>)
  404132:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&three_parameter_echo_command_definition);
  404134:	4807      	ldr	r0, [pc, #28]	; (404154 <vRegisterCLICommands+0x2c>)
  404136:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&multi_parameter_echo_command_definition);
  404138:	4807      	ldr	r0, [pc, #28]	; (404158 <vRegisterCLICommands+0x30>)
  40413a:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&create_task_command_definition);
  40413c:	4807      	ldr	r0, [pc, #28]	; (40415c <vRegisterCLICommands+0x34>)
  40413e:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&delete_task_command_definition);
  404140:	4807      	ldr	r0, [pc, #28]	; (404160 <vRegisterCLICommands+0x38>)
  404142:	47a0      	blx	r4
  404144:	bd10      	pop	{r4, pc}
  404146:	bf00      	nop
  404148:	0040b094 	.word	0x0040b094
  40414c:	00402035 	.word	0x00402035
  404150:	0040ac00 	.word	0x0040ac00
  404154:	0040b0a4 	.word	0x0040b0a4
  404158:	0040abe0 	.word	0x0040abe0
  40415c:	0040abd0 	.word	0x0040abd0
  404160:	0040abf0 	.word	0x0040abf0

00404164 <prvLEDTimerCallback>:
}

/*-----------------------------------------------------------*/

static void prvLEDTimerCallback(void *pvParameters)
{
  404164:	b508      	push	{r3, lr}
	(void) pvParameters;

	/* Check other tasks. */
	#if (defined confINCLUDE_USART_ECHO_TASKS)
	{
		if (are_usart_echo_tasks_still_running() != pdPASS) {
  404166:	4b06      	ldr	r3, [pc, #24]	; (404180 <prvLEDTimerCallback+0x1c>)
  404168:	4798      	blx	r3
		}
	}
	#endif /* configINCLUDE_TWI_EEPROM_TASK */

	/* If an error has been detected, turn the error LED on. */
	if (xStatus != pdPASS) {
  40416a:	2801      	cmp	r0, #1
  40416c:	d003      	beq.n	404176 <prvLEDTimerCallback+0x12>
		vParTestSetLED(mainERROR_LED, pdTRUE);
  40416e:	2001      	movs	r0, #1
  404170:	4601      	mov	r1, r0
  404172:	4b04      	ldr	r3, [pc, #16]	; (404184 <prvLEDTimerCallback+0x20>)
  404174:	4798      	blx	r3
	}

	/* Toggle an LED to show the system is executing. */
	vParTestToggleLED(mainSOFTWARE_TIMER_LED);
  404176:	2000      	movs	r0, #0
  404178:	4b03      	ldr	r3, [pc, #12]	; (404188 <prvLEDTimerCallback+0x24>)
  40417a:	4798      	blx	r3
  40417c:	bd08      	pop	{r3, pc}
  40417e:	bf00      	nop
  404180:	00401fe5 	.word	0x00401fe5
  404184:	00404299 	.word	0x00404299
  404188:	00404385 	.word	0x00404385

0040418c <vApplicationMallocFailedHook>:
}

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook(void)
{
  40418c:	b508      	push	{r3, lr}
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
  40418e:	4b01      	ldr	r3, [pc, #4]	; (404194 <vApplicationMallocFailedHook+0x8>)
  404190:	4798      	blx	r3
	for (;;) {
	}
  404192:	e7fe      	b.n	404192 <vApplicationMallocFailedHook+0x6>
  404194:	00402315 	.word	0x00402315

00404198 <vApplicationStackOverflowHook>:

/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook(xTaskHandle pxTask,
		signed char *pcTaskName)
{
  404198:	b508      	push	{r3, lr}
	(void) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
  40419a:	4b01      	ldr	r3, [pc, #4]	; (4041a0 <vApplicationStackOverflowHook+0x8>)
  40419c:	4798      	blx	r3
	for (;;) {
	}
  40419e:	e7fe      	b.n	40419e <vApplicationStackOverflowHook+0x6>
  4041a0:	00402315 	.word	0x00402315

004041a4 <assert_triggered>:
}

/*-----------------------------------------------------------*/

void assert_triggered(const char *file, uint32_t line)
{
  4041a4:	b500      	push	{lr}
  4041a6:	b083      	sub	sp, #12
	volatile uint32_t block_var = 0, line_in;
  4041a8:	2300      	movs	r3, #0
  4041aa:	9301      	str	r3, [sp, #4]
	const char *file_in;

	/* These assignments are made to prevent the compiler optimizing the
	values away. */
	file_in = file;
	line_in = line;
  4041ac:	9100      	str	r1, [sp, #0]
	(void) file_in;
	(void) line_in;
  4041ae:	9b00      	ldr	r3, [sp, #0]

	taskENTER_CRITICAL();
  4041b0:	4b04      	ldr	r3, [pc, #16]	; (4041c4 <assert_triggered+0x20>)
  4041b2:	4798      	blx	r3
	{
		while (block_var == 0) {
  4041b4:	9b01      	ldr	r3, [sp, #4]
  4041b6:	2b00      	cmp	r3, #0
  4041b8:	d0fc      	beq.n	4041b4 <assert_triggered+0x10>
			/* Set block_var to a non-zero value in the debugger to
			step out of this function. */
		}
	}
	taskEXIT_CRITICAL();
  4041ba:	4b03      	ldr	r3, [pc, #12]	; (4041c8 <assert_triggered+0x24>)
  4041bc:	4798      	blx	r3
}
  4041be:	b003      	add	sp, #12
  4041c0:	f85d fb04 	ldr.w	pc, [sp], #4
  4041c4:	00402325 	.word	0x00402325
  4041c8:	00402345 	.word	0x00402345

004041cc <main>:
void vApplicationTickHook(void);

/*-----------------------------------------------------------*/

int main(void)
{
  4041cc:	b530      	push	{r4, r5, lr}
  4041ce:	b083      	sub	sp, #12
/*-----------------------------------------------------------*/

static void prvSetupHardware(void)
{
	/* ASF function to setup clocking. */
	sysclk_init();
  4041d0:	4b1f      	ldr	r3, [pc, #124]	; (404250 <main+0x84>)
  4041d2:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  4041d4:	4a1f      	ldr	r2, [pc, #124]	; (404254 <main+0x88>)
  4041d6:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  4041d8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  4041dc:	041b      	lsls	r3, r3, #16
  4041de:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                 |
  4041e0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  4041e4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  4041e8:	60d3      	str	r3, [r2, #12]

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping(0);

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
  4041ea:	4b1b      	ldr	r3, [pc, #108]	; (404258 <main+0x8c>)
  4041ec:	4798      	blx	r3

	/* Perform any initialisation required by the partest LED IO functions. */
	vParTestInitialise();
  4041ee:	4b1b      	ldr	r3, [pc, #108]	; (40425c <main+0x90>)
  4041f0:	4798      	blx	r3
	/* Prepare the hardware to run this demo. */
	prvSetupHardware();

	/* Create the timer that toggles an LED to show that the system is running,
	and that the other tasks are behaving as expected. */
	xLEDTimer = xTimerCreate((const signed char * const) "LED timer",/* A text name, purely to help debugging. */
  4041f2:	4b1b      	ldr	r3, [pc, #108]	; (404260 <main+0x94>)
  4041f4:	9300      	str	r3, [sp, #0]
  4041f6:	481b      	ldr	r0, [pc, #108]	; (404264 <main+0x98>)
  4041f8:	21c8      	movs	r1, #200	; 0xc8
  4041fa:	2201      	movs	r2, #1
  4041fc:	2300      	movs	r3, #0
  4041fe:	4c1a      	ldr	r4, [pc, #104]	; (404268 <main+0x9c>)
  404200:	47a0      	blx	r4
							prvLEDTimerCallback			/* The function that is called each time the timer expires. */
							);

	/* Sanity check the timer's creation, then start the timer.  The timer
	will not actually start until the FreeRTOS kernel is started. */
	configASSERT(xLEDTimer);
  404202:	4605      	mov	r5, r0
  404204:	b920      	cbnz	r0, 404210 <main+0x44>
  404206:	4819      	ldr	r0, [pc, #100]	; (40426c <main+0xa0>)
  404208:	f44f 71c0 	mov.w	r1, #384	; 0x180
  40420c:	4b18      	ldr	r3, [pc, #96]	; (404270 <main+0xa4>)
  40420e:	4798      	blx	r3
	xTimerStart(xLEDTimer, mainDONT_BLOCK);
  404210:	4b18      	ldr	r3, [pc, #96]	; (404274 <main+0xa8>)
  404212:	4798      	blx	r3
  404214:	4602      	mov	r2, r0
  404216:	2400      	movs	r4, #0
  404218:	9400      	str	r4, [sp, #0]
  40421a:	4628      	mov	r0, r5
  40421c:	4621      	mov	r1, r4
  40421e:	4623      	mov	r3, r4
  404220:	4d15      	ldr	r5, [pc, #84]	; (404278 <main+0xac>)
  404222:	47a8      	blx	r5
	}
	#endif /* confINCLUDE_USART_CLI */

	#if (defined confINCLUDE_USART_ECHO_TASKS)
	{
		create_usart_echo_test_tasks(BOARD_USART,
  404224:	4815      	ldr	r0, [pc, #84]	; (40427c <main+0xb0>)
  404226:	21a0      	movs	r1, #160	; 0xa0
  404228:	4622      	mov	r2, r4
  40422a:	4b15      	ldr	r3, [pc, #84]	; (404280 <main+0xb4>)
  40422c:	4798      	blx	r3
	}
	#endif /* confINCLUDE_USART_ECHO_TASKS */

	#if (defined confINCLUDE_USART_CLI)
	{
		create_usart_cli_task(BOARD_USART_CLI,
  40422e:	4815      	ldr	r0, [pc, #84]	; (404284 <main+0xb8>)
  404230:	f44f 71a0 	mov.w	r1, #320	; 0x140
  404234:	2201      	movs	r2, #1
  404236:	4b14      	ldr	r3, [pc, #80]	; (404288 <main+0xbc>)
  404238:	4798      	blx	r3
#ifdef HIKU_HW
// Define anything to do with hiku under this block

	#if (defined confINCLUDE_TWI_I2C_TASK)
	{
		create_twi_i2c_test_task(BOARD_TWI_I2C,
  40423a:	4814      	ldr	r0, [pc, #80]	; (40428c <main+0xc0>)
  40423c:	f44f 71a0 	mov.w	r1, #320	; 0x140
  404240:	2201      	movs	r2, #1
  404242:	4623      	mov	r3, r4
  404244:	4c12      	ldr	r4, [pc, #72]	; (404290 <main+0xc4>)
  404246:	47a0      	blx	r4
	#endif /* confINCLUDE_TWI_EEPROM_TASK */
#endif /* HIKU_HW */


	/* Start the RTOS scheduler. */
	vTaskStartScheduler();
  404248:	4b12      	ldr	r3, [pc, #72]	; (404294 <main+0xc8>)
  40424a:	4798      	blx	r3
	will never be reached.  If the following line does execute, then there was
	insufficient FreeRTOS heap memory available for the idle and/or timer tasks
	to be created.  See the memory management section on the FreeRTOS web site
	for more details. */
	for (;;) {
	}
  40424c:	e7fe      	b.n	40424c <main+0x80>
  40424e:	bf00      	nop
  404250:	004007dd 	.word	0x004007dd
  404254:	e000ed00 	.word	0xe000ed00
  404258:	004011b5 	.word	0x004011b5
  40425c:	00404355 	.word	0x00404355
  404260:	00404165 	.word	0x00404165
  404264:	004098a4 	.word	0x004098a4
  404268:	00403af9 	.word	0x00403af9
  40426c:	0040b0b4 	.word	0x0040b0b4
  404270:	004041a5 	.word	0x004041a5
  404274:	00403085 	.word	0x00403085
  404278:	00403b51 	.word	0x00403b51
  40427c:	4000c200 	.word	0x4000c200
  404280:	00401f51 	.word	0x00401f51
  404284:	40034200 	.word	0x40034200
  404288:	00401d31 	.word	0x00401d31
  40428c:	4001c600 	.word	0x4001c600
  404290:	00401ae9 	.word	0x00401ae9
  404294:	00402ff9 	.word	0x00402ff9

00404298 <vParTestSetLED>:

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
	if (uxLED < partestNUM_LEDS) {
  404298:	2801      	cmp	r0, #1
  40429a:	d852      	bhi.n	404342 <vParTestSetLED+0xaa>
}

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
  40429c:	b510      	push	{r4, lr}
  40429e:	4604      	mov	r4, r0
	if (uxLED < partestNUM_LEDS) {
		if (xValue != pdFALSE) {
  4042a0:	b339      	cbz	r1, 4042f2 <vParTestSetLED+0x5a>
			/* Turn the LED on. */
			taskENTER_CRITICAL();
  4042a2:	4b28      	ldr	r3, [pc, #160]	; (404344 <vParTestSetLED+0xac>)
  4042a4:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
  4042a6:	4b28      	ldr	r3, [pc, #160]	; (404348 <vParTestSetLED+0xb0>)
  4042a8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
  4042ac:	b97b      	cbnz	r3, 4042ce <vParTestSetLED+0x36>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
  4042ae:	4b27      	ldr	r3, [pc, #156]	; (40434c <vParTestSetLED+0xb4>)
  4042b0:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4042b4:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4042b6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4042ba:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4042be:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4042c0:	f002 021f 	and.w	r2, r2, #31
  4042c4:	2101      	movs	r1, #1
  4042c6:	fa01 f202 	lsl.w	r2, r1, r2
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  4042ca:	635a      	str	r2, [r3, #52]	; 0x34
  4042cc:	e00e      	b.n	4042ec <vParTestSetLED+0x54>
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
  4042ce:	4b1f      	ldr	r3, [pc, #124]	; (40434c <vParTestSetLED+0xb4>)
  4042d0:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  4042d4:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4042d6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4042da:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4042de:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4042e0:	f002 021f 	and.w	r2, r2, #31
  4042e4:	2101      	movs	r1, #1
  4042e6:	fa01 f202 	lsl.w	r2, r1, r2
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4042ea:	631a      	str	r2, [r3, #48]	; 0x30
				}
			}
			taskEXIT_CRITICAL();
  4042ec:	4b18      	ldr	r3, [pc, #96]	; (404350 <vParTestSetLED+0xb8>)
  4042ee:	4798      	blx	r3
  4042f0:	bd10      	pop	{r4, pc}
		} else {
			/* Turn the LED off. */
			taskENTER_CRITICAL();
  4042f2:	4b14      	ldr	r3, [pc, #80]	; (404344 <vParTestSetLED+0xac>)
  4042f4:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
  4042f6:	4b14      	ldr	r3, [pc, #80]	; (404348 <vParTestSetLED+0xb0>)
  4042f8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
  4042fc:	b97b      	cbnz	r3, 40431e <vParTestSetLED+0x86>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
  4042fe:	4b13      	ldr	r3, [pc, #76]	; (40434c <vParTestSetLED+0xb4>)
  404300:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404304:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404306:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40430a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40430e:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404310:	f002 021f 	and.w	r2, r2, #31
  404314:	2101      	movs	r1, #1
  404316:	fa01 f202 	lsl.w	r2, r1, r2
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40431a:	631a      	str	r2, [r3, #48]	; 0x30
  40431c:	e00e      	b.n	40433c <vParTestSetLED+0xa4>
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
  40431e:	4b0b      	ldr	r3, [pc, #44]	; (40434c <vParTestSetLED+0xb4>)
  404320:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404324:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404326:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40432a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40432e:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404330:	f002 021f 	and.w	r2, r2, #31
  404334:	2101      	movs	r1, #1
  404336:	fa01 f202 	lsl.w	r2, r1, r2
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40433a:	635a      	str	r2, [r3, #52]	; 0x34
				}
			}
			taskEXIT_CRITICAL();
  40433c:	4b04      	ldr	r3, [pc, #16]	; (404350 <vParTestSetLED+0xb8>)
  40433e:	4798      	blx	r3
  404340:	bd10      	pop	{r4, pc}
  404342:	4770      	bx	lr
  404344:	00402325 	.word	0x00402325
  404348:	0040b0c4 	.word	0x0040b0c4
  40434c:	0040b0d0 	.word	0x0040b0d0
  404350:	00402345 	.word	0x00402345

00404354 <vParTestInitialise>:
	= {LED0_ACTIVE_LEVEL, LED1_ACTIVE_LEVEL, LED2_ACTIVE_LEVEL};

/*-----------------------------------------------------------*/

void vParTestInitialise(void)
{
  404354:	b538      	push	{r3, r4, r5, lr}
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  404356:	4c09      	ldr	r4, [pc, #36]	; (40437c <vParTestInitialise+0x28>)
  404358:	2340      	movs	r3, #64	; 0x40
  40435a:	6123      	str	r3, [r4, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40435c:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  404360:	6323      	str	r3, [r4, #48]	; 0x30
	for (ul = 0; ul < partestNUM_LEDS; ul++) {
		/* Configure the LED, before ensuring it starts in the off
		state. */
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
        ioport_set_pin_level(ulLED[ ul ], IOPORT_PIN_LEVEL_HIGH);
		vParTestSetLED(ul, xActiveStates[ ul ]);
  404362:	2000      	movs	r0, #0
  404364:	4601      	mov	r1, r0
  404366:	4d06      	ldr	r5, [pc, #24]	; (404380 <vParTestInitialise+0x2c>)
  404368:	47a8      	blx	r5
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40436a:	2001      	movs	r0, #1
  40436c:	6120      	str	r0, [r4, #16]
	} else if (dir == IOPORT_DIR_INPUT) {
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40436e:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  404372:	6320      	str	r0, [r4, #48]	; 0x30
  404374:	2100      	movs	r1, #0
  404376:	47a8      	blx	r5
  404378:	bd38      	pop	{r3, r4, r5, pc}
  40437a:	bf00      	nop
  40437c:	400e0e00 	.word	0x400e0e00
  404380:	00404299 	.word	0x00404299

00404384 <vParTestToggleLED>:

/*-----------------------------------------------------------*/

void vParTestToggleLED(unsigned portBASE_TYPE uxLED)
{
	if (uxLED < partestNUM_LEDS) {
  404384:	2801      	cmp	r0, #1
  404386:	d819      	bhi.n	4043bc <vParTestToggleLED+0x38>
}

/*-----------------------------------------------------------*/

void vParTestToggleLED(unsigned portBASE_TYPE uxLED)
{
  404388:	b510      	push	{r4, lr}
  40438a:	4604      	mov	r4, r0
	if (uxLED < partestNUM_LEDS) {
		taskENTER_CRITICAL();
  40438c:	4b0c      	ldr	r3, [pc, #48]	; (4043c0 <vParTestToggleLED+0x3c>)
  40438e:	4798      	blx	r3
		{
			ioport_toggle_pin_level(ulLED[ uxLED ]);
  404390:	4b0c      	ldr	r3, [pc, #48]	; (4043c4 <vParTestToggleLED+0x40>)
  404392:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404396:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404398:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40439c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4043a0:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4043a2:	f002 021f 	and.w	r2, r2, #31
  4043a6:	2101      	movs	r1, #1
  4043a8:	fa01 f202 	lsl.w	r2, r1, r2
__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  4043ac:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  4043ae:	420a      	tst	r2, r1
		port->PIO_CODR = mask;
  4043b0:	bf14      	ite	ne
  4043b2:	635a      	strne	r2, [r3, #52]	; 0x34
	} else {
		port->PIO_SODR = mask;
  4043b4:	631a      	streq	r2, [r3, #48]	; 0x30
		}
		taskEXIT_CRITICAL();
  4043b6:	4b04      	ldr	r3, [pc, #16]	; (4043c8 <vParTestToggleLED+0x44>)
  4043b8:	4798      	blx	r3
  4043ba:	bd10      	pop	{r4, pc}
  4043bc:	4770      	bx	lr
  4043be:	bf00      	nop
  4043c0:	00402325 	.word	0x00402325
  4043c4:	0040b0d0 	.word	0x0040b0d0
  4043c8:	00402345 	.word	0x00402345

004043cc <configure_timer_for_run_time_stats>:
/*-----------------------------------------------------------*/

void configure_timer_for_run_time_stats(void)
{
	/* How many clocks are there per tenth of a millisecond? */
	clocks_per_10th_ms = configCPU_CLOCK_HZ / 10000UL;
  4043cc:	f642 62df 	movw	r2, #11999	; 0x2edf
  4043d0:	4b01      	ldr	r3, [pc, #4]	; (4043d8 <configure_timer_for_run_time_stats+0xc>)
  4043d2:	601a      	str	r2, [r3, #0]
  4043d4:	4770      	bx	lr
  4043d6:	bf00      	nop
  4043d8:	200051d4 	.word	0x200051d4

004043dc <get_run_time_counter_value>:
}

/*-----------------------------------------------------------*/

uint32_t get_run_time_counter_value(void)
{
  4043dc:	b538      	push	{r3, r4, r5, lr}
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
  4043de:	4b0f      	ldr	r3, [pc, #60]	; (40441c <get_run_time_counter_value+0x40>)
  4043e0:	681c      	ldr	r4, [r3, #0]

	/* How many times has it overflowed? */
	tick_count = xTaskGetTickCountFromISR();
  4043e2:	4b0f      	ldr	r3, [pc, #60]	; (404420 <get_run_time_counter_value+0x44>)
  4043e4:	4798      	blx	r3
  4043e6:	4605      	mov	r5, r0

	/* This is called from the context switch, so will be called from a
	critical section.  xTaskGetTickCountFromISR() contains its own critical
	section, and the ISR safe critical sections are not designed to nest,
	so reset the critical section. */
	ulReturn = portSET_INTERRUPT_MASK_FROM_ISR();
  4043e8:	4b0e      	ldr	r3, [pc, #56]	; (404424 <get_run_time_counter_value+0x48>)
  4043ea:	4798      	blx	r3
	(void) ulReturn;

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
  4043ec:	4b0e      	ldr	r3, [pc, #56]	; (404428 <get_run_time_counter_value+0x4c>)
  4043ee:	681b      	ldr	r3, [r3, #0]
  4043f0:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
  4043f4:	d103      	bne.n	4043fe <get_run_time_counter_value+0x22>
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
  4043f6:	f5c4 33ea 	rsb	r3, r4, #119808	; 0x1d400
  4043fa:	33bb      	adds	r3, #187	; 0xbb
  4043fc:	e005      	b.n	40440a <get_run_time_counter_value+0x2e>

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
		/* There is a SysTick interrupt pending, so the SysTick has overflowed
		but the tick count not yet incremented. */
		tick_count++;
  4043fe:	3501      	adds	r5, #1

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
				*current_sys_tick_count;
  404400:	4b06      	ldr	r3, [pc, #24]	; (40441c <get_run_time_counter_value+0x40>)
  404402:	681b      	ldr	r3, [r3, #0]
		but the tick count not yet incremented. */
		tick_count++;

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
  404404:	f5c3 33ea 	rsb	r3, r3, #119808	; 0x1d400
  404408:	33bb      	adds	r3, #187	; 0xbb
				*current_sys_tick_count;
	}

	/* Convert the tick count into tenths of a millisecond.  THIS ASSUMES
	configTICK_RATE_HZ is 1000! */
	ulReturn = (tick_count * 10UL);
  40440a:	eb05 0585 	add.w	r5, r5, r5, lsl #2

	/* Add on the number of tenths of a millisecond that have passed since
	the tick count last got updated. */
	ulReturn += (sys_tick_counts / clocks_per_10th_ms);
  40440e:	4a07      	ldr	r2, [pc, #28]	; (40442c <get_run_time_counter_value+0x50>)
  404410:	6810      	ldr	r0, [r2, #0]
  404412:	fbb3 f0f0 	udiv	r0, r3, r0

	return ulReturn;
}
  404416:	eb00 0045 	add.w	r0, r0, r5, lsl #1
  40441a:	bd38      	pop	{r3, r4, r5, pc}
  40441c:	e000e018 	.word	0xe000e018
  404420:	004030a5 	.word	0x004030a5
  404424:	00402315 	.word	0x00402315
  404428:	e000ed04 	.word	0xe000ed04
  40442c:	200051d4 	.word	0x200051d4

00404430 <atol>:
  404430:	2100      	movs	r1, #0
  404432:	220a      	movs	r2, #10
  404434:	f000 bcca 	b.w	404dcc <strtol>

00404438 <__libc_init_array>:
  404438:	b570      	push	{r4, r5, r6, lr}
  40443a:	4e0f      	ldr	r6, [pc, #60]	; (404478 <__libc_init_array+0x40>)
  40443c:	4d0f      	ldr	r5, [pc, #60]	; (40447c <__libc_init_array+0x44>)
  40443e:	1b76      	subs	r6, r6, r5
  404440:	10b6      	asrs	r6, r6, #2
  404442:	bf18      	it	ne
  404444:	2400      	movne	r4, #0
  404446:	d005      	beq.n	404454 <__libc_init_array+0x1c>
  404448:	3401      	adds	r4, #1
  40444a:	f855 3b04 	ldr.w	r3, [r5], #4
  40444e:	4798      	blx	r3
  404450:	42a6      	cmp	r6, r4
  404452:	d1f9      	bne.n	404448 <__libc_init_array+0x10>
  404454:	4e0a      	ldr	r6, [pc, #40]	; (404480 <__libc_init_array+0x48>)
  404456:	4d0b      	ldr	r5, [pc, #44]	; (404484 <__libc_init_array+0x4c>)
  404458:	1b76      	subs	r6, r6, r5
  40445a:	f006 ff85 	bl	40b368 <_init>
  40445e:	10b6      	asrs	r6, r6, #2
  404460:	bf18      	it	ne
  404462:	2400      	movne	r4, #0
  404464:	d006      	beq.n	404474 <__libc_init_array+0x3c>
  404466:	3401      	adds	r4, #1
  404468:	f855 3b04 	ldr.w	r3, [r5], #4
  40446c:	4798      	blx	r3
  40446e:	42a6      	cmp	r6, r4
  404470:	d1f9      	bne.n	404466 <__libc_init_array+0x2e>
  404472:	bd70      	pop	{r4, r5, r6, pc}
  404474:	bd70      	pop	{r4, r5, r6, pc}
  404476:	bf00      	nop
  404478:	0040b374 	.word	0x0040b374
  40447c:	0040b374 	.word	0x0040b374
  404480:	0040b37c 	.word	0x0040b37c
  404484:	0040b374 	.word	0x0040b374

00404488 <memcmp>:
  404488:	2a03      	cmp	r2, #3
  40448a:	b470      	push	{r4, r5, r6}
  40448c:	d926      	bls.n	4044dc <memcmp+0x54>
  40448e:	ea40 0301 	orr.w	r3, r0, r1
  404492:	079b      	lsls	r3, r3, #30
  404494:	d011      	beq.n	4044ba <memcmp+0x32>
  404496:	7804      	ldrb	r4, [r0, #0]
  404498:	780d      	ldrb	r5, [r1, #0]
  40449a:	42ac      	cmp	r4, r5
  40449c:	d122      	bne.n	4044e4 <memcmp+0x5c>
  40449e:	4402      	add	r2, r0
  4044a0:	1c43      	adds	r3, r0, #1
  4044a2:	e005      	b.n	4044b0 <memcmp+0x28>
  4044a4:	f813 4b01 	ldrb.w	r4, [r3], #1
  4044a8:	f811 5f01 	ldrb.w	r5, [r1, #1]!
  4044ac:	42ac      	cmp	r4, r5
  4044ae:	d119      	bne.n	4044e4 <memcmp+0x5c>
  4044b0:	4293      	cmp	r3, r2
  4044b2:	d1f7      	bne.n	4044a4 <memcmp+0x1c>
  4044b4:	2000      	movs	r0, #0
  4044b6:	bc70      	pop	{r4, r5, r6}
  4044b8:	4770      	bx	lr
  4044ba:	460c      	mov	r4, r1
  4044bc:	4603      	mov	r3, r0
  4044be:	681e      	ldr	r6, [r3, #0]
  4044c0:	6825      	ldr	r5, [r4, #0]
  4044c2:	42ae      	cmp	r6, r5
  4044c4:	4618      	mov	r0, r3
  4044c6:	4621      	mov	r1, r4
  4044c8:	f103 0304 	add.w	r3, r3, #4
  4044cc:	f104 0404 	add.w	r4, r4, #4
  4044d0:	d104      	bne.n	4044dc <memcmp+0x54>
  4044d2:	3a04      	subs	r2, #4
  4044d4:	2a03      	cmp	r2, #3
  4044d6:	4618      	mov	r0, r3
  4044d8:	4621      	mov	r1, r4
  4044da:	d8f0      	bhi.n	4044be <memcmp+0x36>
  4044dc:	2a00      	cmp	r2, #0
  4044de:	d1da      	bne.n	404496 <memcmp+0xe>
  4044e0:	4610      	mov	r0, r2
  4044e2:	e7e8      	b.n	4044b6 <memcmp+0x2e>
  4044e4:	1b60      	subs	r0, r4, r5
  4044e6:	bc70      	pop	{r4, r5, r6}
  4044e8:	4770      	bx	lr
  4044ea:	bf00      	nop

004044ec <memcpy>:
  4044ec:	4684      	mov	ip, r0
  4044ee:	ea41 0300 	orr.w	r3, r1, r0
  4044f2:	f013 0303 	ands.w	r3, r3, #3
  4044f6:	d16d      	bne.n	4045d4 <memcpy+0xe8>
  4044f8:	3a40      	subs	r2, #64	; 0x40
  4044fa:	d341      	bcc.n	404580 <memcpy+0x94>
  4044fc:	f851 3b04 	ldr.w	r3, [r1], #4
  404500:	f840 3b04 	str.w	r3, [r0], #4
  404504:	f851 3b04 	ldr.w	r3, [r1], #4
  404508:	f840 3b04 	str.w	r3, [r0], #4
  40450c:	f851 3b04 	ldr.w	r3, [r1], #4
  404510:	f840 3b04 	str.w	r3, [r0], #4
  404514:	f851 3b04 	ldr.w	r3, [r1], #4
  404518:	f840 3b04 	str.w	r3, [r0], #4
  40451c:	f851 3b04 	ldr.w	r3, [r1], #4
  404520:	f840 3b04 	str.w	r3, [r0], #4
  404524:	f851 3b04 	ldr.w	r3, [r1], #4
  404528:	f840 3b04 	str.w	r3, [r0], #4
  40452c:	f851 3b04 	ldr.w	r3, [r1], #4
  404530:	f840 3b04 	str.w	r3, [r0], #4
  404534:	f851 3b04 	ldr.w	r3, [r1], #4
  404538:	f840 3b04 	str.w	r3, [r0], #4
  40453c:	f851 3b04 	ldr.w	r3, [r1], #4
  404540:	f840 3b04 	str.w	r3, [r0], #4
  404544:	f851 3b04 	ldr.w	r3, [r1], #4
  404548:	f840 3b04 	str.w	r3, [r0], #4
  40454c:	f851 3b04 	ldr.w	r3, [r1], #4
  404550:	f840 3b04 	str.w	r3, [r0], #4
  404554:	f851 3b04 	ldr.w	r3, [r1], #4
  404558:	f840 3b04 	str.w	r3, [r0], #4
  40455c:	f851 3b04 	ldr.w	r3, [r1], #4
  404560:	f840 3b04 	str.w	r3, [r0], #4
  404564:	f851 3b04 	ldr.w	r3, [r1], #4
  404568:	f840 3b04 	str.w	r3, [r0], #4
  40456c:	f851 3b04 	ldr.w	r3, [r1], #4
  404570:	f840 3b04 	str.w	r3, [r0], #4
  404574:	f851 3b04 	ldr.w	r3, [r1], #4
  404578:	f840 3b04 	str.w	r3, [r0], #4
  40457c:	3a40      	subs	r2, #64	; 0x40
  40457e:	d2bd      	bcs.n	4044fc <memcpy+0x10>
  404580:	3230      	adds	r2, #48	; 0x30
  404582:	d311      	bcc.n	4045a8 <memcpy+0xbc>
  404584:	f851 3b04 	ldr.w	r3, [r1], #4
  404588:	f840 3b04 	str.w	r3, [r0], #4
  40458c:	f851 3b04 	ldr.w	r3, [r1], #4
  404590:	f840 3b04 	str.w	r3, [r0], #4
  404594:	f851 3b04 	ldr.w	r3, [r1], #4
  404598:	f840 3b04 	str.w	r3, [r0], #4
  40459c:	f851 3b04 	ldr.w	r3, [r1], #4
  4045a0:	f840 3b04 	str.w	r3, [r0], #4
  4045a4:	3a10      	subs	r2, #16
  4045a6:	d2ed      	bcs.n	404584 <memcpy+0x98>
  4045a8:	320c      	adds	r2, #12
  4045aa:	d305      	bcc.n	4045b8 <memcpy+0xcc>
  4045ac:	f851 3b04 	ldr.w	r3, [r1], #4
  4045b0:	f840 3b04 	str.w	r3, [r0], #4
  4045b4:	3a04      	subs	r2, #4
  4045b6:	d2f9      	bcs.n	4045ac <memcpy+0xc0>
  4045b8:	3204      	adds	r2, #4
  4045ba:	d008      	beq.n	4045ce <memcpy+0xe2>
  4045bc:	07d2      	lsls	r2, r2, #31
  4045be:	bf1c      	itt	ne
  4045c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4045c4:	f800 3b01 	strbne.w	r3, [r0], #1
  4045c8:	d301      	bcc.n	4045ce <memcpy+0xe2>
  4045ca:	880b      	ldrh	r3, [r1, #0]
  4045cc:	8003      	strh	r3, [r0, #0]
  4045ce:	4660      	mov	r0, ip
  4045d0:	4770      	bx	lr
  4045d2:	bf00      	nop
  4045d4:	2a08      	cmp	r2, #8
  4045d6:	d313      	bcc.n	404600 <memcpy+0x114>
  4045d8:	078b      	lsls	r3, r1, #30
  4045da:	d08d      	beq.n	4044f8 <memcpy+0xc>
  4045dc:	f010 0303 	ands.w	r3, r0, #3
  4045e0:	d08a      	beq.n	4044f8 <memcpy+0xc>
  4045e2:	f1c3 0304 	rsb	r3, r3, #4
  4045e6:	1ad2      	subs	r2, r2, r3
  4045e8:	07db      	lsls	r3, r3, #31
  4045ea:	bf1c      	itt	ne
  4045ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4045f0:	f800 3b01 	strbne.w	r3, [r0], #1
  4045f4:	d380      	bcc.n	4044f8 <memcpy+0xc>
  4045f6:	f831 3b02 	ldrh.w	r3, [r1], #2
  4045fa:	f820 3b02 	strh.w	r3, [r0], #2
  4045fe:	e77b      	b.n	4044f8 <memcpy+0xc>
  404600:	3a04      	subs	r2, #4
  404602:	d3d9      	bcc.n	4045b8 <memcpy+0xcc>
  404604:	3a01      	subs	r2, #1
  404606:	f811 3b01 	ldrb.w	r3, [r1], #1
  40460a:	f800 3b01 	strb.w	r3, [r0], #1
  40460e:	d2f9      	bcs.n	404604 <memcpy+0x118>
  404610:	780b      	ldrb	r3, [r1, #0]
  404612:	7003      	strb	r3, [r0, #0]
  404614:	784b      	ldrb	r3, [r1, #1]
  404616:	7043      	strb	r3, [r0, #1]
  404618:	788b      	ldrb	r3, [r1, #2]
  40461a:	7083      	strb	r3, [r0, #2]
  40461c:	4660      	mov	r0, ip
  40461e:	4770      	bx	lr

00404620 <memset>:
  404620:	b470      	push	{r4, r5, r6}
  404622:	0784      	lsls	r4, r0, #30
  404624:	d046      	beq.n	4046b4 <memset+0x94>
  404626:	1e54      	subs	r4, r2, #1
  404628:	2a00      	cmp	r2, #0
  40462a:	d041      	beq.n	4046b0 <memset+0x90>
  40462c:	b2cd      	uxtb	r5, r1
  40462e:	4603      	mov	r3, r0
  404630:	e002      	b.n	404638 <memset+0x18>
  404632:	1e62      	subs	r2, r4, #1
  404634:	b3e4      	cbz	r4, 4046b0 <memset+0x90>
  404636:	4614      	mov	r4, r2
  404638:	f803 5b01 	strb.w	r5, [r3], #1
  40463c:	079a      	lsls	r2, r3, #30
  40463e:	d1f8      	bne.n	404632 <memset+0x12>
  404640:	2c03      	cmp	r4, #3
  404642:	d92e      	bls.n	4046a2 <memset+0x82>
  404644:	b2cd      	uxtb	r5, r1
  404646:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40464a:	2c0f      	cmp	r4, #15
  40464c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  404650:	d919      	bls.n	404686 <memset+0x66>
  404652:	f103 0210 	add.w	r2, r3, #16
  404656:	4626      	mov	r6, r4
  404658:	3e10      	subs	r6, #16
  40465a:	2e0f      	cmp	r6, #15
  40465c:	f842 5c10 	str.w	r5, [r2, #-16]
  404660:	f842 5c0c 	str.w	r5, [r2, #-12]
  404664:	f842 5c08 	str.w	r5, [r2, #-8]
  404668:	f842 5c04 	str.w	r5, [r2, #-4]
  40466c:	f102 0210 	add.w	r2, r2, #16
  404670:	d8f2      	bhi.n	404658 <memset+0x38>
  404672:	f1a4 0210 	sub.w	r2, r4, #16
  404676:	f022 020f 	bic.w	r2, r2, #15
  40467a:	f004 040f 	and.w	r4, r4, #15
  40467e:	3210      	adds	r2, #16
  404680:	2c03      	cmp	r4, #3
  404682:	4413      	add	r3, r2
  404684:	d90d      	bls.n	4046a2 <memset+0x82>
  404686:	461e      	mov	r6, r3
  404688:	4622      	mov	r2, r4
  40468a:	3a04      	subs	r2, #4
  40468c:	2a03      	cmp	r2, #3
  40468e:	f846 5b04 	str.w	r5, [r6], #4
  404692:	d8fa      	bhi.n	40468a <memset+0x6a>
  404694:	1f22      	subs	r2, r4, #4
  404696:	f022 0203 	bic.w	r2, r2, #3
  40469a:	3204      	adds	r2, #4
  40469c:	4413      	add	r3, r2
  40469e:	f004 0403 	and.w	r4, r4, #3
  4046a2:	b12c      	cbz	r4, 4046b0 <memset+0x90>
  4046a4:	b2c9      	uxtb	r1, r1
  4046a6:	441c      	add	r4, r3
  4046a8:	f803 1b01 	strb.w	r1, [r3], #1
  4046ac:	42a3      	cmp	r3, r4
  4046ae:	d1fb      	bne.n	4046a8 <memset+0x88>
  4046b0:	bc70      	pop	{r4, r5, r6}
  4046b2:	4770      	bx	lr
  4046b4:	4614      	mov	r4, r2
  4046b6:	4603      	mov	r3, r0
  4046b8:	e7c2      	b.n	404640 <memset+0x20>
  4046ba:	bf00      	nop

004046bc <sprintf>:
  4046bc:	b40e      	push	{r1, r2, r3}
  4046be:	b5f0      	push	{r4, r5, r6, r7, lr}
  4046c0:	b09c      	sub	sp, #112	; 0x70
  4046c2:	ab21      	add	r3, sp, #132	; 0x84
  4046c4:	490f      	ldr	r1, [pc, #60]	; (404704 <sprintf+0x48>)
  4046c6:	f853 2b04 	ldr.w	r2, [r3], #4
  4046ca:	9301      	str	r3, [sp, #4]
  4046cc:	4605      	mov	r5, r0
  4046ce:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
  4046d2:	6808      	ldr	r0, [r1, #0]
  4046d4:	9502      	str	r5, [sp, #8]
  4046d6:	f44f 7702 	mov.w	r7, #520	; 0x208
  4046da:	f64f 76ff 	movw	r6, #65535	; 0xffff
  4046de:	a902      	add	r1, sp, #8
  4046e0:	9506      	str	r5, [sp, #24]
  4046e2:	f8ad 7014 	strh.w	r7, [sp, #20]
  4046e6:	9404      	str	r4, [sp, #16]
  4046e8:	9407      	str	r4, [sp, #28]
  4046ea:	f8ad 6016 	strh.w	r6, [sp, #22]
  4046ee:	f000 fb79 	bl	404de4 <_svfprintf_r>
  4046f2:	9b02      	ldr	r3, [sp, #8]
  4046f4:	2200      	movs	r2, #0
  4046f6:	701a      	strb	r2, [r3, #0]
  4046f8:	b01c      	add	sp, #112	; 0x70
  4046fa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  4046fe:	b003      	add	sp, #12
  404700:	4770      	bx	lr
  404702:	bf00      	nop
  404704:	20000620 	.word	0x20000620

00404708 <strcat>:
  404708:	0783      	lsls	r3, r0, #30
  40470a:	b510      	push	{r4, lr}
  40470c:	4604      	mov	r4, r0
  40470e:	d110      	bne.n	404732 <strcat+0x2a>
  404710:	6802      	ldr	r2, [r0, #0]
  404712:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  404716:	ea23 0302 	bic.w	r3, r3, r2
  40471a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  40471e:	d108      	bne.n	404732 <strcat+0x2a>
  404720:	f850 2f04 	ldr.w	r2, [r0, #4]!
  404724:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
  404728:	ea23 0302 	bic.w	r3, r3, r2
  40472c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  404730:	d0f6      	beq.n	404720 <strcat+0x18>
  404732:	7803      	ldrb	r3, [r0, #0]
  404734:	b11b      	cbz	r3, 40473e <strcat+0x36>
  404736:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  40473a:	2b00      	cmp	r3, #0
  40473c:	d1fb      	bne.n	404736 <strcat+0x2e>
  40473e:	f000 f97d 	bl	404a3c <strcpy>
  404742:	4620      	mov	r0, r4
  404744:	bd10      	pop	{r4, pc}
  404746:	bf00      	nop
	...
  404760:	eba2 0003 	sub.w	r0, r2, r3
  404764:	4770      	bx	lr
  404766:	bf00      	nop

00404768 <strcmp>:
  404768:	7802      	ldrb	r2, [r0, #0]
  40476a:	780b      	ldrb	r3, [r1, #0]
  40476c:	2a01      	cmp	r2, #1
  40476e:	bf28      	it	cs
  404770:	429a      	cmpcs	r2, r3
  404772:	d1f5      	bne.n	404760 <strcat+0x58>
  404774:	e96d 4504 	strd	r4, r5, [sp, #-16]!
  404778:	ea40 0401 	orr.w	r4, r0, r1
  40477c:	e9cd 6702 	strd	r6, r7, [sp, #8]
  404780:	f06f 0c00 	mvn.w	ip, #0
  404784:	ea4f 7244 	mov.w	r2, r4, lsl #29
  404788:	b312      	cbz	r2, 4047d0 <strcmp+0x68>
  40478a:	ea80 0401 	eor.w	r4, r0, r1
  40478e:	f014 0f07 	tst.w	r4, #7
  404792:	d16a      	bne.n	40486a <strcmp+0x102>
  404794:	f000 0407 	and.w	r4, r0, #7
  404798:	f020 0007 	bic.w	r0, r0, #7
  40479c:	f004 0503 	and.w	r5, r4, #3
  4047a0:	f021 0107 	bic.w	r1, r1, #7
  4047a4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  4047a8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
  4047ac:	f014 0f04 	tst.w	r4, #4
  4047b0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
  4047b4:	fa0c f405 	lsl.w	r4, ip, r5
  4047b8:	ea62 0204 	orn	r2, r2, r4
  4047bc:	ea66 0604 	orn	r6, r6, r4
  4047c0:	d00a      	beq.n	4047d8 <strcmp+0x70>
  4047c2:	ea63 0304 	orn	r3, r3, r4
  4047c6:	4662      	mov	r2, ip
  4047c8:	ea67 0704 	orn	r7, r7, r4
  4047cc:	4666      	mov	r6, ip
  4047ce:	e003      	b.n	4047d8 <strcmp+0x70>
  4047d0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
  4047d4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
  4047d8:	fa82 f54c 	uadd8	r5, r2, ip
  4047dc:	ea82 0406 	eor.w	r4, r2, r6
  4047e0:	faa4 f48c 	sel	r4, r4, ip
  4047e4:	bb6c      	cbnz	r4, 404842 <strcmp+0xda>
  4047e6:	fa83 f54c 	uadd8	r5, r3, ip
  4047ea:	ea83 0507 	eor.w	r5, r3, r7
  4047ee:	faa5 f58c 	sel	r5, r5, ip
  4047f2:	b995      	cbnz	r5, 40481a <strcmp+0xb2>
  4047f4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
  4047f8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
  4047fc:	fa82 f54c 	uadd8	r5, r2, ip
  404800:	ea82 0406 	eor.w	r4, r2, r6
  404804:	faa4 f48c 	sel	r4, r4, ip
  404808:	fa83 f54c 	uadd8	r5, r3, ip
  40480c:	ea83 0507 	eor.w	r5, r3, r7
  404810:	faa5 f58c 	sel	r5, r5, ip
  404814:	4325      	orrs	r5, r4
  404816:	d0db      	beq.n	4047d0 <strcmp+0x68>
  404818:	b99c      	cbnz	r4, 404842 <strcmp+0xda>
  40481a:	ba2d      	rev	r5, r5
  40481c:	fab5 f485 	clz	r4, r5
  404820:	f024 0407 	bic.w	r4, r4, #7
  404824:	fa27 f104 	lsr.w	r1, r7, r4
  404828:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  40482c:	fa23 f304 	lsr.w	r3, r3, r4
  404830:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  404834:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  404838:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  40483c:	eba0 0001 	sub.w	r0, r0, r1
  404840:	4770      	bx	lr
  404842:	ba24      	rev	r4, r4
  404844:	fab4 f484 	clz	r4, r4
  404848:	f024 0407 	bic.w	r4, r4, #7
  40484c:	fa26 f104 	lsr.w	r1, r6, r4
  404850:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  404854:	fa22 f204 	lsr.w	r2, r2, r4
  404858:	f002 00ff 	and.w	r0, r2, #255	; 0xff
  40485c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  404860:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  404864:	eba0 0001 	sub.w	r0, r0, r1
  404868:	4770      	bx	lr
  40486a:	f014 0f03 	tst.w	r4, #3
  40486e:	d13c      	bne.n	4048ea <strcmp+0x182>
  404870:	f010 0403 	ands.w	r4, r0, #3
  404874:	d128      	bne.n	4048c8 <strcmp+0x160>
  404876:	f850 2b08 	ldr.w	r2, [r0], #8
  40487a:	f851 3b08 	ldr.w	r3, [r1], #8
  40487e:	fa82 f54c 	uadd8	r5, r2, ip
  404882:	ea82 0503 	eor.w	r5, r2, r3
  404886:	faa5 f58c 	sel	r5, r5, ip
  40488a:	b95d      	cbnz	r5, 4048a4 <strcmp+0x13c>
  40488c:	f850 2c04 	ldr.w	r2, [r0, #-4]
  404890:	f851 3c04 	ldr.w	r3, [r1, #-4]
  404894:	fa82 f54c 	uadd8	r5, r2, ip
  404898:	ea82 0503 	eor.w	r5, r2, r3
  40489c:	faa5 f58c 	sel	r5, r5, ip
  4048a0:	2d00      	cmp	r5, #0
  4048a2:	d0e8      	beq.n	404876 <strcmp+0x10e>
  4048a4:	ba2d      	rev	r5, r5
  4048a6:	fab5 f485 	clz	r4, r5
  4048aa:	f024 0407 	bic.w	r4, r4, #7
  4048ae:	fa23 f104 	lsr.w	r1, r3, r4
  4048b2:	fa22 f204 	lsr.w	r2, r2, r4
  4048b6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
  4048ba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  4048be:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  4048c2:	eba0 0001 	sub.w	r0, r0, r1
  4048c6:	4770      	bx	lr
  4048c8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
  4048cc:	f020 0003 	bic.w	r0, r0, #3
  4048d0:	f850 2b08 	ldr.w	r2, [r0], #8
  4048d4:	f021 0103 	bic.w	r1, r1, #3
  4048d8:	f851 3b08 	ldr.w	r3, [r1], #8
  4048dc:	fa0c f404 	lsl.w	r4, ip, r4
  4048e0:	ea62 0204 	orn	r2, r2, r4
  4048e4:	ea63 0304 	orn	r3, r3, r4
  4048e8:	e7c9      	b.n	40487e <strcmp+0x116>
  4048ea:	f010 0403 	ands.w	r4, r0, #3
  4048ee:	d01a      	beq.n	404926 <strcmp+0x1be>
  4048f0:	eba1 0104 	sub.w	r1, r1, r4
  4048f4:	f020 0003 	bic.w	r0, r0, #3
  4048f8:	07e4      	lsls	r4, r4, #31
  4048fa:	f850 2b04 	ldr.w	r2, [r0], #4
  4048fe:	d006      	beq.n	40490e <strcmp+0x1a6>
  404900:	d20f      	bcs.n	404922 <strcmp+0x1ba>
  404902:	788b      	ldrb	r3, [r1, #2]
  404904:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
  404908:	1ae4      	subs	r4, r4, r3
  40490a:	d106      	bne.n	40491a <strcmp+0x1b2>
  40490c:	b12b      	cbz	r3, 40491a <strcmp+0x1b2>
  40490e:	78cb      	ldrb	r3, [r1, #3]
  404910:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
  404914:	1ae4      	subs	r4, r4, r3
  404916:	d100      	bne.n	40491a <strcmp+0x1b2>
  404918:	b91b      	cbnz	r3, 404922 <strcmp+0x1ba>
  40491a:	4620      	mov	r0, r4
  40491c:	f85d 4b10 	ldr.w	r4, [sp], #16
  404920:	4770      	bx	lr
  404922:	f101 0104 	add.w	r1, r1, #4
  404926:	f850 2b04 	ldr.w	r2, [r0], #4
  40492a:	07cc      	lsls	r4, r1, #31
  40492c:	f021 0103 	bic.w	r1, r1, #3
  404930:	f851 3b04 	ldr.w	r3, [r1], #4
  404934:	d848      	bhi.n	4049c8 <strcmp+0x260>
  404936:	d224      	bcs.n	404982 <strcmp+0x21a>
  404938:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
  40493c:	fa82 f54c 	uadd8	r5, r2, ip
  404940:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
  404944:	faa5 f58c 	sel	r5, r5, ip
  404948:	d10a      	bne.n	404960 <strcmp+0x1f8>
  40494a:	b965      	cbnz	r5, 404966 <strcmp+0x1fe>
  40494c:	f851 3b04 	ldr.w	r3, [r1], #4
  404950:	ea84 0402 	eor.w	r4, r4, r2
  404954:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
  404958:	d10e      	bne.n	404978 <strcmp+0x210>
  40495a:	f850 2b04 	ldr.w	r2, [r0], #4
  40495e:	e7eb      	b.n	404938 <strcmp+0x1d0>
  404960:	ea4f 2313 	mov.w	r3, r3, lsr #8
  404964:	e055      	b.n	404a12 <strcmp+0x2aa>
  404966:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
  40496a:	d14d      	bne.n	404a08 <strcmp+0x2a0>
  40496c:	7808      	ldrb	r0, [r1, #0]
  40496e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  404972:	f1c0 0000 	rsb	r0, r0, #0
  404976:	4770      	bx	lr
  404978:	ea4f 6212 	mov.w	r2, r2, lsr #24
  40497c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
  404980:	e047      	b.n	404a12 <strcmp+0x2aa>
  404982:	ea02 441c 	and.w	r4, r2, ip, lsr #16
  404986:	fa82 f54c 	uadd8	r5, r2, ip
  40498a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
  40498e:	faa5 f58c 	sel	r5, r5, ip
  404992:	d10a      	bne.n	4049aa <strcmp+0x242>
  404994:	b965      	cbnz	r5, 4049b0 <strcmp+0x248>
  404996:	f851 3b04 	ldr.w	r3, [r1], #4
  40499a:	ea84 0402 	eor.w	r4, r4, r2
  40499e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
  4049a2:	d10c      	bne.n	4049be <strcmp+0x256>
  4049a4:	f850 2b04 	ldr.w	r2, [r0], #4
  4049a8:	e7eb      	b.n	404982 <strcmp+0x21a>
  4049aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
  4049ae:	e030      	b.n	404a12 <strcmp+0x2aa>
  4049b0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
  4049b4:	d128      	bne.n	404a08 <strcmp+0x2a0>
  4049b6:	880b      	ldrh	r3, [r1, #0]
  4049b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
  4049bc:	e029      	b.n	404a12 <strcmp+0x2aa>
  4049be:	ea4f 4212 	mov.w	r2, r2, lsr #16
  4049c2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
  4049c6:	e024      	b.n	404a12 <strcmp+0x2aa>
  4049c8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
  4049cc:	fa82 f54c 	uadd8	r5, r2, ip
  4049d0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
  4049d4:	faa5 f58c 	sel	r5, r5, ip
  4049d8:	d10a      	bne.n	4049f0 <strcmp+0x288>
  4049da:	b965      	cbnz	r5, 4049f6 <strcmp+0x28e>
  4049dc:	f851 3b04 	ldr.w	r3, [r1], #4
  4049e0:	ea84 0402 	eor.w	r4, r4, r2
  4049e4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
  4049e8:	d109      	bne.n	4049fe <strcmp+0x296>
  4049ea:	f850 2b04 	ldr.w	r2, [r0], #4
  4049ee:	e7eb      	b.n	4049c8 <strcmp+0x260>
  4049f0:	ea4f 6313 	mov.w	r3, r3, lsr #24
  4049f4:	e00d      	b.n	404a12 <strcmp+0x2aa>
  4049f6:	f015 0fff 	tst.w	r5, #255	; 0xff
  4049fa:	d105      	bne.n	404a08 <strcmp+0x2a0>
  4049fc:	680b      	ldr	r3, [r1, #0]
  4049fe:	ea4f 2212 	mov.w	r2, r2, lsr #8
  404a02:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  404a06:	e004      	b.n	404a12 <strcmp+0x2aa>
  404a08:	f04f 0000 	mov.w	r0, #0
  404a0c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  404a10:	4770      	bx	lr
  404a12:	ba12      	rev	r2, r2
  404a14:	ba1b      	rev	r3, r3
  404a16:	fa82 f44c 	uadd8	r4, r2, ip
  404a1a:	ea82 0403 	eor.w	r4, r2, r3
  404a1e:	faa4 f58c 	sel	r5, r4, ip
  404a22:	fab5 f485 	clz	r4, r5
  404a26:	fa02 f204 	lsl.w	r2, r2, r4
  404a2a:	fa03 f304 	lsl.w	r3, r3, r4
  404a2e:	ea4f 6012 	mov.w	r0, r2, lsr #24
  404a32:	e8fd 4504 	ldrd	r4, r5, [sp], #16
  404a36:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
  404a3a:	4770      	bx	lr

00404a3c <strcpy>:
  404a3c:	ea80 0201 	eor.w	r2, r0, r1
  404a40:	4684      	mov	ip, r0
  404a42:	f012 0f03 	tst.w	r2, #3
  404a46:	d14f      	bne.n	404ae8 <strcpy+0xac>
  404a48:	f011 0f03 	tst.w	r1, #3
  404a4c:	d132      	bne.n	404ab4 <strcpy+0x78>
  404a4e:	f84d 4d04 	str.w	r4, [sp, #-4]!
  404a52:	f011 0f04 	tst.w	r1, #4
  404a56:	f851 3b04 	ldr.w	r3, [r1], #4
  404a5a:	d00b      	beq.n	404a74 <strcpy+0x38>
  404a5c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  404a60:	439a      	bics	r2, r3
  404a62:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  404a66:	bf04      	itt	eq
  404a68:	f84c 3b04 	streq.w	r3, [ip], #4
  404a6c:	f851 3b04 	ldreq.w	r3, [r1], #4
  404a70:	d116      	bne.n	404aa0 <strcpy+0x64>
  404a72:	bf00      	nop
  404a74:	f851 4b04 	ldr.w	r4, [r1], #4
  404a78:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  404a7c:	439a      	bics	r2, r3
  404a7e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  404a82:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
  404a86:	d10b      	bne.n	404aa0 <strcpy+0x64>
  404a88:	f84c 3b04 	str.w	r3, [ip], #4
  404a8c:	43a2      	bics	r2, r4
  404a8e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  404a92:	bf04      	itt	eq
  404a94:	f851 3b04 	ldreq.w	r3, [r1], #4
  404a98:	f84c 4b04 	streq.w	r4, [ip], #4
  404a9c:	d0ea      	beq.n	404a74 <strcpy+0x38>
  404a9e:	4623      	mov	r3, r4
  404aa0:	f80c 3b01 	strb.w	r3, [ip], #1
  404aa4:	f013 0fff 	tst.w	r3, #255	; 0xff
  404aa8:	ea4f 2333 	mov.w	r3, r3, ror #8
  404aac:	d1f8      	bne.n	404aa0 <strcpy+0x64>
  404aae:	f85d 4b04 	ldr.w	r4, [sp], #4
  404ab2:	4770      	bx	lr
  404ab4:	f011 0f01 	tst.w	r1, #1
  404ab8:	d006      	beq.n	404ac8 <strcpy+0x8c>
  404aba:	f811 2b01 	ldrb.w	r2, [r1], #1
  404abe:	f80c 2b01 	strb.w	r2, [ip], #1
  404ac2:	2a00      	cmp	r2, #0
  404ac4:	bf08      	it	eq
  404ac6:	4770      	bxeq	lr
  404ac8:	f011 0f02 	tst.w	r1, #2
  404acc:	d0bf      	beq.n	404a4e <strcpy+0x12>
  404ace:	f831 2b02 	ldrh.w	r2, [r1], #2
  404ad2:	f012 0fff 	tst.w	r2, #255	; 0xff
  404ad6:	bf16      	itet	ne
  404ad8:	f82c 2b02 	strhne.w	r2, [ip], #2
  404adc:	f88c 2000 	strbeq.w	r2, [ip]
  404ae0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
  404ae4:	d1b3      	bne.n	404a4e <strcpy+0x12>
  404ae6:	4770      	bx	lr
  404ae8:	f811 2b01 	ldrb.w	r2, [r1], #1
  404aec:	f80c 2b01 	strb.w	r2, [ip], #1
  404af0:	2a00      	cmp	r2, #0
  404af2:	d1f9      	bne.n	404ae8 <strcpy+0xac>
  404af4:	4770      	bx	lr
  404af6:	bf00      	nop

00404af8 <strlen>:
  404af8:	f020 0103 	bic.w	r1, r0, #3
  404afc:	f010 0003 	ands.w	r0, r0, #3
  404b00:	f1c0 0000 	rsb	r0, r0, #0
  404b04:	f851 3b04 	ldr.w	r3, [r1], #4
  404b08:	f100 0c04 	add.w	ip, r0, #4
  404b0c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  404b10:	f06f 0200 	mvn.w	r2, #0
  404b14:	bf1c      	itt	ne
  404b16:	fa22 f20c 	lsrne.w	r2, r2, ip
  404b1a:	4313      	orrne	r3, r2
  404b1c:	f04f 0c01 	mov.w	ip, #1
  404b20:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  404b24:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  404b28:	eba3 020c 	sub.w	r2, r3, ip
  404b2c:	ea22 0203 	bic.w	r2, r2, r3
  404b30:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  404b34:	bf04      	itt	eq
  404b36:	f851 3b04 	ldreq.w	r3, [r1], #4
  404b3a:	3004      	addeq	r0, #4
  404b3c:	d0f4      	beq.n	404b28 <strlen+0x30>
  404b3e:	f1c2 0100 	rsb	r1, r2, #0
  404b42:	ea02 0201 	and.w	r2, r2, r1
  404b46:	fab2 f282 	clz	r2, r2
  404b4a:	f1c2 021f 	rsb	r2, r2, #31
  404b4e:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  404b52:	4770      	bx	lr

00404b54 <strncat>:
  404b54:	0783      	lsls	r3, r0, #30
  404b56:	b430      	push	{r4, r5}
  404b58:	d125      	bne.n	404ba6 <strncat+0x52>
  404b5a:	6804      	ldr	r4, [r0, #0]
  404b5c:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
  404b60:	ea23 0304 	bic.w	r3, r3, r4
  404b64:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  404b68:	4603      	mov	r3, r0
  404b6a:	d108      	bne.n	404b7e <strncat+0x2a>
  404b6c:	f853 5f04 	ldr.w	r5, [r3, #4]!
  404b70:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
  404b74:	ea24 0405 	bic.w	r4, r4, r5
  404b78:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  404b7c:	d0f6      	beq.n	404b6c <strncat+0x18>
  404b7e:	781c      	ldrb	r4, [r3, #0]
  404b80:	b11c      	cbz	r4, 404b8a <strncat+0x36>
  404b82:	f813 4f01 	ldrb.w	r4, [r3, #1]!
  404b86:	2c00      	cmp	r4, #0
  404b88:	d1fb      	bne.n	404b82 <strncat+0x2e>
  404b8a:	189d      	adds	r5, r3, r2
  404b8c:	e005      	b.n	404b9a <strncat+0x46>
  404b8e:	f811 4b01 	ldrb.w	r4, [r1], #1
  404b92:	f803 4b01 	strb.w	r4, [r3], #1
  404b96:	b124      	cbz	r4, 404ba2 <strncat+0x4e>
  404b98:	b13a      	cbz	r2, 404baa <strncat+0x56>
  404b9a:	42ab      	cmp	r3, r5
  404b9c:	f102 32ff 	add.w	r2, r2, #4294967295
  404ba0:	d1f5      	bne.n	404b8e <strncat+0x3a>
  404ba2:	bc30      	pop	{r4, r5}
  404ba4:	4770      	bx	lr
  404ba6:	4603      	mov	r3, r0
  404ba8:	e7e9      	b.n	404b7e <strncat+0x2a>
  404baa:	701a      	strb	r2, [r3, #0]
  404bac:	e7f5      	b.n	404b9a <strncat+0x46>
  404bae:	bf00      	nop

00404bb0 <strncmp>:
  404bb0:	2a00      	cmp	r2, #0
  404bb2:	d03e      	beq.n	404c32 <strncmp+0x82>
  404bb4:	ea40 0301 	orr.w	r3, r0, r1
  404bb8:	f013 0303 	ands.w	r3, r3, #3
  404bbc:	b4f0      	push	{r4, r5, r6, r7}
  404bbe:	d125      	bne.n	404c0c <strncmp+0x5c>
  404bc0:	2a03      	cmp	r2, #3
  404bc2:	d923      	bls.n	404c0c <strncmp+0x5c>
  404bc4:	6804      	ldr	r4, [r0, #0]
  404bc6:	680d      	ldr	r5, [r1, #0]
  404bc8:	42ac      	cmp	r4, r5
  404bca:	d11f      	bne.n	404c0c <strncmp+0x5c>
  404bcc:	3a04      	subs	r2, #4
  404bce:	d032      	beq.n	404c36 <strncmp+0x86>
  404bd0:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  404bd4:	ea25 0404 	bic.w	r4, r5, r4
  404bd8:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  404bdc:	d12e      	bne.n	404c3c <strncmp+0x8c>
  404bde:	1d07      	adds	r7, r0, #4
  404be0:	1d0d      	adds	r5, r1, #4
  404be2:	e00d      	b.n	404c00 <strncmp+0x50>
  404be4:	f857 3b04 	ldr.w	r3, [r7], #4
  404be8:	680e      	ldr	r6, [r1, #0]
  404bea:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
  404bee:	42b3      	cmp	r3, r6
  404bf0:	ea24 0403 	bic.w	r4, r4, r3
  404bf4:	d10a      	bne.n	404c0c <strncmp+0x5c>
  404bf6:	3a04      	subs	r2, #4
  404bf8:	d01d      	beq.n	404c36 <strncmp+0x86>
  404bfa:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  404bfe:	d120      	bne.n	404c42 <strncmp+0x92>
  404c00:	2a03      	cmp	r2, #3
  404c02:	4629      	mov	r1, r5
  404c04:	4638      	mov	r0, r7
  404c06:	f105 0504 	add.w	r5, r5, #4
  404c0a:	d8eb      	bhi.n	404be4 <strncmp+0x34>
  404c0c:	7803      	ldrb	r3, [r0, #0]
  404c0e:	780c      	ldrb	r4, [r1, #0]
  404c10:	42a3      	cmp	r3, r4
  404c12:	f102 32ff 	add.w	r2, r2, #4294967295
  404c16:	d109      	bne.n	404c2c <strncmp+0x7c>
  404c18:	b16a      	cbz	r2, 404c36 <strncmp+0x86>
  404c1a:	b17b      	cbz	r3, 404c3c <strncmp+0x8c>
  404c1c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  404c20:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  404c24:	42a3      	cmp	r3, r4
  404c26:	f102 32ff 	add.w	r2, r2, #4294967295
  404c2a:	d0f5      	beq.n	404c18 <strncmp+0x68>
  404c2c:	1b18      	subs	r0, r3, r4
  404c2e:	bcf0      	pop	{r4, r5, r6, r7}
  404c30:	4770      	bx	lr
  404c32:	4610      	mov	r0, r2
  404c34:	4770      	bx	lr
  404c36:	4610      	mov	r0, r2
  404c38:	bcf0      	pop	{r4, r5, r6, r7}
  404c3a:	4770      	bx	lr
  404c3c:	4618      	mov	r0, r3
  404c3e:	bcf0      	pop	{r4, r5, r6, r7}
  404c40:	4770      	bx	lr
  404c42:	2000      	movs	r0, #0
  404c44:	e7f3      	b.n	404c2e <strncmp+0x7e>
  404c46:	bf00      	nop

00404c48 <strncpy>:
  404c48:	ea40 0301 	orr.w	r3, r0, r1
  404c4c:	079b      	lsls	r3, r3, #30
  404c4e:	b470      	push	{r4, r5, r6}
  404c50:	d12b      	bne.n	404caa <strncpy+0x62>
  404c52:	2a03      	cmp	r2, #3
  404c54:	d929      	bls.n	404caa <strncpy+0x62>
  404c56:	460c      	mov	r4, r1
  404c58:	4603      	mov	r3, r0
  404c5a:	4621      	mov	r1, r4
  404c5c:	f854 6b04 	ldr.w	r6, [r4], #4
  404c60:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
  404c64:	ea25 0506 	bic.w	r5, r5, r6
  404c68:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  404c6c:	d105      	bne.n	404c7a <strncpy+0x32>
  404c6e:	3a04      	subs	r2, #4
  404c70:	2a03      	cmp	r2, #3
  404c72:	f843 6b04 	str.w	r6, [r3], #4
  404c76:	4621      	mov	r1, r4
  404c78:	d8ef      	bhi.n	404c5a <strncpy+0x12>
  404c7a:	b1a2      	cbz	r2, 404ca6 <strncpy+0x5e>
  404c7c:	780c      	ldrb	r4, [r1, #0]
  404c7e:	701c      	strb	r4, [r3, #0]
  404c80:	3a01      	subs	r2, #1
  404c82:	3301      	adds	r3, #1
  404c84:	3101      	adds	r1, #1
  404c86:	b13c      	cbz	r4, 404c98 <strncpy+0x50>
  404c88:	b16a      	cbz	r2, 404ca6 <strncpy+0x5e>
  404c8a:	f811 4b01 	ldrb.w	r4, [r1], #1
  404c8e:	f803 4b01 	strb.w	r4, [r3], #1
  404c92:	3a01      	subs	r2, #1
  404c94:	2c00      	cmp	r4, #0
  404c96:	d1f7      	bne.n	404c88 <strncpy+0x40>
  404c98:	b12a      	cbz	r2, 404ca6 <strncpy+0x5e>
  404c9a:	441a      	add	r2, r3
  404c9c:	2100      	movs	r1, #0
  404c9e:	f803 1b01 	strb.w	r1, [r3], #1
  404ca2:	4293      	cmp	r3, r2
  404ca4:	d1fb      	bne.n	404c9e <strncpy+0x56>
  404ca6:	bc70      	pop	{r4, r5, r6}
  404ca8:	4770      	bx	lr
  404caa:	4603      	mov	r3, r0
  404cac:	e7e5      	b.n	404c7a <strncpy+0x32>
  404cae:	bf00      	nop

00404cb0 <_strtol_r>:
  404cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404cb4:	4c44      	ldr	r4, [pc, #272]	; (404dc8 <_strtol_r+0x118>)
  404cb6:	4683      	mov	fp, r0
  404cb8:	460e      	mov	r6, r1
  404cba:	f8d4 e000 	ldr.w	lr, [r4]
  404cbe:	e000      	b.n	404cc2 <_strtol_r+0x12>
  404cc0:	4626      	mov	r6, r4
  404cc2:	4634      	mov	r4, r6
  404cc4:	f814 5b01 	ldrb.w	r5, [r4], #1
  404cc8:	eb0e 0005 	add.w	r0, lr, r5
  404ccc:	7840      	ldrb	r0, [r0, #1]
  404cce:	f000 0008 	and.w	r0, r0, #8
  404cd2:	f000 08ff 	and.w	r8, r0, #255	; 0xff
  404cd6:	2800      	cmp	r0, #0
  404cd8:	d1f2      	bne.n	404cc0 <_strtol_r+0x10>
  404cda:	2d2d      	cmp	r5, #45	; 0x2d
  404cdc:	d04b      	beq.n	404d76 <_strtol_r+0xc6>
  404cde:	2d2b      	cmp	r5, #43	; 0x2b
  404ce0:	bf04      	itt	eq
  404ce2:	7875      	ldrbeq	r5, [r6, #1]
  404ce4:	1cb4      	addeq	r4, r6, #2
  404ce6:	b11b      	cbz	r3, 404cf0 <_strtol_r+0x40>
  404ce8:	2b10      	cmp	r3, #16
  404cea:	d060      	beq.n	404dae <_strtol_r+0xfe>
  404cec:	469a      	mov	sl, r3
  404cee:	e003      	b.n	404cf8 <_strtol_r+0x48>
  404cf0:	2d30      	cmp	r5, #48	; 0x30
  404cf2:	d054      	beq.n	404d9e <_strtol_r+0xee>
  404cf4:	230a      	movs	r3, #10
  404cf6:	469a      	mov	sl, r3
  404cf8:	f1b8 0f00 	cmp.w	r8, #0
  404cfc:	bf14      	ite	ne
  404cfe:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  404d02:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  404d06:	2700      	movs	r7, #0
  404d08:	fbb0 f9fa 	udiv	r9, r0, sl
  404d0c:	46bc      	mov	ip, r7
  404d0e:	fb0a 0019 	mls	r0, sl, r9, r0
  404d12:	e00c      	b.n	404d2e <_strtol_r+0x7e>
  404d14:	3d30      	subs	r5, #48	; 0x30
  404d16:	42ab      	cmp	r3, r5
  404d18:	dd19      	ble.n	404d4e <_strtol_r+0x9e>
  404d1a:	1c7e      	adds	r6, r7, #1
  404d1c:	d005      	beq.n	404d2a <_strtol_r+0x7a>
  404d1e:	45cc      	cmp	ip, r9
  404d20:	d824      	bhi.n	404d6c <_strtol_r+0xbc>
  404d22:	d021      	beq.n	404d68 <_strtol_r+0xb8>
  404d24:	fb0a 5c0c 	mla	ip, sl, ip, r5
  404d28:	2701      	movs	r7, #1
  404d2a:	f814 5b01 	ldrb.w	r5, [r4], #1
  404d2e:	eb0e 0605 	add.w	r6, lr, r5
  404d32:	7876      	ldrb	r6, [r6, #1]
  404d34:	f016 0f04 	tst.w	r6, #4
  404d38:	d1ec      	bne.n	404d14 <_strtol_r+0x64>
  404d3a:	f016 0603 	ands.w	r6, r6, #3
  404d3e:	d006      	beq.n	404d4e <_strtol_r+0x9e>
  404d40:	2e01      	cmp	r6, #1
  404d42:	bf0c      	ite	eq
  404d44:	2637      	moveq	r6, #55	; 0x37
  404d46:	2657      	movne	r6, #87	; 0x57
  404d48:	1bad      	subs	r5, r5, r6
  404d4a:	42ab      	cmp	r3, r5
  404d4c:	dce5      	bgt.n	404d1a <_strtol_r+0x6a>
  404d4e:	1c7b      	adds	r3, r7, #1
  404d50:	d016      	beq.n	404d80 <_strtol_r+0xd0>
  404d52:	f1c8 0000 	rsb	r0, r8, #0
  404d56:	ea8c 0000 	eor.w	r0, ip, r0
  404d5a:	4440      	add	r0, r8
  404d5c:	b14a      	cbz	r2, 404d72 <_strtol_r+0xc2>
  404d5e:	b107      	cbz	r7, 404d62 <_strtol_r+0xb2>
  404d60:	1e61      	subs	r1, r4, #1
  404d62:	6011      	str	r1, [r2, #0]
  404d64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404d68:	4285      	cmp	r5, r0
  404d6a:	dddb      	ble.n	404d24 <_strtol_r+0x74>
  404d6c:	f04f 37ff 	mov.w	r7, #4294967295
  404d70:	e7db      	b.n	404d2a <_strtol_r+0x7a>
  404d72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404d76:	1cb4      	adds	r4, r6, #2
  404d78:	7875      	ldrb	r5, [r6, #1]
  404d7a:	f04f 0801 	mov.w	r8, #1
  404d7e:	e7b2      	b.n	404ce6 <_strtol_r+0x36>
  404d80:	f1b8 0f00 	cmp.w	r8, #0
  404d84:	f04f 0322 	mov.w	r3, #34	; 0x22
  404d88:	bf14      	ite	ne
  404d8a:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  404d8e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  404d92:	f8cb 3000 	str.w	r3, [fp]
  404d96:	2a00      	cmp	r2, #0
  404d98:	d1e2      	bne.n	404d60 <_strtol_r+0xb0>
  404d9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404d9e:	7823      	ldrb	r3, [r4, #0]
  404da0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  404da4:	2b58      	cmp	r3, #88	; 0x58
  404da6:	d009      	beq.n	404dbc <_strtol_r+0x10c>
  404da8:	2308      	movs	r3, #8
  404daa:	469a      	mov	sl, r3
  404dac:	e7a4      	b.n	404cf8 <_strtol_r+0x48>
  404dae:	2d30      	cmp	r5, #48	; 0x30
  404db0:	d19c      	bne.n	404cec <_strtol_r+0x3c>
  404db2:	7820      	ldrb	r0, [r4, #0]
  404db4:	f000 00df 	and.w	r0, r0, #223	; 0xdf
  404db8:	2858      	cmp	r0, #88	; 0x58
  404dba:	d197      	bne.n	404cec <_strtol_r+0x3c>
  404dbc:	f04f 0a10 	mov.w	sl, #16
  404dc0:	7865      	ldrb	r5, [r4, #1]
  404dc2:	4653      	mov	r3, sl
  404dc4:	3402      	adds	r4, #2
  404dc6:	e797      	b.n	404cf8 <_strtol_r+0x48>
  404dc8:	20000624 	.word	0x20000624

00404dcc <strtol>:
  404dcc:	b430      	push	{r4, r5}
  404dce:	4c04      	ldr	r4, [pc, #16]	; (404de0 <strtol+0x14>)
  404dd0:	460d      	mov	r5, r1
  404dd2:	4613      	mov	r3, r2
  404dd4:	4601      	mov	r1, r0
  404dd6:	462a      	mov	r2, r5
  404dd8:	6820      	ldr	r0, [r4, #0]
  404dda:	bc30      	pop	{r4, r5}
  404ddc:	f7ff bf68 	b.w	404cb0 <_strtol_r>
  404de0:	20000620 	.word	0x20000620

00404de4 <_svfprintf_r>:
  404de4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404de8:	b0c1      	sub	sp, #260	; 0x104
  404dea:	4689      	mov	r9, r1
  404dec:	920a      	str	r2, [sp, #40]	; 0x28
  404dee:	930e      	str	r3, [sp, #56]	; 0x38
  404df0:	9008      	str	r0, [sp, #32]
  404df2:	f002 fb6f 	bl	4074d4 <_localeconv_r>
  404df6:	6803      	ldr	r3, [r0, #0]
  404df8:	9317      	str	r3, [sp, #92]	; 0x5c
  404dfa:	4618      	mov	r0, r3
  404dfc:	f7ff fe7c 	bl	404af8 <strlen>
  404e00:	f8b9 300c 	ldrh.w	r3, [r9, #12]
  404e04:	9018      	str	r0, [sp, #96]	; 0x60
  404e06:	061a      	lsls	r2, r3, #24
  404e08:	d504      	bpl.n	404e14 <_svfprintf_r+0x30>
  404e0a:	f8d9 3010 	ldr.w	r3, [r9, #16]
  404e0e:	2b00      	cmp	r3, #0
  404e10:	f001 808c 	beq.w	405f2c <_svfprintf_r+0x1148>
  404e14:	2300      	movs	r3, #0
  404e16:	af30      	add	r7, sp, #192	; 0xc0
  404e18:	9313      	str	r3, [sp, #76]	; 0x4c
  404e1a:	9325      	str	r3, [sp, #148]	; 0x94
  404e1c:	9324      	str	r3, [sp, #144]	; 0x90
  404e1e:	9316      	str	r3, [sp, #88]	; 0x58
  404e20:	9319      	str	r3, [sp, #100]	; 0x64
  404e22:	930b      	str	r3, [sp, #44]	; 0x2c
  404e24:	9723      	str	r7, [sp, #140]	; 0x8c
  404e26:	9314      	str	r3, [sp, #80]	; 0x50
  404e28:	9315      	str	r3, [sp, #84]	; 0x54
  404e2a:	463c      	mov	r4, r7
  404e2c:	464e      	mov	r6, r9
  404e2e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  404e30:	782b      	ldrb	r3, [r5, #0]
  404e32:	2b00      	cmp	r3, #0
  404e34:	f000 80a9 	beq.w	404f8a <_svfprintf_r+0x1a6>
  404e38:	2b25      	cmp	r3, #37	; 0x25
  404e3a:	d102      	bne.n	404e42 <_svfprintf_r+0x5e>
  404e3c:	e0a5      	b.n	404f8a <_svfprintf_r+0x1a6>
  404e3e:	2b25      	cmp	r3, #37	; 0x25
  404e40:	d003      	beq.n	404e4a <_svfprintf_r+0x66>
  404e42:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  404e46:	2b00      	cmp	r3, #0
  404e48:	d1f9      	bne.n	404e3e <_svfprintf_r+0x5a>
  404e4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  404e4c:	1aeb      	subs	r3, r5, r3
  404e4e:	b173      	cbz	r3, 404e6e <_svfprintf_r+0x8a>
  404e50:	9a24      	ldr	r2, [sp, #144]	; 0x90
  404e52:	9925      	ldr	r1, [sp, #148]	; 0x94
  404e54:	980a      	ldr	r0, [sp, #40]	; 0x28
  404e56:	6020      	str	r0, [r4, #0]
  404e58:	3201      	adds	r2, #1
  404e5a:	4419      	add	r1, r3
  404e5c:	2a07      	cmp	r2, #7
  404e5e:	6063      	str	r3, [r4, #4]
  404e60:	9125      	str	r1, [sp, #148]	; 0x94
  404e62:	9224      	str	r2, [sp, #144]	; 0x90
  404e64:	dc72      	bgt.n	404f4c <_svfprintf_r+0x168>
  404e66:	3408      	adds	r4, #8
  404e68:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  404e6a:	441a      	add	r2, r3
  404e6c:	920b      	str	r2, [sp, #44]	; 0x2c
  404e6e:	782b      	ldrb	r3, [r5, #0]
  404e70:	2b00      	cmp	r3, #0
  404e72:	f000 87b5 	beq.w	405de0 <_svfprintf_r+0xffc>
  404e76:	2300      	movs	r3, #0
  404e78:	1c69      	adds	r1, r5, #1
  404e7a:	786d      	ldrb	r5, [r5, #1]
  404e7c:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  404e80:	461a      	mov	r2, r3
  404e82:	930c      	str	r3, [sp, #48]	; 0x30
  404e84:	9307      	str	r3, [sp, #28]
  404e86:	f04f 3aff 	mov.w	sl, #4294967295
  404e8a:	1c4b      	adds	r3, r1, #1
  404e8c:	f1a5 0120 	sub.w	r1, r5, #32
  404e90:	2958      	cmp	r1, #88	; 0x58
  404e92:	f200 83d9 	bhi.w	405648 <_svfprintf_r+0x864>
  404e96:	e8df f011 	tbh	[pc, r1, lsl #1]
  404e9a:	0270      	.short	0x0270
  404e9c:	03d703d7 	.word	0x03d703d7
  404ea0:	03d70374 	.word	0x03d70374
  404ea4:	03d703d7 	.word	0x03d703d7
  404ea8:	03d703d7 	.word	0x03d703d7
  404eac:	02f003d7 	.word	0x02f003d7
  404eb0:	03d7020d 	.word	0x03d7020d
  404eb4:	021101f4 	.word	0x021101f4
  404eb8:	037b03d7 	.word	0x037b03d7
  404ebc:	02ba02ba 	.word	0x02ba02ba
  404ec0:	02ba02ba 	.word	0x02ba02ba
  404ec4:	02ba02ba 	.word	0x02ba02ba
  404ec8:	02ba02ba 	.word	0x02ba02ba
  404ecc:	03d702ba 	.word	0x03d702ba
  404ed0:	03d703d7 	.word	0x03d703d7
  404ed4:	03d703d7 	.word	0x03d703d7
  404ed8:	03d703d7 	.word	0x03d703d7
  404edc:	03d703d7 	.word	0x03d703d7
  404ee0:	02c903d7 	.word	0x02c903d7
  404ee4:	03d7038b 	.word	0x03d7038b
  404ee8:	03d7038b 	.word	0x03d7038b
  404eec:	03d703d7 	.word	0x03d703d7
  404ef0:	036d03d7 	.word	0x036d03d7
  404ef4:	03d703d7 	.word	0x03d703d7
  404ef8:	03d70305 	.word	0x03d70305
  404efc:	03d703d7 	.word	0x03d703d7
  404f00:	03d703d7 	.word	0x03d703d7
  404f04:	03d70323 	.word	0x03d70323
  404f08:	033d03d7 	.word	0x033d03d7
  404f0c:	03d703d7 	.word	0x03d703d7
  404f10:	03d703d7 	.word	0x03d703d7
  404f14:	03d703d7 	.word	0x03d703d7
  404f18:	03d703d7 	.word	0x03d703d7
  404f1c:	03d703d7 	.word	0x03d703d7
  404f20:	022c0358 	.word	0x022c0358
  404f24:	038b038b 	.word	0x038b038b
  404f28:	02fe038b 	.word	0x02fe038b
  404f2c:	03d7022c 	.word	0x03d7022c
  404f30:	02e603d7 	.word	0x02e603d7
  404f34:	027e03d7 	.word	0x027e03d7
  404f38:	03c001fb 	.word	0x03c001fb
  404f3c:	03d70277 	.word	0x03d70277
  404f40:	03d70292 	.word	0x03d70292
  404f44:	03d7007a 	.word	0x03d7007a
  404f48:	024a03d7 	.word	0x024a03d7
  404f4c:	9808      	ldr	r0, [sp, #32]
  404f4e:	9307      	str	r3, [sp, #28]
  404f50:	4631      	mov	r1, r6
  404f52:	aa23      	add	r2, sp, #140	; 0x8c
  404f54:	f003 fb2e 	bl	4085b4 <__ssprint_r>
  404f58:	b950      	cbnz	r0, 404f70 <_svfprintf_r+0x18c>
  404f5a:	463c      	mov	r4, r7
  404f5c:	9b07      	ldr	r3, [sp, #28]
  404f5e:	e783      	b.n	404e68 <_svfprintf_r+0x84>
  404f60:	9808      	ldr	r0, [sp, #32]
  404f62:	4631      	mov	r1, r6
  404f64:	aa23      	add	r2, sp, #140	; 0x8c
  404f66:	f003 fb25 	bl	4085b4 <__ssprint_r>
  404f6a:	2800      	cmp	r0, #0
  404f6c:	f000 8185 	beq.w	40527a <_svfprintf_r+0x496>
  404f70:	46b1      	mov	r9, r6
  404f72:	f8b9 300c 	ldrh.w	r3, [r9, #12]
  404f76:	f013 0f40 	tst.w	r3, #64	; 0x40
  404f7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  404f7c:	bf18      	it	ne
  404f7e:	f04f 33ff 	movne.w	r3, #4294967295
  404f82:	4618      	mov	r0, r3
  404f84:	b041      	add	sp, #260	; 0x104
  404f86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404f8a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  404f8c:	e76f      	b.n	404e6e <_svfprintf_r+0x8a>
  404f8e:	930a      	str	r3, [sp, #40]	; 0x28
  404f90:	9b07      	ldr	r3, [sp, #28]
  404f92:	0698      	lsls	r0, r3, #26
  404f94:	f140 82ad 	bpl.w	4054f2 <_svfprintf_r+0x70e>
  404f98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  404f9a:	f103 0907 	add.w	r9, r3, #7
  404f9e:	f029 0307 	bic.w	r3, r9, #7
  404fa2:	f103 0208 	add.w	r2, r3, #8
  404fa6:	e9d3 8900 	ldrd	r8, r9, [r3]
  404faa:	920e      	str	r2, [sp, #56]	; 0x38
  404fac:	2301      	movs	r3, #1
  404fae:	f04f 0c00 	mov.w	ip, #0
  404fb2:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  404fb6:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  404fba:	f1ba 0f00 	cmp.w	sl, #0
  404fbe:	db03      	blt.n	404fc8 <_svfprintf_r+0x1e4>
  404fc0:	9a07      	ldr	r2, [sp, #28]
  404fc2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  404fc6:	9207      	str	r2, [sp, #28]
  404fc8:	ea58 0209 	orrs.w	r2, r8, r9
  404fcc:	f040 834c 	bne.w	405668 <_svfprintf_r+0x884>
  404fd0:	f1ba 0f00 	cmp.w	sl, #0
  404fd4:	f000 8451 	beq.w	40587a <_svfprintf_r+0xa96>
  404fd8:	2b01      	cmp	r3, #1
  404fda:	f000 834f 	beq.w	40567c <_svfprintf_r+0x898>
  404fde:	2b02      	cmp	r3, #2
  404fe0:	f000 8490 	beq.w	405904 <_svfprintf_r+0xb20>
  404fe4:	4639      	mov	r1, r7
  404fe6:	ea4f 02d8 	mov.w	r2, r8, lsr #3
  404fea:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
  404fee:	ea4f 00d9 	mov.w	r0, r9, lsr #3
  404ff2:	f008 0307 	and.w	r3, r8, #7
  404ff6:	4681      	mov	r9, r0
  404ff8:	4690      	mov	r8, r2
  404ffa:	3330      	adds	r3, #48	; 0x30
  404ffc:	ea58 0209 	orrs.w	r2, r8, r9
  405000:	f801 3d01 	strb.w	r3, [r1, #-1]!
  405004:	d1ef      	bne.n	404fe6 <_svfprintf_r+0x202>
  405006:	9a07      	ldr	r2, [sp, #28]
  405008:	9110      	str	r1, [sp, #64]	; 0x40
  40500a:	07d2      	lsls	r2, r2, #31
  40500c:	f100 8544 	bmi.w	405a98 <_svfprintf_r+0xcb4>
  405010:	1a7b      	subs	r3, r7, r1
  405012:	930d      	str	r3, [sp, #52]	; 0x34
  405014:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  405016:	4592      	cmp	sl, r2
  405018:	4653      	mov	r3, sl
  40501a:	bfb8      	it	lt
  40501c:	4613      	movlt	r3, r2
  40501e:	9309      	str	r3, [sp, #36]	; 0x24
  405020:	2300      	movs	r3, #0
  405022:	9312      	str	r3, [sp, #72]	; 0x48
  405024:	f1bc 0f00 	cmp.w	ip, #0
  405028:	d002      	beq.n	405030 <_svfprintf_r+0x24c>
  40502a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40502c:	3301      	adds	r3, #1
  40502e:	9309      	str	r3, [sp, #36]	; 0x24
  405030:	9b07      	ldr	r3, [sp, #28]
  405032:	f013 0302 	ands.w	r3, r3, #2
  405036:	930f      	str	r3, [sp, #60]	; 0x3c
  405038:	d002      	beq.n	405040 <_svfprintf_r+0x25c>
  40503a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40503c:	3302      	adds	r3, #2
  40503e:	9309      	str	r3, [sp, #36]	; 0x24
  405040:	9b07      	ldr	r3, [sp, #28]
  405042:	f013 0984 	ands.w	r9, r3, #132	; 0x84
  405046:	f040 830c 	bne.w	405662 <_svfprintf_r+0x87e>
  40504a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40504c:	9a09      	ldr	r2, [sp, #36]	; 0x24
  40504e:	ebc2 0803 	rsb	r8, r2, r3
  405052:	f1b8 0f00 	cmp.w	r8, #0
  405056:	f340 8304 	ble.w	405662 <_svfprintf_r+0x87e>
  40505a:	f1b8 0f10 	cmp.w	r8, #16
  40505e:	9925      	ldr	r1, [sp, #148]	; 0x94
  405060:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405062:	f8df a544 	ldr.w	sl, [pc, #1348]	; 4055a8 <_svfprintf_r+0x7c4>
  405066:	dd29      	ble.n	4050bc <_svfprintf_r+0x2d8>
  405068:	4653      	mov	r3, sl
  40506a:	f04f 0b10 	mov.w	fp, #16
  40506e:	46c2      	mov	sl, r8
  405070:	46a8      	mov	r8, r5
  405072:	461d      	mov	r5, r3
  405074:	e006      	b.n	405084 <_svfprintf_r+0x2a0>
  405076:	f1aa 0a10 	sub.w	sl, sl, #16
  40507a:	f1ba 0f10 	cmp.w	sl, #16
  40507e:	f104 0408 	add.w	r4, r4, #8
  405082:	dd17      	ble.n	4050b4 <_svfprintf_r+0x2d0>
  405084:	3201      	adds	r2, #1
  405086:	3110      	adds	r1, #16
  405088:	2a07      	cmp	r2, #7
  40508a:	9125      	str	r1, [sp, #148]	; 0x94
  40508c:	9224      	str	r2, [sp, #144]	; 0x90
  40508e:	e884 0820 	stmia.w	r4, {r5, fp}
  405092:	ddf0      	ble.n	405076 <_svfprintf_r+0x292>
  405094:	9808      	ldr	r0, [sp, #32]
  405096:	4631      	mov	r1, r6
  405098:	aa23      	add	r2, sp, #140	; 0x8c
  40509a:	f003 fa8b 	bl	4085b4 <__ssprint_r>
  40509e:	2800      	cmp	r0, #0
  4050a0:	f47f af66 	bne.w	404f70 <_svfprintf_r+0x18c>
  4050a4:	f1aa 0a10 	sub.w	sl, sl, #16
  4050a8:	f1ba 0f10 	cmp.w	sl, #16
  4050ac:	9925      	ldr	r1, [sp, #148]	; 0x94
  4050ae:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4050b0:	463c      	mov	r4, r7
  4050b2:	dce7      	bgt.n	405084 <_svfprintf_r+0x2a0>
  4050b4:	462b      	mov	r3, r5
  4050b6:	4645      	mov	r5, r8
  4050b8:	46d0      	mov	r8, sl
  4050ba:	469a      	mov	sl, r3
  4050bc:	3201      	adds	r2, #1
  4050be:	eb08 0b01 	add.w	fp, r8, r1
  4050c2:	2a07      	cmp	r2, #7
  4050c4:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4050c8:	9224      	str	r2, [sp, #144]	; 0x90
  4050ca:	f8c4 a000 	str.w	sl, [r4]
  4050ce:	f8c4 8004 	str.w	r8, [r4, #4]
  4050d2:	f300 847b 	bgt.w	4059cc <_svfprintf_r+0xbe8>
  4050d6:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4050da:	3408      	adds	r4, #8
  4050dc:	f1bc 0f00 	cmp.w	ip, #0
  4050e0:	d00f      	beq.n	405102 <_svfprintf_r+0x31e>
  4050e2:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4050e4:	3301      	adds	r3, #1
  4050e6:	f10b 0b01 	add.w	fp, fp, #1
  4050ea:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
  4050ee:	2201      	movs	r2, #1
  4050f0:	2b07      	cmp	r3, #7
  4050f2:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4050f6:	9324      	str	r3, [sp, #144]	; 0x90
  4050f8:	e884 0006 	stmia.w	r4, {r1, r2}
  4050fc:	f300 83da 	bgt.w	4058b4 <_svfprintf_r+0xad0>
  405100:	3408      	adds	r4, #8
  405102:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  405104:	b173      	cbz	r3, 405124 <_svfprintf_r+0x340>
  405106:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405108:	3301      	adds	r3, #1
  40510a:	f10b 0b02 	add.w	fp, fp, #2
  40510e:	a91c      	add	r1, sp, #112	; 0x70
  405110:	2202      	movs	r2, #2
  405112:	2b07      	cmp	r3, #7
  405114:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405118:	9324      	str	r3, [sp, #144]	; 0x90
  40511a:	e884 0006 	stmia.w	r4, {r1, r2}
  40511e:	f300 83d5 	bgt.w	4058cc <_svfprintf_r+0xae8>
  405122:	3408      	adds	r4, #8
  405124:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
  405128:	f000 8311 	beq.w	40574e <_svfprintf_r+0x96a>
  40512c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  40512e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  405130:	ebc2 0a03 	rsb	sl, r2, r3
  405134:	f1ba 0f00 	cmp.w	sl, #0
  405138:	dd3c      	ble.n	4051b4 <_svfprintf_r+0x3d0>
  40513a:	f1ba 0f10 	cmp.w	sl, #16
  40513e:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405140:	f8df 9468 	ldr.w	r9, [pc, #1128]	; 4055ac <_svfprintf_r+0x7c8>
  405144:	dd2b      	ble.n	40519e <_svfprintf_r+0x3ba>
  405146:	4649      	mov	r1, r9
  405148:	465b      	mov	r3, fp
  40514a:	46a9      	mov	r9, r5
  40514c:	f04f 0810 	mov.w	r8, #16
  405150:	f8dd b020 	ldr.w	fp, [sp, #32]
  405154:	460d      	mov	r5, r1
  405156:	e006      	b.n	405166 <_svfprintf_r+0x382>
  405158:	f1aa 0a10 	sub.w	sl, sl, #16
  40515c:	f1ba 0f10 	cmp.w	sl, #16
  405160:	f104 0408 	add.w	r4, r4, #8
  405164:	dd17      	ble.n	405196 <_svfprintf_r+0x3b2>
  405166:	3201      	adds	r2, #1
  405168:	3310      	adds	r3, #16
  40516a:	2a07      	cmp	r2, #7
  40516c:	9325      	str	r3, [sp, #148]	; 0x94
  40516e:	9224      	str	r2, [sp, #144]	; 0x90
  405170:	e884 0120 	stmia.w	r4, {r5, r8}
  405174:	ddf0      	ble.n	405158 <_svfprintf_r+0x374>
  405176:	4658      	mov	r0, fp
  405178:	4631      	mov	r1, r6
  40517a:	aa23      	add	r2, sp, #140	; 0x8c
  40517c:	f003 fa1a 	bl	4085b4 <__ssprint_r>
  405180:	2800      	cmp	r0, #0
  405182:	f47f aef5 	bne.w	404f70 <_svfprintf_r+0x18c>
  405186:	f1aa 0a10 	sub.w	sl, sl, #16
  40518a:	f1ba 0f10 	cmp.w	sl, #16
  40518e:	9b25      	ldr	r3, [sp, #148]	; 0x94
  405190:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405192:	463c      	mov	r4, r7
  405194:	dce7      	bgt.n	405166 <_svfprintf_r+0x382>
  405196:	469b      	mov	fp, r3
  405198:	462b      	mov	r3, r5
  40519a:	464d      	mov	r5, r9
  40519c:	4699      	mov	r9, r3
  40519e:	3201      	adds	r2, #1
  4051a0:	44d3      	add	fp, sl
  4051a2:	2a07      	cmp	r2, #7
  4051a4:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4051a8:	9224      	str	r2, [sp, #144]	; 0x90
  4051aa:	e884 0600 	stmia.w	r4, {r9, sl}
  4051ae:	f300 8375 	bgt.w	40589c <_svfprintf_r+0xab8>
  4051b2:	3408      	adds	r4, #8
  4051b4:	9b07      	ldr	r3, [sp, #28]
  4051b6:	05d9      	lsls	r1, r3, #23
  4051b8:	f100 826c 	bmi.w	405694 <_svfprintf_r+0x8b0>
  4051bc:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4051be:	990d      	ldr	r1, [sp, #52]	; 0x34
  4051c0:	9a10      	ldr	r2, [sp, #64]	; 0x40
  4051c2:	6022      	str	r2, [r4, #0]
  4051c4:	3301      	adds	r3, #1
  4051c6:	448b      	add	fp, r1
  4051c8:	2b07      	cmp	r3, #7
  4051ca:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4051ce:	6061      	str	r1, [r4, #4]
  4051d0:	9324      	str	r3, [sp, #144]	; 0x90
  4051d2:	f300 8346 	bgt.w	405862 <_svfprintf_r+0xa7e>
  4051d6:	3408      	adds	r4, #8
  4051d8:	9b07      	ldr	r3, [sp, #28]
  4051da:	075a      	lsls	r2, r3, #29
  4051dc:	d541      	bpl.n	405262 <_svfprintf_r+0x47e>
  4051de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4051e0:	9a09      	ldr	r2, [sp, #36]	; 0x24
  4051e2:	1a9d      	subs	r5, r3, r2
  4051e4:	2d00      	cmp	r5, #0
  4051e6:	dd3c      	ble.n	405262 <_svfprintf_r+0x47e>
  4051e8:	2d10      	cmp	r5, #16
  4051ea:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4051ec:	f8df a3b8 	ldr.w	sl, [pc, #952]	; 4055a8 <_svfprintf_r+0x7c4>
  4051f0:	dd23      	ble.n	40523a <_svfprintf_r+0x456>
  4051f2:	f04f 0810 	mov.w	r8, #16
  4051f6:	465a      	mov	r2, fp
  4051f8:	f8dd 9020 	ldr.w	r9, [sp, #32]
  4051fc:	e004      	b.n	405208 <_svfprintf_r+0x424>
  4051fe:	3d10      	subs	r5, #16
  405200:	2d10      	cmp	r5, #16
  405202:	f104 0408 	add.w	r4, r4, #8
  405206:	dd17      	ble.n	405238 <_svfprintf_r+0x454>
  405208:	3301      	adds	r3, #1
  40520a:	3210      	adds	r2, #16
  40520c:	2b07      	cmp	r3, #7
  40520e:	9225      	str	r2, [sp, #148]	; 0x94
  405210:	9324      	str	r3, [sp, #144]	; 0x90
  405212:	f8c4 a000 	str.w	sl, [r4]
  405216:	f8c4 8004 	str.w	r8, [r4, #4]
  40521a:	ddf0      	ble.n	4051fe <_svfprintf_r+0x41a>
  40521c:	4648      	mov	r0, r9
  40521e:	4631      	mov	r1, r6
  405220:	aa23      	add	r2, sp, #140	; 0x8c
  405222:	f003 f9c7 	bl	4085b4 <__ssprint_r>
  405226:	2800      	cmp	r0, #0
  405228:	f47f aea2 	bne.w	404f70 <_svfprintf_r+0x18c>
  40522c:	3d10      	subs	r5, #16
  40522e:	2d10      	cmp	r5, #16
  405230:	9a25      	ldr	r2, [sp, #148]	; 0x94
  405232:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405234:	463c      	mov	r4, r7
  405236:	dce7      	bgt.n	405208 <_svfprintf_r+0x424>
  405238:	4693      	mov	fp, r2
  40523a:	3301      	adds	r3, #1
  40523c:	44ab      	add	fp, r5
  40523e:	2b07      	cmp	r3, #7
  405240:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405244:	9324      	str	r3, [sp, #144]	; 0x90
  405246:	f8c4 a000 	str.w	sl, [r4]
  40524a:	6065      	str	r5, [r4, #4]
  40524c:	dd09      	ble.n	405262 <_svfprintf_r+0x47e>
  40524e:	9808      	ldr	r0, [sp, #32]
  405250:	4631      	mov	r1, r6
  405252:	aa23      	add	r2, sp, #140	; 0x8c
  405254:	f003 f9ae 	bl	4085b4 <__ssprint_r>
  405258:	2800      	cmp	r0, #0
  40525a:	f47f ae89 	bne.w	404f70 <_svfprintf_r+0x18c>
  40525e:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405262:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  405264:	9a09      	ldr	r2, [sp, #36]	; 0x24
  405266:	990c      	ldr	r1, [sp, #48]	; 0x30
  405268:	428a      	cmp	r2, r1
  40526a:	bfac      	ite	ge
  40526c:	189b      	addge	r3, r3, r2
  40526e:	185b      	addlt	r3, r3, r1
  405270:	930b      	str	r3, [sp, #44]	; 0x2c
  405272:	f1bb 0f00 	cmp.w	fp, #0
  405276:	f47f ae73 	bne.w	404f60 <_svfprintf_r+0x17c>
  40527a:	2300      	movs	r3, #0
  40527c:	9324      	str	r3, [sp, #144]	; 0x90
  40527e:	463c      	mov	r4, r7
  405280:	e5d5      	b.n	404e2e <_svfprintf_r+0x4a>
  405282:	4619      	mov	r1, r3
  405284:	9807      	ldr	r0, [sp, #28]
  405286:	781d      	ldrb	r5, [r3, #0]
  405288:	f040 0004 	orr.w	r0, r0, #4
  40528c:	9007      	str	r0, [sp, #28]
  40528e:	e5fc      	b.n	404e8a <_svfprintf_r+0xa6>
  405290:	930a      	str	r3, [sp, #40]	; 0x28
  405292:	9b07      	ldr	r3, [sp, #28]
  405294:	f013 0320 	ands.w	r3, r3, #32
  405298:	f000 810e 	beq.w	4054b8 <_svfprintf_r+0x6d4>
  40529c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  40529e:	f103 0907 	add.w	r9, r3, #7
  4052a2:	f029 0307 	bic.w	r3, r9, #7
  4052a6:	f103 0208 	add.w	r2, r3, #8
  4052aa:	e9d3 8900 	ldrd	r8, r9, [r3]
  4052ae:	920e      	str	r2, [sp, #56]	; 0x38
  4052b0:	2300      	movs	r3, #0
  4052b2:	e67c      	b.n	404fae <_svfprintf_r+0x1ca>
  4052b4:	781d      	ldrb	r5, [r3, #0]
  4052b6:	4619      	mov	r1, r3
  4052b8:	222b      	movs	r2, #43	; 0x2b
  4052ba:	e5e6      	b.n	404e8a <_svfprintf_r+0xa6>
  4052bc:	781d      	ldrb	r5, [r3, #0]
  4052be:	2d2a      	cmp	r5, #42	; 0x2a
  4052c0:	f103 0101 	add.w	r1, r3, #1
  4052c4:	f000 87ad 	beq.w	406222 <_svfprintf_r+0x143e>
  4052c8:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  4052cc:	2809      	cmp	r0, #9
  4052ce:	460b      	mov	r3, r1
  4052d0:	f04f 0a00 	mov.w	sl, #0
  4052d4:	f63f adda 	bhi.w	404e8c <_svfprintf_r+0xa8>
  4052d8:	f813 5b01 	ldrb.w	r5, [r3], #1
  4052dc:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
  4052e0:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
  4052e4:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  4052e8:	2809      	cmp	r0, #9
  4052ea:	d9f5      	bls.n	4052d8 <_svfprintf_r+0x4f4>
  4052ec:	ea4a 7aea 	orr.w	sl, sl, sl, asr #31
  4052f0:	e5cc      	b.n	404e8c <_svfprintf_r+0xa8>
  4052f2:	930a      	str	r3, [sp, #40]	; 0x28
  4052f4:	9b07      	ldr	r3, [sp, #28]
  4052f6:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  4052fa:	069b      	lsls	r3, r3, #26
  4052fc:	f140 80a1 	bpl.w	405442 <_svfprintf_r+0x65e>
  405300:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  405302:	f103 0907 	add.w	r9, r3, #7
  405306:	f029 0907 	bic.w	r9, r9, #7
  40530a:	e9d9 2300 	ldrd	r2, r3, [r9]
  40530e:	f109 0108 	add.w	r1, r9, #8
  405312:	910e      	str	r1, [sp, #56]	; 0x38
  405314:	4690      	mov	r8, r2
  405316:	4699      	mov	r9, r3
  405318:	2a00      	cmp	r2, #0
  40531a:	f173 0300 	sbcs.w	r3, r3, #0
  40531e:	f2c0 840b 	blt.w	405b38 <_svfprintf_r+0xd54>
  405322:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  405326:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  40532a:	2301      	movs	r3, #1
  40532c:	e645      	b.n	404fba <_svfprintf_r+0x1d6>
  40532e:	930a      	str	r3, [sp, #40]	; 0x28
  405330:	4b9b      	ldr	r3, [pc, #620]	; (4055a0 <_svfprintf_r+0x7bc>)
  405332:	9316      	str	r3, [sp, #88]	; 0x58
  405334:	9b07      	ldr	r3, [sp, #28]
  405336:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  40533a:	069b      	lsls	r3, r3, #26
  40533c:	f140 80f3 	bpl.w	405526 <_svfprintf_r+0x742>
  405340:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  405342:	f103 0907 	add.w	r9, r3, #7
  405346:	f029 0307 	bic.w	r3, r9, #7
  40534a:	e9d3 8900 	ldrd	r8, r9, [r3]
  40534e:	f103 0208 	add.w	r2, r3, #8
  405352:	920e      	str	r2, [sp, #56]	; 0x38
  405354:	9b07      	ldr	r3, [sp, #28]
  405356:	07d9      	lsls	r1, r3, #31
  405358:	f140 80f5 	bpl.w	405546 <_svfprintf_r+0x762>
  40535c:	ea58 0309 	orrs.w	r3, r8, r9
  405360:	f000 80f1 	beq.w	405546 <_svfprintf_r+0x762>
  405364:	9a07      	ldr	r2, [sp, #28]
  405366:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
  40536a:	2330      	movs	r3, #48	; 0x30
  40536c:	f042 0202 	orr.w	r2, r2, #2
  405370:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  405374:	9207      	str	r2, [sp, #28]
  405376:	2302      	movs	r3, #2
  405378:	e619      	b.n	404fae <_svfprintf_r+0x1ca>
  40537a:	781d      	ldrb	r5, [r3, #0]
  40537c:	4619      	mov	r1, r3
  40537e:	2a00      	cmp	r2, #0
  405380:	f47f ad83 	bne.w	404e8a <_svfprintf_r+0xa6>
  405384:	2220      	movs	r2, #32
  405386:	e580      	b.n	404e8a <_svfprintf_r+0xa6>
  405388:	9907      	ldr	r1, [sp, #28]
  40538a:	f041 0120 	orr.w	r1, r1, #32
  40538e:	9107      	str	r1, [sp, #28]
  405390:	781d      	ldrb	r5, [r3, #0]
  405392:	4619      	mov	r1, r3
  405394:	e579      	b.n	404e8a <_svfprintf_r+0xa6>
  405396:	930a      	str	r3, [sp, #40]	; 0x28
  405398:	9b07      	ldr	r3, [sp, #28]
  40539a:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  40539e:	069a      	lsls	r2, r3, #26
  4053a0:	f140 84a1 	bpl.w	405ce6 <_svfprintf_r+0xf02>
  4053a4:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4053a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4053a8:	ea4f 79e1 	mov.w	r9, r1, asr #31
  4053ac:	6813      	ldr	r3, [r2, #0]
  4053ae:	4608      	mov	r0, r1
  4053b0:	4688      	mov	r8, r1
  4053b2:	3204      	adds	r2, #4
  4053b4:	4649      	mov	r1, r9
  4053b6:	920e      	str	r2, [sp, #56]	; 0x38
  4053b8:	e9c3 0100 	strd	r0, r1, [r3]
  4053bc:	e537      	b.n	404e2e <_svfprintf_r+0x4a>
  4053be:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4053c0:	930a      	str	r3, [sp, #40]	; 0x28
  4053c2:	6813      	ldr	r3, [r2, #0]
  4053c4:	9310      	str	r3, [sp, #64]	; 0x40
  4053c6:	f04f 0b00 	mov.w	fp, #0
  4053ca:	f88d b06f 	strb.w	fp, [sp, #111]	; 0x6f
  4053ce:	f102 0904 	add.w	r9, r2, #4
  4053d2:	2b00      	cmp	r3, #0
  4053d4:	f000 863b 	beq.w	40604e <_svfprintf_r+0x126a>
  4053d8:	f1ba 0f00 	cmp.w	sl, #0
  4053dc:	9810      	ldr	r0, [sp, #64]	; 0x40
  4053de:	f2c0 85e9 	blt.w	405fb4 <_svfprintf_r+0x11d0>
  4053e2:	4659      	mov	r1, fp
  4053e4:	4652      	mov	r2, sl
  4053e6:	f002 fb0b 	bl	407a00 <memchr>
  4053ea:	2800      	cmp	r0, #0
  4053ec:	f000 866c 	beq.w	4060c8 <_svfprintf_r+0x12e4>
  4053f0:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4053f2:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
  4053f6:	1ac3      	subs	r3, r0, r3
  4053f8:	930d      	str	r3, [sp, #52]	; 0x34
  4053fa:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  4053fe:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  405402:	9309      	str	r3, [sp, #36]	; 0x24
  405404:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
  405408:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  40540c:	e60a      	b.n	405024 <_svfprintf_r+0x240>
  40540e:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  405412:	2100      	movs	r1, #0
  405414:	f813 5b01 	ldrb.w	r5, [r3], #1
  405418:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40541c:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  405420:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
  405424:	2809      	cmp	r0, #9
  405426:	d9f5      	bls.n	405414 <_svfprintf_r+0x630>
  405428:	910c      	str	r1, [sp, #48]	; 0x30
  40542a:	e52f      	b.n	404e8c <_svfprintf_r+0xa8>
  40542c:	930a      	str	r3, [sp, #40]	; 0x28
  40542e:	9b07      	ldr	r3, [sp, #28]
  405430:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  405434:	f043 0310 	orr.w	r3, r3, #16
  405438:	9307      	str	r3, [sp, #28]
  40543a:	9b07      	ldr	r3, [sp, #28]
  40543c:	069b      	lsls	r3, r3, #26
  40543e:	f53f af5f 	bmi.w	405300 <_svfprintf_r+0x51c>
  405442:	9b07      	ldr	r3, [sp, #28]
  405444:	06d8      	lsls	r0, r3, #27
  405446:	f100 8368 	bmi.w	405b1a <_svfprintf_r+0xd36>
  40544a:	9b07      	ldr	r3, [sp, #28]
  40544c:	0659      	lsls	r1, r3, #25
  40544e:	f140 8364 	bpl.w	405b1a <_svfprintf_r+0xd36>
  405452:	990e      	ldr	r1, [sp, #56]	; 0x38
  405454:	f9b1 8000 	ldrsh.w	r8, [r1]
  405458:	3104      	adds	r1, #4
  40545a:	ea4f 79e8 	mov.w	r9, r8, asr #31
  40545e:	4642      	mov	r2, r8
  405460:	464b      	mov	r3, r9
  405462:	910e      	str	r1, [sp, #56]	; 0x38
  405464:	e758      	b.n	405318 <_svfprintf_r+0x534>
  405466:	781d      	ldrb	r5, [r3, #0]
  405468:	9907      	ldr	r1, [sp, #28]
  40546a:	2d6c      	cmp	r5, #108	; 0x6c
  40546c:	f000 84cb 	beq.w	405e06 <_svfprintf_r+0x1022>
  405470:	f041 0110 	orr.w	r1, r1, #16
  405474:	9107      	str	r1, [sp, #28]
  405476:	4619      	mov	r1, r3
  405478:	e507      	b.n	404e8a <_svfprintf_r+0xa6>
  40547a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  40547c:	6829      	ldr	r1, [r5, #0]
  40547e:	910c      	str	r1, [sp, #48]	; 0x30
  405480:	4608      	mov	r0, r1
  405482:	2800      	cmp	r0, #0
  405484:	4629      	mov	r1, r5
  405486:	f101 0104 	add.w	r1, r1, #4
  40548a:	f2c0 84b5 	blt.w	405df8 <_svfprintf_r+0x1014>
  40548e:	910e      	str	r1, [sp, #56]	; 0x38
  405490:	781d      	ldrb	r5, [r3, #0]
  405492:	4619      	mov	r1, r3
  405494:	e4f9      	b.n	404e8a <_svfprintf_r+0xa6>
  405496:	9907      	ldr	r1, [sp, #28]
  405498:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  40549c:	9107      	str	r1, [sp, #28]
  40549e:	781d      	ldrb	r5, [r3, #0]
  4054a0:	4619      	mov	r1, r3
  4054a2:	e4f2      	b.n	404e8a <_svfprintf_r+0xa6>
  4054a4:	930a      	str	r3, [sp, #40]	; 0x28
  4054a6:	9b07      	ldr	r3, [sp, #28]
  4054a8:	f043 0310 	orr.w	r3, r3, #16
  4054ac:	9307      	str	r3, [sp, #28]
  4054ae:	9b07      	ldr	r3, [sp, #28]
  4054b0:	f013 0320 	ands.w	r3, r3, #32
  4054b4:	f47f aef2 	bne.w	40529c <_svfprintf_r+0x4b8>
  4054b8:	9a07      	ldr	r2, [sp, #28]
  4054ba:	f012 0210 	ands.w	r2, r2, #16
  4054be:	f040 8319 	bne.w	405af4 <_svfprintf_r+0xd10>
  4054c2:	9b07      	ldr	r3, [sp, #28]
  4054c4:	f013 0340 	ands.w	r3, r3, #64	; 0x40
  4054c8:	f000 8314 	beq.w	405af4 <_svfprintf_r+0xd10>
  4054cc:	990e      	ldr	r1, [sp, #56]	; 0x38
  4054ce:	4613      	mov	r3, r2
  4054d0:	460a      	mov	r2, r1
  4054d2:	3204      	adds	r2, #4
  4054d4:	f8b1 8000 	ldrh.w	r8, [r1]
  4054d8:	920e      	str	r2, [sp, #56]	; 0x38
  4054da:	f04f 0900 	mov.w	r9, #0
  4054de:	e566      	b.n	404fae <_svfprintf_r+0x1ca>
  4054e0:	930a      	str	r3, [sp, #40]	; 0x28
  4054e2:	9b07      	ldr	r3, [sp, #28]
  4054e4:	f043 0310 	orr.w	r3, r3, #16
  4054e8:	9307      	str	r3, [sp, #28]
  4054ea:	9b07      	ldr	r3, [sp, #28]
  4054ec:	0698      	lsls	r0, r3, #26
  4054ee:	f53f ad53 	bmi.w	404f98 <_svfprintf_r+0x1b4>
  4054f2:	9b07      	ldr	r3, [sp, #28]
  4054f4:	06d9      	lsls	r1, r3, #27
  4054f6:	f100 8306 	bmi.w	405b06 <_svfprintf_r+0xd22>
  4054fa:	9b07      	ldr	r3, [sp, #28]
  4054fc:	065a      	lsls	r2, r3, #25
  4054fe:	f140 8302 	bpl.w	405b06 <_svfprintf_r+0xd22>
  405502:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405504:	f8b2 8000 	ldrh.w	r8, [r2]
  405508:	3204      	adds	r2, #4
  40550a:	f04f 0900 	mov.w	r9, #0
  40550e:	2301      	movs	r3, #1
  405510:	920e      	str	r2, [sp, #56]	; 0x38
  405512:	e54c      	b.n	404fae <_svfprintf_r+0x1ca>
  405514:	930a      	str	r3, [sp, #40]	; 0x28
  405516:	4b23      	ldr	r3, [pc, #140]	; (4055a4 <_svfprintf_r+0x7c0>)
  405518:	9316      	str	r3, [sp, #88]	; 0x58
  40551a:	9b07      	ldr	r3, [sp, #28]
  40551c:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  405520:	069b      	lsls	r3, r3, #26
  405522:	f53f af0d 	bmi.w	405340 <_svfprintf_r+0x55c>
  405526:	9b07      	ldr	r3, [sp, #28]
  405528:	06d8      	lsls	r0, r3, #27
  40552a:	f140 83cd 	bpl.w	405cc8 <_svfprintf_r+0xee4>
  40552e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405530:	4613      	mov	r3, r2
  405532:	681b      	ldr	r3, [r3, #0]
  405534:	4698      	mov	r8, r3
  405536:	9b07      	ldr	r3, [sp, #28]
  405538:	3204      	adds	r2, #4
  40553a:	07d9      	lsls	r1, r3, #31
  40553c:	920e      	str	r2, [sp, #56]	; 0x38
  40553e:	f04f 0900 	mov.w	r9, #0
  405542:	f53f af0b 	bmi.w	40535c <_svfprintf_r+0x578>
  405546:	2302      	movs	r3, #2
  405548:	e531      	b.n	404fae <_svfprintf_r+0x1ca>
  40554a:	990e      	ldr	r1, [sp, #56]	; 0x38
  40554c:	930a      	str	r3, [sp, #40]	; 0x28
  40554e:	680a      	ldr	r2, [r1, #0]
  405550:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  405554:	2300      	movs	r3, #0
  405556:	2201      	movs	r2, #1
  405558:	3104      	adds	r1, #4
  40555a:	469c      	mov	ip, r3
  40555c:	9209      	str	r2, [sp, #36]	; 0x24
  40555e:	910e      	str	r1, [sp, #56]	; 0x38
  405560:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  405564:	ab26      	add	r3, sp, #152	; 0x98
  405566:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
  40556a:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
  40556e:	920d      	str	r2, [sp, #52]	; 0x34
  405570:	9310      	str	r3, [sp, #64]	; 0x40
  405572:	e55d      	b.n	405030 <_svfprintf_r+0x24c>
  405574:	9907      	ldr	r1, [sp, #28]
  405576:	f041 0108 	orr.w	r1, r1, #8
  40557a:	9107      	str	r1, [sp, #28]
  40557c:	781d      	ldrb	r5, [r3, #0]
  40557e:	4619      	mov	r1, r3
  405580:	e483      	b.n	404e8a <_svfprintf_r+0xa6>
  405582:	9907      	ldr	r1, [sp, #28]
  405584:	f041 0101 	orr.w	r1, r1, #1
  405588:	9107      	str	r1, [sp, #28]
  40558a:	781d      	ldrb	r5, [r3, #0]
  40558c:	4619      	mov	r1, r3
  40558e:	e47c      	b.n	404e8a <_svfprintf_r+0xa6>
  405590:	9907      	ldr	r1, [sp, #28]
  405592:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  405596:	9107      	str	r1, [sp, #28]
  405598:	781d      	ldrb	r5, [r3, #0]
  40559a:	4619      	mov	r1, r3
  40559c:	e475      	b.n	404e8a <_svfprintf_r+0xa6>
  40559e:	bf00      	nop
  4055a0:	0040b128 	.word	0x0040b128
  4055a4:	0040b114 	.word	0x0040b114
  4055a8:	0040b0f4 	.word	0x0040b0f4
  4055ac:	0040b0e4 	.word	0x0040b0e4
  4055b0:	930a      	str	r3, [sp, #40]	; 0x28
  4055b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4055b4:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  4055b8:	f103 0907 	add.w	r9, r3, #7
  4055bc:	f029 0307 	bic.w	r3, r9, #7
  4055c0:	f103 0208 	add.w	r2, r3, #8
  4055c4:	920e      	str	r2, [sp, #56]	; 0x38
  4055c6:	681a      	ldr	r2, [r3, #0]
  4055c8:	9214      	str	r2, [sp, #80]	; 0x50
  4055ca:	685b      	ldr	r3, [r3, #4]
  4055cc:	9315      	str	r3, [sp, #84]	; 0x54
  4055ce:	9915      	ldr	r1, [sp, #84]	; 0x54
  4055d0:	9814      	ldr	r0, [sp, #80]	; 0x50
  4055d2:	f002 ffb1 	bl	408538 <__fpclassifyd>
  4055d6:	2801      	cmp	r0, #1
  4055d8:	46d3      	mov	fp, sl
  4055da:	9814      	ldr	r0, [sp, #80]	; 0x50
  4055dc:	9915      	ldr	r1, [sp, #84]	; 0x54
  4055de:	f040 8359 	bne.w	405c94 <_svfprintf_r+0xeb0>
  4055e2:	2200      	movs	r2, #0
  4055e4:	2300      	movs	r3, #0
  4055e6:	f003 fd13 	bl	409010 <__aeabi_dcmplt>
  4055ea:	2800      	cmp	r0, #0
  4055ec:	f040 8564 	bne.w	4060b8 <_svfprintf_r+0x12d4>
  4055f0:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4055f4:	9b07      	ldr	r3, [sp, #28]
  4055f6:	4abe      	ldr	r2, [pc, #760]	; (4058f0 <_svfprintf_r+0xb0c>)
  4055f8:	f8df e300 	ldr.w	lr, [pc, #768]	; 4058fc <_svfprintf_r+0xb18>
  4055fc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  405600:	9307      	str	r3, [sp, #28]
  405602:	4613      	mov	r3, r2
  405604:	2103      	movs	r1, #3
  405606:	2000      	movs	r0, #0
  405608:	2d47      	cmp	r5, #71	; 0x47
  40560a:	bfd8      	it	le
  40560c:	4673      	movle	r3, lr
  40560e:	9109      	str	r1, [sp, #36]	; 0x24
  405610:	9011      	str	r0, [sp, #68]	; 0x44
  405612:	9310      	str	r3, [sp, #64]	; 0x40
  405614:	910d      	str	r1, [sp, #52]	; 0x34
  405616:	9012      	str	r0, [sp, #72]	; 0x48
  405618:	e504      	b.n	405024 <_svfprintf_r+0x240>
  40561a:	980e      	ldr	r0, [sp, #56]	; 0x38
  40561c:	9907      	ldr	r1, [sp, #28]
  40561e:	930a      	str	r3, [sp, #40]	; 0x28
  405620:	2230      	movs	r2, #48	; 0x30
  405622:	6803      	ldr	r3, [r0, #0]
  405624:	f88d 2070 	strb.w	r2, [sp, #112]	; 0x70
  405628:	4602      	mov	r2, r0
  40562a:	2578      	movs	r5, #120	; 0x78
  40562c:	f041 0102 	orr.w	r1, r1, #2
  405630:	3204      	adds	r2, #4
  405632:	4698      	mov	r8, r3
  405634:	4baf      	ldr	r3, [pc, #700]	; (4058f4 <_svfprintf_r+0xb10>)
  405636:	9316      	str	r3, [sp, #88]	; 0x58
  405638:	9107      	str	r1, [sp, #28]
  40563a:	920e      	str	r2, [sp, #56]	; 0x38
  40563c:	f04f 0900 	mov.w	r9, #0
  405640:	f88d 5071 	strb.w	r5, [sp, #113]	; 0x71
  405644:	2302      	movs	r3, #2
  405646:	e4b2      	b.n	404fae <_svfprintf_r+0x1ca>
  405648:	930a      	str	r3, [sp, #40]	; 0x28
  40564a:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
  40564e:	2d00      	cmp	r5, #0
  405650:	f000 83c6 	beq.w	405de0 <_svfprintf_r+0xffc>
  405654:	2300      	movs	r3, #0
  405656:	2201      	movs	r2, #1
  405658:	469c      	mov	ip, r3
  40565a:	9209      	str	r2, [sp, #36]	; 0x24
  40565c:	f88d 5098 	strb.w	r5, [sp, #152]	; 0x98
  405660:	e77e      	b.n	405560 <_svfprintf_r+0x77c>
  405662:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405666:	e539      	b.n	4050dc <_svfprintf_r+0x2f8>
  405668:	2b01      	cmp	r3, #1
  40566a:	f47f acb8 	bne.w	404fde <_svfprintf_r+0x1fa>
  40566e:	f1b9 0f00 	cmp.w	r9, #0
  405672:	bf08      	it	eq
  405674:	f1b8 0f0a 	cmpeq.w	r8, #10
  405678:	f080 821c 	bcs.w	405ab4 <_svfprintf_r+0xcd0>
  40567c:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
  405680:	f108 0830 	add.w	r8, r8, #48	; 0x30
  405684:	f80b 8d41 	strb.w	r8, [fp, #-65]!
  405688:	ebcb 0307 	rsb	r3, fp, r7
  40568c:	930d      	str	r3, [sp, #52]	; 0x34
  40568e:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  405692:	e4bf      	b.n	405014 <_svfprintf_r+0x230>
  405694:	2d65      	cmp	r5, #101	; 0x65
  405696:	f340 80a0 	ble.w	4057da <_svfprintf_r+0x9f6>
  40569a:	9814      	ldr	r0, [sp, #80]	; 0x50
  40569c:	9915      	ldr	r1, [sp, #84]	; 0x54
  40569e:	2200      	movs	r2, #0
  4056a0:	2300      	movs	r3, #0
  4056a2:	f003 fcab 	bl	408ffc <__aeabi_dcmpeq>
  4056a6:	2800      	cmp	r0, #0
  4056a8:	f000 8145 	beq.w	405936 <_svfprintf_r+0xb52>
  4056ac:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4056ae:	4a92      	ldr	r2, [pc, #584]	; (4058f8 <_svfprintf_r+0xb14>)
  4056b0:	6022      	str	r2, [r4, #0]
  4056b2:	3301      	adds	r3, #1
  4056b4:	f10b 0b01 	add.w	fp, fp, #1
  4056b8:	2201      	movs	r2, #1
  4056ba:	2b07      	cmp	r3, #7
  4056bc:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4056c0:	9324      	str	r3, [sp, #144]	; 0x90
  4056c2:	6062      	str	r2, [r4, #4]
  4056c4:	f300 8334 	bgt.w	405d30 <_svfprintf_r+0xf4c>
  4056c8:	3408      	adds	r4, #8
  4056ca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4056cc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  4056ce:	4293      	cmp	r3, r2
  4056d0:	db03      	blt.n	4056da <_svfprintf_r+0x8f6>
  4056d2:	9b07      	ldr	r3, [sp, #28]
  4056d4:	07da      	lsls	r2, r3, #31
  4056d6:	f57f ad7f 	bpl.w	4051d8 <_svfprintf_r+0x3f4>
  4056da:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4056dc:	9918      	ldr	r1, [sp, #96]	; 0x60
  4056de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  4056e0:	6022      	str	r2, [r4, #0]
  4056e2:	3301      	adds	r3, #1
  4056e4:	448b      	add	fp, r1
  4056e6:	2b07      	cmp	r3, #7
  4056e8:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4056ec:	6061      	str	r1, [r4, #4]
  4056ee:	9324      	str	r3, [sp, #144]	; 0x90
  4056f0:	f300 8390 	bgt.w	405e14 <_svfprintf_r+0x1030>
  4056f4:	3408      	adds	r4, #8
  4056f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4056f8:	1e5d      	subs	r5, r3, #1
  4056fa:	2d00      	cmp	r5, #0
  4056fc:	f77f ad6c 	ble.w	4051d8 <_svfprintf_r+0x3f4>
  405700:	2d10      	cmp	r5, #16
  405702:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405704:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 405900 <_svfprintf_r+0xb1c>
  405708:	f340 81ba 	ble.w	405a80 <_svfprintf_r+0xc9c>
  40570c:	f04f 0810 	mov.w	r8, #16
  405710:	465a      	mov	r2, fp
  405712:	f8dd a020 	ldr.w	sl, [sp, #32]
  405716:	e004      	b.n	405722 <_svfprintf_r+0x93e>
  405718:	3408      	adds	r4, #8
  40571a:	3d10      	subs	r5, #16
  40571c:	2d10      	cmp	r5, #16
  40571e:	f340 81ae 	ble.w	405a7e <_svfprintf_r+0xc9a>
  405722:	3301      	adds	r3, #1
  405724:	3210      	adds	r2, #16
  405726:	2b07      	cmp	r3, #7
  405728:	9225      	str	r2, [sp, #148]	; 0x94
  40572a:	9324      	str	r3, [sp, #144]	; 0x90
  40572c:	f8c4 9000 	str.w	r9, [r4]
  405730:	f8c4 8004 	str.w	r8, [r4, #4]
  405734:	ddf0      	ble.n	405718 <_svfprintf_r+0x934>
  405736:	4650      	mov	r0, sl
  405738:	4631      	mov	r1, r6
  40573a:	aa23      	add	r2, sp, #140	; 0x8c
  40573c:	f002 ff3a 	bl	4085b4 <__ssprint_r>
  405740:	2800      	cmp	r0, #0
  405742:	f47f ac15 	bne.w	404f70 <_svfprintf_r+0x18c>
  405746:	9a25      	ldr	r2, [sp, #148]	; 0x94
  405748:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40574a:	463c      	mov	r4, r7
  40574c:	e7e5      	b.n	40571a <_svfprintf_r+0x936>
  40574e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  405750:	9a09      	ldr	r2, [sp, #36]	; 0x24
  405752:	ebc2 0a03 	rsb	sl, r2, r3
  405756:	f1ba 0f00 	cmp.w	sl, #0
  40575a:	f77f ace7 	ble.w	40512c <_svfprintf_r+0x348>
  40575e:	f1ba 0f10 	cmp.w	sl, #16
  405762:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405764:	f8df 9198 	ldr.w	r9, [pc, #408]	; 405900 <_svfprintf_r+0xb1c>
  405768:	dd2b      	ble.n	4057c2 <_svfprintf_r+0x9de>
  40576a:	4649      	mov	r1, r9
  40576c:	465b      	mov	r3, fp
  40576e:	46a9      	mov	r9, r5
  405770:	f04f 0810 	mov.w	r8, #16
  405774:	f8dd b020 	ldr.w	fp, [sp, #32]
  405778:	460d      	mov	r5, r1
  40577a:	e006      	b.n	40578a <_svfprintf_r+0x9a6>
  40577c:	f1aa 0a10 	sub.w	sl, sl, #16
  405780:	f1ba 0f10 	cmp.w	sl, #16
  405784:	f104 0408 	add.w	r4, r4, #8
  405788:	dd17      	ble.n	4057ba <_svfprintf_r+0x9d6>
  40578a:	3201      	adds	r2, #1
  40578c:	3310      	adds	r3, #16
  40578e:	2a07      	cmp	r2, #7
  405790:	9325      	str	r3, [sp, #148]	; 0x94
  405792:	9224      	str	r2, [sp, #144]	; 0x90
  405794:	e884 0120 	stmia.w	r4, {r5, r8}
  405798:	ddf0      	ble.n	40577c <_svfprintf_r+0x998>
  40579a:	4658      	mov	r0, fp
  40579c:	4631      	mov	r1, r6
  40579e:	aa23      	add	r2, sp, #140	; 0x8c
  4057a0:	f002 ff08 	bl	4085b4 <__ssprint_r>
  4057a4:	2800      	cmp	r0, #0
  4057a6:	f47f abe3 	bne.w	404f70 <_svfprintf_r+0x18c>
  4057aa:	f1aa 0a10 	sub.w	sl, sl, #16
  4057ae:	f1ba 0f10 	cmp.w	sl, #16
  4057b2:	9b25      	ldr	r3, [sp, #148]	; 0x94
  4057b4:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4057b6:	463c      	mov	r4, r7
  4057b8:	dce7      	bgt.n	40578a <_svfprintf_r+0x9a6>
  4057ba:	469b      	mov	fp, r3
  4057bc:	462b      	mov	r3, r5
  4057be:	464d      	mov	r5, r9
  4057c0:	4699      	mov	r9, r3
  4057c2:	3201      	adds	r2, #1
  4057c4:	44d3      	add	fp, sl
  4057c6:	2a07      	cmp	r2, #7
  4057c8:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  4057cc:	9224      	str	r2, [sp, #144]	; 0x90
  4057ce:	e884 0600 	stmia.w	r4, {r9, sl}
  4057d2:	f300 8252 	bgt.w	405c7a <_svfprintf_r+0xe96>
  4057d6:	3408      	adds	r4, #8
  4057d8:	e4a8      	b.n	40512c <_svfprintf_r+0x348>
  4057da:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4057dc:	9d24      	ldr	r5, [sp, #144]	; 0x90
  4057de:	2b01      	cmp	r3, #1
  4057e0:	f340 8220 	ble.w	405c24 <_svfprintf_r+0xe40>
  4057e4:	9b10      	ldr	r3, [sp, #64]	; 0x40
  4057e6:	6023      	str	r3, [r4, #0]
  4057e8:	3501      	adds	r5, #1
  4057ea:	f10b 0301 	add.w	r3, fp, #1
  4057ee:	2201      	movs	r2, #1
  4057f0:	2d07      	cmp	r5, #7
  4057f2:	9325      	str	r3, [sp, #148]	; 0x94
  4057f4:	9524      	str	r5, [sp, #144]	; 0x90
  4057f6:	6062      	str	r2, [r4, #4]
  4057f8:	f300 8226 	bgt.w	405c48 <_svfprintf_r+0xe64>
  4057fc:	3408      	adds	r4, #8
  4057fe:	9918      	ldr	r1, [sp, #96]	; 0x60
  405800:	6061      	str	r1, [r4, #4]
  405802:	3501      	adds	r5, #1
  405804:	eb03 0b01 	add.w	fp, r3, r1
  405808:	2d07      	cmp	r5, #7
  40580a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  40580c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405810:	9524      	str	r5, [sp, #144]	; 0x90
  405812:	6023      	str	r3, [r4, #0]
  405814:	f300 8224 	bgt.w	405c60 <_svfprintf_r+0xe7c>
  405818:	3408      	adds	r4, #8
  40581a:	2300      	movs	r3, #0
  40581c:	9814      	ldr	r0, [sp, #80]	; 0x50
  40581e:	9915      	ldr	r1, [sp, #84]	; 0x54
  405820:	2200      	movs	r2, #0
  405822:	f003 fbeb 	bl	408ffc <__aeabi_dcmpeq>
  405826:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  405828:	2800      	cmp	r0, #0
  40582a:	f040 80de 	bne.w	4059ea <_svfprintf_r+0xc06>
  40582e:	9a10      	ldr	r2, [sp, #64]	; 0x40
  405830:	3b01      	subs	r3, #1
  405832:	3501      	adds	r5, #1
  405834:	3201      	adds	r2, #1
  405836:	449b      	add	fp, r3
  405838:	2d07      	cmp	r5, #7
  40583a:	9524      	str	r5, [sp, #144]	; 0x90
  40583c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405840:	6022      	str	r2, [r4, #0]
  405842:	6063      	str	r3, [r4, #4]
  405844:	f300 810e 	bgt.w	405a64 <_svfprintf_r+0xc80>
  405848:	3408      	adds	r4, #8
  40584a:	9a19      	ldr	r2, [sp, #100]	; 0x64
  40584c:	6062      	str	r2, [r4, #4]
  40584e:	3501      	adds	r5, #1
  405850:	4493      	add	fp, r2
  405852:	ab1f      	add	r3, sp, #124	; 0x7c
  405854:	2d07      	cmp	r5, #7
  405856:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  40585a:	9524      	str	r5, [sp, #144]	; 0x90
  40585c:	6023      	str	r3, [r4, #0]
  40585e:	f77f acba 	ble.w	4051d6 <_svfprintf_r+0x3f2>
  405862:	9808      	ldr	r0, [sp, #32]
  405864:	4631      	mov	r1, r6
  405866:	aa23      	add	r2, sp, #140	; 0x8c
  405868:	f002 fea4 	bl	4085b4 <__ssprint_r>
  40586c:	2800      	cmp	r0, #0
  40586e:	f47f ab7f 	bne.w	404f70 <_svfprintf_r+0x18c>
  405872:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405876:	463c      	mov	r4, r7
  405878:	e4ae      	b.n	4051d8 <_svfprintf_r+0x3f4>
  40587a:	2b00      	cmp	r3, #0
  40587c:	d132      	bne.n	4058e4 <_svfprintf_r+0xb00>
  40587e:	9b07      	ldr	r3, [sp, #28]
  405880:	07d8      	lsls	r0, r3, #31
  405882:	d52f      	bpl.n	4058e4 <_svfprintf_r+0xb00>
  405884:	f50d 7b80 	add.w	fp, sp, #256	; 0x100
  405888:	2330      	movs	r3, #48	; 0x30
  40588a:	f80b 3d41 	strb.w	r3, [fp, #-65]!
  40588e:	ebcb 0307 	rsb	r3, fp, r7
  405892:	930d      	str	r3, [sp, #52]	; 0x34
  405894:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  405898:	f7ff bbbc 	b.w	405014 <_svfprintf_r+0x230>
  40589c:	9808      	ldr	r0, [sp, #32]
  40589e:	4631      	mov	r1, r6
  4058a0:	aa23      	add	r2, sp, #140	; 0x8c
  4058a2:	f002 fe87 	bl	4085b4 <__ssprint_r>
  4058a6:	2800      	cmp	r0, #0
  4058a8:	f47f ab62 	bne.w	404f70 <_svfprintf_r+0x18c>
  4058ac:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4058b0:	463c      	mov	r4, r7
  4058b2:	e47f      	b.n	4051b4 <_svfprintf_r+0x3d0>
  4058b4:	9808      	ldr	r0, [sp, #32]
  4058b6:	4631      	mov	r1, r6
  4058b8:	aa23      	add	r2, sp, #140	; 0x8c
  4058ba:	f002 fe7b 	bl	4085b4 <__ssprint_r>
  4058be:	2800      	cmp	r0, #0
  4058c0:	f47f ab56 	bne.w	404f70 <_svfprintf_r+0x18c>
  4058c4:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4058c8:	463c      	mov	r4, r7
  4058ca:	e41a      	b.n	405102 <_svfprintf_r+0x31e>
  4058cc:	9808      	ldr	r0, [sp, #32]
  4058ce:	4631      	mov	r1, r6
  4058d0:	aa23      	add	r2, sp, #140	; 0x8c
  4058d2:	f002 fe6f 	bl	4085b4 <__ssprint_r>
  4058d6:	2800      	cmp	r0, #0
  4058d8:	f47f ab4a 	bne.w	404f70 <_svfprintf_r+0x18c>
  4058dc:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4058e0:	463c      	mov	r4, r7
  4058e2:	e41f      	b.n	405124 <_svfprintf_r+0x340>
  4058e4:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  4058e8:	9710      	str	r7, [sp, #64]	; 0x40
  4058ea:	f7ff bb93 	b.w	405014 <_svfprintf_r+0x230>
  4058ee:	bf00      	nop
  4058f0:	0040b108 	.word	0x0040b108
  4058f4:	0040b128 	.word	0x0040b128
  4058f8:	0040b144 	.word	0x0040b144
  4058fc:	0040b104 	.word	0x0040b104
  405900:	0040b0e4 	.word	0x0040b0e4
  405904:	9816      	ldr	r0, [sp, #88]	; 0x58
  405906:	46bb      	mov	fp, r7
  405908:	ea4f 1318 	mov.w	r3, r8, lsr #4
  40590c:	f008 010f 	and.w	r1, r8, #15
  405910:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
  405914:	ea4f 1219 	mov.w	r2, r9, lsr #4
  405918:	4698      	mov	r8, r3
  40591a:	4691      	mov	r9, r2
  40591c:	5c43      	ldrb	r3, [r0, r1]
  40591e:	f80b 3d01 	strb.w	r3, [fp, #-1]!
  405922:	ea58 0309 	orrs.w	r3, r8, r9
  405926:	d1ef      	bne.n	405908 <_svfprintf_r+0xb24>
  405928:	465b      	mov	r3, fp
  40592a:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  40592e:	1afb      	subs	r3, r7, r3
  405930:	930d      	str	r3, [sp, #52]	; 0x34
  405932:	f7ff bb6f 	b.w	405014 <_svfprintf_r+0x230>
  405936:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  405938:	2d00      	cmp	r5, #0
  40593a:	f340 8205 	ble.w	405d48 <_svfprintf_r+0xf64>
  40593e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405940:	9912      	ldr	r1, [sp, #72]	; 0x48
  405942:	428a      	cmp	r2, r1
  405944:	4613      	mov	r3, r2
  405946:	bfa8      	it	ge
  405948:	460b      	movge	r3, r1
  40594a:	461d      	mov	r5, r3
  40594c:	9910      	ldr	r1, [sp, #64]	; 0x40
  40594e:	2d00      	cmp	r5, #0
  405950:	eb01 0a02 	add.w	sl, r1, r2
  405954:	dd0b      	ble.n	40596e <_svfprintf_r+0xb8a>
  405956:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405958:	6021      	str	r1, [r4, #0]
  40595a:	3301      	adds	r3, #1
  40595c:	44ab      	add	fp, r5
  40595e:	2b07      	cmp	r3, #7
  405960:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405964:	6065      	str	r5, [r4, #4]
  405966:	9324      	str	r3, [sp, #144]	; 0x90
  405968:	f300 834d 	bgt.w	406006 <_svfprintf_r+0x1222>
  40596c:	3408      	adds	r4, #8
  40596e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  405970:	2d00      	cmp	r5, #0
  405972:	bfa8      	it	ge
  405974:	1b5b      	subge	r3, r3, r5
  405976:	2b00      	cmp	r3, #0
  405978:	461d      	mov	r5, r3
  40597a:	f340 80f5 	ble.w	405b68 <_svfprintf_r+0xd84>
  40597e:	2d10      	cmp	r5, #16
  405980:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405982:	f8df 95f4 	ldr.w	r9, [pc, #1524]	; 405f78 <_svfprintf_r+0x1194>
  405986:	f340 81c6 	ble.w	405d16 <_svfprintf_r+0xf32>
  40598a:	465a      	mov	r2, fp
  40598c:	f04f 0810 	mov.w	r8, #16
  405990:	f8dd b020 	ldr.w	fp, [sp, #32]
  405994:	e004      	b.n	4059a0 <_svfprintf_r+0xbbc>
  405996:	3408      	adds	r4, #8
  405998:	3d10      	subs	r5, #16
  40599a:	2d10      	cmp	r5, #16
  40599c:	f340 81ba 	ble.w	405d14 <_svfprintf_r+0xf30>
  4059a0:	3301      	adds	r3, #1
  4059a2:	3210      	adds	r2, #16
  4059a4:	2b07      	cmp	r3, #7
  4059a6:	9225      	str	r2, [sp, #148]	; 0x94
  4059a8:	9324      	str	r3, [sp, #144]	; 0x90
  4059aa:	f8c4 9000 	str.w	r9, [r4]
  4059ae:	f8c4 8004 	str.w	r8, [r4, #4]
  4059b2:	ddf0      	ble.n	405996 <_svfprintf_r+0xbb2>
  4059b4:	4658      	mov	r0, fp
  4059b6:	4631      	mov	r1, r6
  4059b8:	aa23      	add	r2, sp, #140	; 0x8c
  4059ba:	f002 fdfb 	bl	4085b4 <__ssprint_r>
  4059be:	2800      	cmp	r0, #0
  4059c0:	f47f aad6 	bne.w	404f70 <_svfprintf_r+0x18c>
  4059c4:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4059c6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4059c8:	463c      	mov	r4, r7
  4059ca:	e7e5      	b.n	405998 <_svfprintf_r+0xbb4>
  4059cc:	9808      	ldr	r0, [sp, #32]
  4059ce:	4631      	mov	r1, r6
  4059d0:	aa23      	add	r2, sp, #140	; 0x8c
  4059d2:	f002 fdef 	bl	4085b4 <__ssprint_r>
  4059d6:	2800      	cmp	r0, #0
  4059d8:	f47f aaca 	bne.w	404f70 <_svfprintf_r+0x18c>
  4059dc:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4059e0:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  4059e4:	463c      	mov	r4, r7
  4059e6:	f7ff bb79 	b.w	4050dc <_svfprintf_r+0x2f8>
  4059ea:	f103 38ff 	add.w	r8, r3, #4294967295
  4059ee:	f1b8 0f00 	cmp.w	r8, #0
  4059f2:	f77f af2a 	ble.w	40584a <_svfprintf_r+0xa66>
  4059f6:	f1b8 0f10 	cmp.w	r8, #16
  4059fa:	f8df 957c 	ldr.w	r9, [pc, #1404]	; 405f78 <_svfprintf_r+0x1194>
  4059fe:	dd25      	ble.n	405a4c <_svfprintf_r+0xc68>
  405a00:	465b      	mov	r3, fp
  405a02:	f04f 0a10 	mov.w	sl, #16
  405a06:	f8dd b020 	ldr.w	fp, [sp, #32]
  405a0a:	e006      	b.n	405a1a <_svfprintf_r+0xc36>
  405a0c:	f1a8 0810 	sub.w	r8, r8, #16
  405a10:	f1b8 0f10 	cmp.w	r8, #16
  405a14:	f104 0408 	add.w	r4, r4, #8
  405a18:	dd17      	ble.n	405a4a <_svfprintf_r+0xc66>
  405a1a:	3501      	adds	r5, #1
  405a1c:	3310      	adds	r3, #16
  405a1e:	2d07      	cmp	r5, #7
  405a20:	9325      	str	r3, [sp, #148]	; 0x94
  405a22:	9524      	str	r5, [sp, #144]	; 0x90
  405a24:	e884 0600 	stmia.w	r4, {r9, sl}
  405a28:	ddf0      	ble.n	405a0c <_svfprintf_r+0xc28>
  405a2a:	4658      	mov	r0, fp
  405a2c:	4631      	mov	r1, r6
  405a2e:	aa23      	add	r2, sp, #140	; 0x8c
  405a30:	f002 fdc0 	bl	4085b4 <__ssprint_r>
  405a34:	2800      	cmp	r0, #0
  405a36:	f47f aa9b 	bne.w	404f70 <_svfprintf_r+0x18c>
  405a3a:	f1a8 0810 	sub.w	r8, r8, #16
  405a3e:	f1b8 0f10 	cmp.w	r8, #16
  405a42:	9b25      	ldr	r3, [sp, #148]	; 0x94
  405a44:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405a46:	463c      	mov	r4, r7
  405a48:	dce7      	bgt.n	405a1a <_svfprintf_r+0xc36>
  405a4a:	469b      	mov	fp, r3
  405a4c:	3501      	adds	r5, #1
  405a4e:	44c3      	add	fp, r8
  405a50:	2d07      	cmp	r5, #7
  405a52:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405a56:	9524      	str	r5, [sp, #144]	; 0x90
  405a58:	f8c4 9000 	str.w	r9, [r4]
  405a5c:	f8c4 8004 	str.w	r8, [r4, #4]
  405a60:	f77f aef2 	ble.w	405848 <_svfprintf_r+0xa64>
  405a64:	9808      	ldr	r0, [sp, #32]
  405a66:	4631      	mov	r1, r6
  405a68:	aa23      	add	r2, sp, #140	; 0x8c
  405a6a:	f002 fda3 	bl	4085b4 <__ssprint_r>
  405a6e:	2800      	cmp	r0, #0
  405a70:	f47f aa7e 	bne.w	404f70 <_svfprintf_r+0x18c>
  405a74:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405a78:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405a7a:	463c      	mov	r4, r7
  405a7c:	e6e5      	b.n	40584a <_svfprintf_r+0xa66>
  405a7e:	4693      	mov	fp, r2
  405a80:	3301      	adds	r3, #1
  405a82:	44ab      	add	fp, r5
  405a84:	2b07      	cmp	r3, #7
  405a86:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405a8a:	9324      	str	r3, [sp, #144]	; 0x90
  405a8c:	f8c4 9000 	str.w	r9, [r4]
  405a90:	6065      	str	r5, [r4, #4]
  405a92:	f77f aba0 	ble.w	4051d6 <_svfprintf_r+0x3f2>
  405a96:	e6e4      	b.n	405862 <_svfprintf_r+0xa7e>
  405a98:	2b30      	cmp	r3, #48	; 0x30
  405a9a:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405a9c:	f43f af47 	beq.w	40592e <_svfprintf_r+0xb4a>
  405aa0:	3b01      	subs	r3, #1
  405aa2:	461a      	mov	r2, r3
  405aa4:	9310      	str	r3, [sp, #64]	; 0x40
  405aa6:	1aba      	subs	r2, r7, r2
  405aa8:	2330      	movs	r3, #48	; 0x30
  405aaa:	920d      	str	r2, [sp, #52]	; 0x34
  405aac:	f801 3c01 	strb.w	r3, [r1, #-1]
  405ab0:	f7ff bab0 	b.w	405014 <_svfprintf_r+0x230>
  405ab4:	46bb      	mov	fp, r7
  405ab6:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  405aba:	4640      	mov	r0, r8
  405abc:	4649      	mov	r1, r9
  405abe:	220a      	movs	r2, #10
  405ac0:	2300      	movs	r3, #0
  405ac2:	f003 faf5 	bl	4090b0 <__aeabi_uldivmod>
  405ac6:	3230      	adds	r2, #48	; 0x30
  405ac8:	4640      	mov	r0, r8
  405aca:	4649      	mov	r1, r9
  405acc:	f80b 2d01 	strb.w	r2, [fp, #-1]!
  405ad0:	2300      	movs	r3, #0
  405ad2:	220a      	movs	r2, #10
  405ad4:	f003 faec 	bl	4090b0 <__aeabi_uldivmod>
  405ad8:	4680      	mov	r8, r0
  405ada:	4689      	mov	r9, r1
  405adc:	ea58 0309 	orrs.w	r3, r8, r9
  405ae0:	d1eb      	bne.n	405aba <_svfprintf_r+0xcd6>
  405ae2:	465b      	mov	r3, fp
  405ae4:	1afb      	subs	r3, r7, r3
  405ae6:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  405aea:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
  405aee:	930d      	str	r3, [sp, #52]	; 0x34
  405af0:	f7ff ba90 	b.w	405014 <_svfprintf_r+0x230>
  405af4:	990e      	ldr	r1, [sp, #56]	; 0x38
  405af6:	680a      	ldr	r2, [r1, #0]
  405af8:	3104      	adds	r1, #4
  405afa:	910e      	str	r1, [sp, #56]	; 0x38
  405afc:	4690      	mov	r8, r2
  405afe:	f04f 0900 	mov.w	r9, #0
  405b02:	f7ff ba54 	b.w	404fae <_svfprintf_r+0x1ca>
  405b06:	990e      	ldr	r1, [sp, #56]	; 0x38
  405b08:	680a      	ldr	r2, [r1, #0]
  405b0a:	3104      	adds	r1, #4
  405b0c:	2301      	movs	r3, #1
  405b0e:	910e      	str	r1, [sp, #56]	; 0x38
  405b10:	4690      	mov	r8, r2
  405b12:	f04f 0900 	mov.w	r9, #0
  405b16:	f7ff ba4a 	b.w	404fae <_svfprintf_r+0x1ca>
  405b1a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405b1c:	6813      	ldr	r3, [r2, #0]
  405b1e:	4698      	mov	r8, r3
  405b20:	ea4f 79e3 	mov.w	r9, r3, asr #31
  405b24:	4613      	mov	r3, r2
  405b26:	3304      	adds	r3, #4
  405b28:	4642      	mov	r2, r8
  405b2a:	930e      	str	r3, [sp, #56]	; 0x38
  405b2c:	2a00      	cmp	r2, #0
  405b2e:	464b      	mov	r3, r9
  405b30:	f173 0300 	sbcs.w	r3, r3, #0
  405b34:	f6bf abf5 	bge.w	405322 <_svfprintf_r+0x53e>
  405b38:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  405b3c:	f1d8 0800 	rsbs	r8, r8, #0
  405b40:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
  405b44:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  405b48:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  405b4c:	2301      	movs	r3, #1
  405b4e:	f7ff ba34 	b.w	404fba <_svfprintf_r+0x1d6>
  405b52:	9808      	ldr	r0, [sp, #32]
  405b54:	4631      	mov	r1, r6
  405b56:	aa23      	add	r2, sp, #140	; 0x8c
  405b58:	f002 fd2c 	bl	4085b4 <__ssprint_r>
  405b5c:	2800      	cmp	r0, #0
  405b5e:	f47f aa07 	bne.w	404f70 <_svfprintf_r+0x18c>
  405b62:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405b66:	463c      	mov	r4, r7
  405b68:	9a10      	ldr	r2, [sp, #64]	; 0x40
  405b6a:	9912      	ldr	r1, [sp, #72]	; 0x48
  405b6c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405b6e:	440a      	add	r2, r1
  405b70:	4690      	mov	r8, r2
  405b72:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405b74:	4293      	cmp	r3, r2
  405b76:	db46      	blt.n	405c06 <_svfprintf_r+0xe22>
  405b78:	9a07      	ldr	r2, [sp, #28]
  405b7a:	07d0      	lsls	r0, r2, #31
  405b7c:	d443      	bmi.n	405c06 <_svfprintf_r+0xe22>
  405b7e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  405b80:	ebc8 050a 	rsb	r5, r8, sl
  405b84:	1ad3      	subs	r3, r2, r3
  405b86:	429d      	cmp	r5, r3
  405b88:	bfa8      	it	ge
  405b8a:	461d      	movge	r5, r3
  405b8c:	2d00      	cmp	r5, #0
  405b8e:	dd0c      	ble.n	405baa <_svfprintf_r+0xdc6>
  405b90:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405b92:	f8c4 8000 	str.w	r8, [r4]
  405b96:	3201      	adds	r2, #1
  405b98:	44ab      	add	fp, r5
  405b9a:	2a07      	cmp	r2, #7
  405b9c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405ba0:	6065      	str	r5, [r4, #4]
  405ba2:	9224      	str	r2, [sp, #144]	; 0x90
  405ba4:	f300 8267 	bgt.w	406076 <_svfprintf_r+0x1292>
  405ba8:	3408      	adds	r4, #8
  405baa:	2d00      	cmp	r5, #0
  405bac:	bfac      	ite	ge
  405bae:	1b5d      	subge	r5, r3, r5
  405bb0:	461d      	movlt	r5, r3
  405bb2:	2d00      	cmp	r5, #0
  405bb4:	f77f ab10 	ble.w	4051d8 <_svfprintf_r+0x3f4>
  405bb8:	2d10      	cmp	r5, #16
  405bba:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405bbc:	f8df 93b8 	ldr.w	r9, [pc, #952]	; 405f78 <_svfprintf_r+0x1194>
  405bc0:	f77f af5e 	ble.w	405a80 <_svfprintf_r+0xc9c>
  405bc4:	f04f 0810 	mov.w	r8, #16
  405bc8:	465a      	mov	r2, fp
  405bca:	f8dd a020 	ldr.w	sl, [sp, #32]
  405bce:	e004      	b.n	405bda <_svfprintf_r+0xdf6>
  405bd0:	3408      	adds	r4, #8
  405bd2:	3d10      	subs	r5, #16
  405bd4:	2d10      	cmp	r5, #16
  405bd6:	f77f af52 	ble.w	405a7e <_svfprintf_r+0xc9a>
  405bda:	3301      	adds	r3, #1
  405bdc:	3210      	adds	r2, #16
  405bde:	2b07      	cmp	r3, #7
  405be0:	9225      	str	r2, [sp, #148]	; 0x94
  405be2:	9324      	str	r3, [sp, #144]	; 0x90
  405be4:	f8c4 9000 	str.w	r9, [r4]
  405be8:	f8c4 8004 	str.w	r8, [r4, #4]
  405bec:	ddf0      	ble.n	405bd0 <_svfprintf_r+0xdec>
  405bee:	4650      	mov	r0, sl
  405bf0:	4631      	mov	r1, r6
  405bf2:	aa23      	add	r2, sp, #140	; 0x8c
  405bf4:	f002 fcde 	bl	4085b4 <__ssprint_r>
  405bf8:	2800      	cmp	r0, #0
  405bfa:	f47f a9b9 	bne.w	404f70 <_svfprintf_r+0x18c>
  405bfe:	9a25      	ldr	r2, [sp, #148]	; 0x94
  405c00:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405c02:	463c      	mov	r4, r7
  405c04:	e7e5      	b.n	405bd2 <_svfprintf_r+0xdee>
  405c06:	9a24      	ldr	r2, [sp, #144]	; 0x90
  405c08:	9818      	ldr	r0, [sp, #96]	; 0x60
  405c0a:	9917      	ldr	r1, [sp, #92]	; 0x5c
  405c0c:	6021      	str	r1, [r4, #0]
  405c0e:	3201      	adds	r2, #1
  405c10:	4483      	add	fp, r0
  405c12:	2a07      	cmp	r2, #7
  405c14:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405c18:	6060      	str	r0, [r4, #4]
  405c1a:	9224      	str	r2, [sp, #144]	; 0x90
  405c1c:	f300 820a 	bgt.w	406034 <_svfprintf_r+0x1250>
  405c20:	3408      	adds	r4, #8
  405c22:	e7ac      	b.n	405b7e <_svfprintf_r+0xd9a>
  405c24:	9b07      	ldr	r3, [sp, #28]
  405c26:	07d9      	lsls	r1, r3, #31
  405c28:	f53f addc 	bmi.w	4057e4 <_svfprintf_r+0xa00>
  405c2c:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405c2e:	6023      	str	r3, [r4, #0]
  405c30:	3501      	adds	r5, #1
  405c32:	f10b 0b01 	add.w	fp, fp, #1
  405c36:	2301      	movs	r3, #1
  405c38:	2d07      	cmp	r5, #7
  405c3a:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405c3e:	9524      	str	r5, [sp, #144]	; 0x90
  405c40:	6063      	str	r3, [r4, #4]
  405c42:	f77f ae01 	ble.w	405848 <_svfprintf_r+0xa64>
  405c46:	e70d      	b.n	405a64 <_svfprintf_r+0xc80>
  405c48:	9808      	ldr	r0, [sp, #32]
  405c4a:	4631      	mov	r1, r6
  405c4c:	aa23      	add	r2, sp, #140	; 0x8c
  405c4e:	f002 fcb1 	bl	4085b4 <__ssprint_r>
  405c52:	2800      	cmp	r0, #0
  405c54:	f47f a98c 	bne.w	404f70 <_svfprintf_r+0x18c>
  405c58:	9b25      	ldr	r3, [sp, #148]	; 0x94
  405c5a:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405c5c:	463c      	mov	r4, r7
  405c5e:	e5ce      	b.n	4057fe <_svfprintf_r+0xa1a>
  405c60:	9808      	ldr	r0, [sp, #32]
  405c62:	4631      	mov	r1, r6
  405c64:	aa23      	add	r2, sp, #140	; 0x8c
  405c66:	f002 fca5 	bl	4085b4 <__ssprint_r>
  405c6a:	2800      	cmp	r0, #0
  405c6c:	f47f a980 	bne.w	404f70 <_svfprintf_r+0x18c>
  405c70:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405c74:	9d24      	ldr	r5, [sp, #144]	; 0x90
  405c76:	463c      	mov	r4, r7
  405c78:	e5cf      	b.n	40581a <_svfprintf_r+0xa36>
  405c7a:	9808      	ldr	r0, [sp, #32]
  405c7c:	4631      	mov	r1, r6
  405c7e:	aa23      	add	r2, sp, #140	; 0x8c
  405c80:	f002 fc98 	bl	4085b4 <__ssprint_r>
  405c84:	2800      	cmp	r0, #0
  405c86:	f47f a973 	bne.w	404f70 <_svfprintf_r+0x18c>
  405c8a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405c8e:	463c      	mov	r4, r7
  405c90:	f7ff ba4c 	b.w	40512c <_svfprintf_r+0x348>
  405c94:	f002 fc50 	bl	408538 <__fpclassifyd>
  405c98:	2800      	cmp	r0, #0
  405c9a:	f040 80c7 	bne.w	405e2c <_svfprintf_r+0x1048>
  405c9e:	4686      	mov	lr, r0
  405ca0:	4ab2      	ldr	r2, [pc, #712]	; (405f6c <_svfprintf_r+0x1188>)
  405ca2:	4bb3      	ldr	r3, [pc, #716]	; (405f70 <_svfprintf_r+0x118c>)
  405ca4:	9011      	str	r0, [sp, #68]	; 0x44
  405ca6:	9807      	ldr	r0, [sp, #28]
  405ca8:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  405cac:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
  405cb0:	2103      	movs	r1, #3
  405cb2:	f020 0080 	bic.w	r0, r0, #128	; 0x80
  405cb6:	2d47      	cmp	r5, #71	; 0x47
  405cb8:	bfd8      	it	le
  405cba:	461a      	movle	r2, r3
  405cbc:	9109      	str	r1, [sp, #36]	; 0x24
  405cbe:	9007      	str	r0, [sp, #28]
  405cc0:	9210      	str	r2, [sp, #64]	; 0x40
  405cc2:	910d      	str	r1, [sp, #52]	; 0x34
  405cc4:	f7ff b9ae 	b.w	405024 <_svfprintf_r+0x240>
  405cc8:	9b07      	ldr	r3, [sp, #28]
  405cca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405ccc:	f013 0f40 	tst.w	r3, #64	; 0x40
  405cd0:	4613      	mov	r3, r2
  405cd2:	f43f ac2e 	beq.w	405532 <_svfprintf_r+0x74e>
  405cd6:	3304      	adds	r3, #4
  405cd8:	f8b2 8000 	ldrh.w	r8, [r2]
  405cdc:	930e      	str	r3, [sp, #56]	; 0x38
  405cde:	f04f 0900 	mov.w	r9, #0
  405ce2:	f7ff bb37 	b.w	405354 <_svfprintf_r+0x570>
  405ce6:	9b07      	ldr	r3, [sp, #28]
  405ce8:	06db      	lsls	r3, r3, #27
  405cea:	d40b      	bmi.n	405d04 <_svfprintf_r+0xf20>
  405cec:	9b07      	ldr	r3, [sp, #28]
  405cee:	065d      	lsls	r5, r3, #25
  405cf0:	d508      	bpl.n	405d04 <_svfprintf_r+0xf20>
  405cf2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405cf4:	6813      	ldr	r3, [r2, #0]
  405cf6:	3204      	adds	r2, #4
  405cf8:	920e      	str	r2, [sp, #56]	; 0x38
  405cfa:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
  405cfe:	801a      	strh	r2, [r3, #0]
  405d00:	f7ff b895 	b.w	404e2e <_svfprintf_r+0x4a>
  405d04:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  405d06:	6813      	ldr	r3, [r2, #0]
  405d08:	3204      	adds	r2, #4
  405d0a:	920e      	str	r2, [sp, #56]	; 0x38
  405d0c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  405d0e:	601a      	str	r2, [r3, #0]
  405d10:	f7ff b88d 	b.w	404e2e <_svfprintf_r+0x4a>
  405d14:	4693      	mov	fp, r2
  405d16:	3301      	adds	r3, #1
  405d18:	44ab      	add	fp, r5
  405d1a:	2b07      	cmp	r3, #7
  405d1c:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405d20:	9324      	str	r3, [sp, #144]	; 0x90
  405d22:	f8c4 9000 	str.w	r9, [r4]
  405d26:	6065      	str	r5, [r4, #4]
  405d28:	f73f af13 	bgt.w	405b52 <_svfprintf_r+0xd6e>
  405d2c:	3408      	adds	r4, #8
  405d2e:	e71b      	b.n	405b68 <_svfprintf_r+0xd84>
  405d30:	9808      	ldr	r0, [sp, #32]
  405d32:	4631      	mov	r1, r6
  405d34:	aa23      	add	r2, sp, #140	; 0x8c
  405d36:	f002 fc3d 	bl	4085b4 <__ssprint_r>
  405d3a:	2800      	cmp	r0, #0
  405d3c:	f47f a918 	bne.w	404f70 <_svfprintf_r+0x18c>
  405d40:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405d44:	463c      	mov	r4, r7
  405d46:	e4c0      	b.n	4056ca <_svfprintf_r+0x8e6>
  405d48:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405d4a:	4a8a      	ldr	r2, [pc, #552]	; (405f74 <_svfprintf_r+0x1190>)
  405d4c:	6022      	str	r2, [r4, #0]
  405d4e:	3301      	adds	r3, #1
  405d50:	f10b 0b01 	add.w	fp, fp, #1
  405d54:	2201      	movs	r2, #1
  405d56:	2b07      	cmp	r3, #7
  405d58:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405d5c:	9324      	str	r3, [sp, #144]	; 0x90
  405d5e:	6062      	str	r2, [r4, #4]
  405d60:	f300 80f4 	bgt.w	405f4c <_svfprintf_r+0x1168>
  405d64:	3408      	adds	r4, #8
  405d66:	b92d      	cbnz	r5, 405d74 <_svfprintf_r+0xf90>
  405d68:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  405d6a:	b91b      	cbnz	r3, 405d74 <_svfprintf_r+0xf90>
  405d6c:	9b07      	ldr	r3, [sp, #28]
  405d6e:	07db      	lsls	r3, r3, #31
  405d70:	f57f aa32 	bpl.w	4051d8 <_svfprintf_r+0x3f4>
  405d74:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405d76:	9818      	ldr	r0, [sp, #96]	; 0x60
  405d78:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  405d7a:	6022      	str	r2, [r4, #0]
  405d7c:	3301      	adds	r3, #1
  405d7e:	eb0b 0100 	add.w	r1, fp, r0
  405d82:	2b07      	cmp	r3, #7
  405d84:	9125      	str	r1, [sp, #148]	; 0x94
  405d86:	6060      	str	r0, [r4, #4]
  405d88:	9324      	str	r3, [sp, #144]	; 0x90
  405d8a:	f300 81f3 	bgt.w	406174 <_svfprintf_r+0x1390>
  405d8e:	f104 0208 	add.w	r2, r4, #8
  405d92:	426d      	negs	r5, r5
  405d94:	2d00      	cmp	r5, #0
  405d96:	f340 80fc 	ble.w	405f92 <_svfprintf_r+0x11ae>
  405d9a:	2d10      	cmp	r5, #16
  405d9c:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 405f78 <_svfprintf_r+0x1194>
  405da0:	f340 813d 	ble.w	40601e <_svfprintf_r+0x123a>
  405da4:	2410      	movs	r4, #16
  405da6:	f8dd 8020 	ldr.w	r8, [sp, #32]
  405daa:	e004      	b.n	405db6 <_svfprintf_r+0xfd2>
  405dac:	3208      	adds	r2, #8
  405dae:	3d10      	subs	r5, #16
  405db0:	2d10      	cmp	r5, #16
  405db2:	f340 8134 	ble.w	40601e <_svfprintf_r+0x123a>
  405db6:	3301      	adds	r3, #1
  405db8:	3110      	adds	r1, #16
  405dba:	2b07      	cmp	r3, #7
  405dbc:	9125      	str	r1, [sp, #148]	; 0x94
  405dbe:	9324      	str	r3, [sp, #144]	; 0x90
  405dc0:	f8c2 9000 	str.w	r9, [r2]
  405dc4:	6054      	str	r4, [r2, #4]
  405dc6:	ddf1      	ble.n	405dac <_svfprintf_r+0xfc8>
  405dc8:	4640      	mov	r0, r8
  405dca:	4631      	mov	r1, r6
  405dcc:	aa23      	add	r2, sp, #140	; 0x8c
  405dce:	f002 fbf1 	bl	4085b4 <__ssprint_r>
  405dd2:	2800      	cmp	r0, #0
  405dd4:	f47f a8cc 	bne.w	404f70 <_svfprintf_r+0x18c>
  405dd8:	9925      	ldr	r1, [sp, #148]	; 0x94
  405dda:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405ddc:	463a      	mov	r2, r7
  405dde:	e7e6      	b.n	405dae <_svfprintf_r+0xfca>
  405de0:	9b25      	ldr	r3, [sp, #148]	; 0x94
  405de2:	46b1      	mov	r9, r6
  405de4:	2b00      	cmp	r3, #0
  405de6:	f43f a8c4 	beq.w	404f72 <_svfprintf_r+0x18e>
  405dea:	9808      	ldr	r0, [sp, #32]
  405dec:	4631      	mov	r1, r6
  405dee:	aa23      	add	r2, sp, #140	; 0x8c
  405df0:	f002 fbe0 	bl	4085b4 <__ssprint_r>
  405df4:	f7ff b8bd 	b.w	404f72 <_svfprintf_r+0x18e>
  405df8:	980c      	ldr	r0, [sp, #48]	; 0x30
  405dfa:	910e      	str	r1, [sp, #56]	; 0x38
  405dfc:	4240      	negs	r0, r0
  405dfe:	900c      	str	r0, [sp, #48]	; 0x30
  405e00:	4619      	mov	r1, r3
  405e02:	f7ff ba3f 	b.w	405284 <_svfprintf_r+0x4a0>
  405e06:	f041 0120 	orr.w	r1, r1, #32
  405e0a:	9107      	str	r1, [sp, #28]
  405e0c:	785d      	ldrb	r5, [r3, #1]
  405e0e:	1c59      	adds	r1, r3, #1
  405e10:	f7ff b83b 	b.w	404e8a <_svfprintf_r+0xa6>
  405e14:	9808      	ldr	r0, [sp, #32]
  405e16:	4631      	mov	r1, r6
  405e18:	aa23      	add	r2, sp, #140	; 0x8c
  405e1a:	f002 fbcb 	bl	4085b4 <__ssprint_r>
  405e1e:	2800      	cmp	r0, #0
  405e20:	f47f a8a6 	bne.w	404f70 <_svfprintf_r+0x18c>
  405e24:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405e28:	463c      	mov	r4, r7
  405e2a:	e464      	b.n	4056f6 <_svfprintf_r+0x912>
  405e2c:	f025 0320 	bic.w	r3, r5, #32
  405e30:	f1ba 3fff 	cmp.w	sl, #4294967295
  405e34:	930d      	str	r3, [sp, #52]	; 0x34
  405e36:	f000 8096 	beq.w	405f66 <_svfprintf_r+0x1182>
  405e3a:	2b47      	cmp	r3, #71	; 0x47
  405e3c:	d105      	bne.n	405e4a <_svfprintf_r+0x1066>
  405e3e:	f1ba 0f00 	cmp.w	sl, #0
  405e42:	bf14      	ite	ne
  405e44:	46d3      	movne	fp, sl
  405e46:	f04f 0b01 	moveq.w	fp, #1
  405e4a:	9b07      	ldr	r3, [sp, #28]
  405e4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  405e50:	9311      	str	r3, [sp, #68]	; 0x44
  405e52:	9b15      	ldr	r3, [sp, #84]	; 0x54
  405e54:	f1b3 0a00 	subs.w	sl, r3, #0
  405e58:	9b14      	ldr	r3, [sp, #80]	; 0x50
  405e5a:	9309      	str	r3, [sp, #36]	; 0x24
  405e5c:	bfbb      	ittet	lt
  405e5e:	4653      	movlt	r3, sl
  405e60:	f103 4a00 	addlt.w	sl, r3, #2147483648	; 0x80000000
  405e64:	2300      	movge	r3, #0
  405e66:	232d      	movlt	r3, #45	; 0x2d
  405e68:	2d66      	cmp	r5, #102	; 0x66
  405e6a:	930f      	str	r3, [sp, #60]	; 0x3c
  405e6c:	f000 80ac 	beq.w	405fc8 <_svfprintf_r+0x11e4>
  405e70:	2d46      	cmp	r5, #70	; 0x46
  405e72:	f000 80a9 	beq.w	405fc8 <_svfprintf_r+0x11e4>
  405e76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405e78:	9a09      	ldr	r2, [sp, #36]	; 0x24
  405e7a:	2b45      	cmp	r3, #69	; 0x45
  405e7c:	bf0c      	ite	eq
  405e7e:	f10b 0901 	addeq.w	r9, fp, #1
  405e82:	46d9      	movne	r9, fp
  405e84:	2002      	movs	r0, #2
  405e86:	a91d      	add	r1, sp, #116	; 0x74
  405e88:	e88d 0201 	stmia.w	sp, {r0, r9}
  405e8c:	9102      	str	r1, [sp, #8]
  405e8e:	a81e      	add	r0, sp, #120	; 0x78
  405e90:	a921      	add	r1, sp, #132	; 0x84
  405e92:	9003      	str	r0, [sp, #12]
  405e94:	4653      	mov	r3, sl
  405e96:	9104      	str	r1, [sp, #16]
  405e98:	9808      	ldr	r0, [sp, #32]
  405e9a:	f000 fa95 	bl	4063c8 <_dtoa_r>
  405e9e:	2d67      	cmp	r5, #103	; 0x67
  405ea0:	9010      	str	r0, [sp, #64]	; 0x40
  405ea2:	d002      	beq.n	405eaa <_svfprintf_r+0x10c6>
  405ea4:	2d47      	cmp	r5, #71	; 0x47
  405ea6:	f040 809f 	bne.w	405fe8 <_svfprintf_r+0x1204>
  405eaa:	9b07      	ldr	r3, [sp, #28]
  405eac:	07db      	lsls	r3, r3, #31
  405eae:	f140 8189 	bpl.w	4061c4 <_svfprintf_r+0x13e0>
  405eb2:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405eb4:	eb03 0809 	add.w	r8, r3, r9
  405eb8:	9809      	ldr	r0, [sp, #36]	; 0x24
  405eba:	4651      	mov	r1, sl
  405ebc:	2200      	movs	r2, #0
  405ebe:	2300      	movs	r3, #0
  405ec0:	f003 f89c 	bl	408ffc <__aeabi_dcmpeq>
  405ec4:	2800      	cmp	r0, #0
  405ec6:	f040 80fd 	bne.w	4060c4 <_svfprintf_r+0x12e0>
  405eca:	9b21      	ldr	r3, [sp, #132]	; 0x84
  405ecc:	4598      	cmp	r8, r3
  405ece:	d906      	bls.n	405ede <_svfprintf_r+0x10fa>
  405ed0:	2130      	movs	r1, #48	; 0x30
  405ed2:	1c5a      	adds	r2, r3, #1
  405ed4:	9221      	str	r2, [sp, #132]	; 0x84
  405ed6:	7019      	strb	r1, [r3, #0]
  405ed8:	9b21      	ldr	r3, [sp, #132]	; 0x84
  405eda:	4598      	cmp	r8, r3
  405edc:	d8f9      	bhi.n	405ed2 <_svfprintf_r+0x10ee>
  405ede:	9a10      	ldr	r2, [sp, #64]	; 0x40
  405ee0:	1a9b      	subs	r3, r3, r2
  405ee2:	9313      	str	r3, [sp, #76]	; 0x4c
  405ee4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405ee6:	2b47      	cmp	r3, #71	; 0x47
  405ee8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  405eea:	f000 80de 	beq.w	4060aa <_svfprintf_r+0x12c6>
  405eee:	2d65      	cmp	r5, #101	; 0x65
  405ef0:	f340 80f8 	ble.w	4060e4 <_svfprintf_r+0x1300>
  405ef4:	2d66      	cmp	r5, #102	; 0x66
  405ef6:	9312      	str	r3, [sp, #72]	; 0x48
  405ef8:	f000 8157 	beq.w	4061aa <_svfprintf_r+0x13c6>
  405efc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  405efe:	9a12      	ldr	r2, [sp, #72]	; 0x48
  405f00:	4293      	cmp	r3, r2
  405f02:	f300 8144 	bgt.w	40618e <_svfprintf_r+0x13aa>
  405f06:	9b07      	ldr	r3, [sp, #28]
  405f08:	07d9      	lsls	r1, r3, #31
  405f0a:	f100 8173 	bmi.w	4061f4 <_svfprintf_r+0x1410>
  405f0e:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  405f12:	920d      	str	r2, [sp, #52]	; 0x34
  405f14:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  405f16:	2a00      	cmp	r2, #0
  405f18:	f040 80bc 	bne.w	406094 <_svfprintf_r+0x12b0>
  405f1c:	9309      	str	r3, [sp, #36]	; 0x24
  405f1e:	9b11      	ldr	r3, [sp, #68]	; 0x44
  405f20:	9307      	str	r3, [sp, #28]
  405f22:	9211      	str	r2, [sp, #68]	; 0x44
  405f24:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  405f28:	f7ff b87c 	b.w	405024 <_svfprintf_r+0x240>
  405f2c:	9808      	ldr	r0, [sp, #32]
  405f2e:	2140      	movs	r1, #64	; 0x40
  405f30:	f001 fad4 	bl	4074dc <_malloc_r>
  405f34:	f8c9 0000 	str.w	r0, [r9]
  405f38:	f8c9 0010 	str.w	r0, [r9, #16]
  405f3c:	2800      	cmp	r0, #0
  405f3e:	f000 818c 	beq.w	40625a <_svfprintf_r+0x1476>
  405f42:	2340      	movs	r3, #64	; 0x40
  405f44:	f8c9 3014 	str.w	r3, [r9, #20]
  405f48:	f7fe bf64 	b.w	404e14 <_svfprintf_r+0x30>
  405f4c:	9808      	ldr	r0, [sp, #32]
  405f4e:	4631      	mov	r1, r6
  405f50:	aa23      	add	r2, sp, #140	; 0x8c
  405f52:	f002 fb2f 	bl	4085b4 <__ssprint_r>
  405f56:	2800      	cmp	r0, #0
  405f58:	f47f a80a 	bne.w	404f70 <_svfprintf_r+0x18c>
  405f5c:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  405f5e:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  405f62:	463c      	mov	r4, r7
  405f64:	e6ff      	b.n	405d66 <_svfprintf_r+0xf82>
  405f66:	f04f 0b06 	mov.w	fp, #6
  405f6a:	e76e      	b.n	405e4a <_svfprintf_r+0x1066>
  405f6c:	0040b110 	.word	0x0040b110
  405f70:	0040b10c 	.word	0x0040b10c
  405f74:	0040b144 	.word	0x0040b144
  405f78:	0040b0e4 	.word	0x0040b0e4
  405f7c:	9808      	ldr	r0, [sp, #32]
  405f7e:	4631      	mov	r1, r6
  405f80:	aa23      	add	r2, sp, #140	; 0x8c
  405f82:	f002 fb17 	bl	4085b4 <__ssprint_r>
  405f86:	2800      	cmp	r0, #0
  405f88:	f47e aff2 	bne.w	404f70 <_svfprintf_r+0x18c>
  405f8c:	9925      	ldr	r1, [sp, #148]	; 0x94
  405f8e:	9b24      	ldr	r3, [sp, #144]	; 0x90
  405f90:	463a      	mov	r2, r7
  405f92:	9c13      	ldr	r4, [sp, #76]	; 0x4c
  405f94:	6054      	str	r4, [r2, #4]
  405f96:	3301      	adds	r3, #1
  405f98:	eb01 0b04 	add.w	fp, r1, r4
  405f9c:	2b07      	cmp	r3, #7
  405f9e:	9910      	ldr	r1, [sp, #64]	; 0x40
  405fa0:	f8cd b094 	str.w	fp, [sp, #148]	; 0x94
  405fa4:	9324      	str	r3, [sp, #144]	; 0x90
  405fa6:	6011      	str	r1, [r2, #0]
  405fa8:	f73f ac5b 	bgt.w	405862 <_svfprintf_r+0xa7e>
  405fac:	f102 0408 	add.w	r4, r2, #8
  405fb0:	f7ff b912 	b.w	4051d8 <_svfprintf_r+0x3f4>
  405fb4:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
  405fb8:	f7fe fd9e 	bl	404af8 <strlen>
  405fbc:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  405fc0:	900d      	str	r0, [sp, #52]	; 0x34
  405fc2:	4603      	mov	r3, r0
  405fc4:	f7ff ba1b 	b.w	4053fe <_svfprintf_r+0x61a>
  405fc8:	2003      	movs	r0, #3
  405fca:	a91d      	add	r1, sp, #116	; 0x74
  405fcc:	e88d 0801 	stmia.w	sp, {r0, fp}
  405fd0:	9102      	str	r1, [sp, #8]
  405fd2:	a81e      	add	r0, sp, #120	; 0x78
  405fd4:	a921      	add	r1, sp, #132	; 0x84
  405fd6:	9003      	str	r0, [sp, #12]
  405fd8:	9a09      	ldr	r2, [sp, #36]	; 0x24
  405fda:	9104      	str	r1, [sp, #16]
  405fdc:	4653      	mov	r3, sl
  405fde:	9808      	ldr	r0, [sp, #32]
  405fe0:	f000 f9f2 	bl	4063c8 <_dtoa_r>
  405fe4:	46d9      	mov	r9, fp
  405fe6:	9010      	str	r0, [sp, #64]	; 0x40
  405fe8:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405fea:	eb03 0809 	add.w	r8, r3, r9
  405fee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  405ff0:	2b46      	cmp	r3, #70	; 0x46
  405ff2:	f47f af61 	bne.w	405eb8 <_svfprintf_r+0x10d4>
  405ff6:	9b10      	ldr	r3, [sp, #64]	; 0x40
  405ff8:	781b      	ldrb	r3, [r3, #0]
  405ffa:	2b30      	cmp	r3, #48	; 0x30
  405ffc:	f000 80e4 	beq.w	4061c8 <_svfprintf_r+0x13e4>
  406000:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  406002:	4498      	add	r8, r3
  406004:	e758      	b.n	405eb8 <_svfprintf_r+0x10d4>
  406006:	9808      	ldr	r0, [sp, #32]
  406008:	4631      	mov	r1, r6
  40600a:	aa23      	add	r2, sp, #140	; 0x8c
  40600c:	f002 fad2 	bl	4085b4 <__ssprint_r>
  406010:	2800      	cmp	r0, #0
  406012:	f47e afad 	bne.w	404f70 <_svfprintf_r+0x18c>
  406016:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40601a:	463c      	mov	r4, r7
  40601c:	e4a7      	b.n	40596e <_svfprintf_r+0xb8a>
  40601e:	3301      	adds	r3, #1
  406020:	4429      	add	r1, r5
  406022:	2b07      	cmp	r3, #7
  406024:	9125      	str	r1, [sp, #148]	; 0x94
  406026:	9324      	str	r3, [sp, #144]	; 0x90
  406028:	f8c2 9000 	str.w	r9, [r2]
  40602c:	6055      	str	r5, [r2, #4]
  40602e:	dca5      	bgt.n	405f7c <_svfprintf_r+0x1198>
  406030:	3208      	adds	r2, #8
  406032:	e7ae      	b.n	405f92 <_svfprintf_r+0x11ae>
  406034:	9808      	ldr	r0, [sp, #32]
  406036:	4631      	mov	r1, r6
  406038:	aa23      	add	r2, sp, #140	; 0x8c
  40603a:	f002 fabb 	bl	4085b4 <__ssprint_r>
  40603e:	2800      	cmp	r0, #0
  406040:	f47e af96 	bne.w	404f70 <_svfprintf_r+0x18c>
  406044:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  406046:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40604a:	463c      	mov	r4, r7
  40604c:	e597      	b.n	405b7e <_svfprintf_r+0xd9a>
  40604e:	4653      	mov	r3, sl
  406050:	2b06      	cmp	r3, #6
  406052:	bf28      	it	cs
  406054:	2306      	movcs	r3, #6
  406056:	930d      	str	r3, [sp, #52]	; 0x34
  406058:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  40605c:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  406060:	9309      	str	r3, [sp, #36]	; 0x24
  406062:	4b83      	ldr	r3, [pc, #524]	; (406270 <_svfprintf_r+0x148c>)
  406064:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  406068:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
  40606c:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
  406070:	9310      	str	r3, [sp, #64]	; 0x40
  406072:	f7fe bfd7 	b.w	405024 <_svfprintf_r+0x240>
  406076:	9808      	ldr	r0, [sp, #32]
  406078:	4631      	mov	r1, r6
  40607a:	aa23      	add	r2, sp, #140	; 0x8c
  40607c:	f002 fa9a 	bl	4085b4 <__ssprint_r>
  406080:	2800      	cmp	r0, #0
  406082:	f47e af75 	bne.w	404f70 <_svfprintf_r+0x18c>
  406086:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  406088:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  40608a:	f8dd b094 	ldr.w	fp, [sp, #148]	; 0x94
  40608e:	1ad3      	subs	r3, r2, r3
  406090:	463c      	mov	r4, r7
  406092:	e58a      	b.n	405baa <_svfprintf_r+0xdc6>
  406094:	9309      	str	r3, [sp, #36]	; 0x24
  406096:	9b11      	ldr	r3, [sp, #68]	; 0x44
  406098:	9307      	str	r3, [sp, #28]
  40609a:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  40609e:	2300      	movs	r3, #0
  4060a0:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  4060a4:	9311      	str	r3, [sp, #68]	; 0x44
  4060a6:	f7fe bfc0 	b.w	40502a <_svfprintf_r+0x246>
  4060aa:	1cda      	adds	r2, r3, #3
  4060ac:	db19      	blt.n	4060e2 <_svfprintf_r+0x12fe>
  4060ae:	459b      	cmp	fp, r3
  4060b0:	db17      	blt.n	4060e2 <_svfprintf_r+0x12fe>
  4060b2:	9312      	str	r3, [sp, #72]	; 0x48
  4060b4:	2567      	movs	r5, #103	; 0x67
  4060b6:	e721      	b.n	405efc <_svfprintf_r+0x1118>
  4060b8:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
  4060bc:	f88d c06f 	strb.w	ip, [sp, #111]	; 0x6f
  4060c0:	f7ff ba98 	b.w	4055f4 <_svfprintf_r+0x810>
  4060c4:	4643      	mov	r3, r8
  4060c6:	e70a      	b.n	405ede <_svfprintf_r+0x10fa>
  4060c8:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
  4060cc:	9011      	str	r0, [sp, #68]	; 0x44
  4060ce:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
  4060d2:	9012      	str	r0, [sp, #72]	; 0x48
  4060d4:	f89d c06f 	ldrb.w	ip, [sp, #111]	; 0x6f
  4060d8:	9309      	str	r3, [sp, #36]	; 0x24
  4060da:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  4060de:	f7fe bfa1 	b.w	405024 <_svfprintf_r+0x240>
  4060e2:	3d02      	subs	r5, #2
  4060e4:	3b01      	subs	r3, #1
  4060e6:	2b00      	cmp	r3, #0
  4060e8:	931d      	str	r3, [sp, #116]	; 0x74
  4060ea:	bfba      	itte	lt
  4060ec:	425b      	neglt	r3, r3
  4060ee:	222d      	movlt	r2, #45	; 0x2d
  4060f0:	222b      	movge	r2, #43	; 0x2b
  4060f2:	2b09      	cmp	r3, #9
  4060f4:	f88d 507c 	strb.w	r5, [sp, #124]	; 0x7c
  4060f8:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
  4060fc:	dd72      	ble.n	4061e4 <_svfprintf_r+0x1400>
  4060fe:	f10d 0e8b 	add.w	lr, sp, #139	; 0x8b
  406102:	4670      	mov	r0, lr
  406104:	4a5b      	ldr	r2, [pc, #364]	; (406274 <_svfprintf_r+0x1490>)
  406106:	fb82 2103 	smull	r2, r1, r2, r3
  40610a:	17da      	asrs	r2, r3, #31
  40610c:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
  406110:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  406114:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
  406118:	f103 0130 	add.w	r1, r3, #48	; 0x30
  40611c:	2a09      	cmp	r2, #9
  40611e:	4613      	mov	r3, r2
  406120:	f800 1d01 	strb.w	r1, [r0, #-1]!
  406124:	dcee      	bgt.n	406104 <_svfprintf_r+0x1320>
  406126:	4602      	mov	r2, r0
  406128:	3330      	adds	r3, #48	; 0x30
  40612a:	b2d9      	uxtb	r1, r3
  40612c:	f802 1d01 	strb.w	r1, [r2, #-1]!
  406130:	4596      	cmp	lr, r2
  406132:	f240 8099 	bls.w	406268 <_svfprintf_r+0x1484>
  406136:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  40613a:	4603      	mov	r3, r0
  40613c:	e001      	b.n	406142 <_svfprintf_r+0x135e>
  40613e:	f813 1b01 	ldrb.w	r1, [r3], #1
  406142:	f802 1b01 	strb.w	r1, [r2], #1
  406146:	4573      	cmp	r3, lr
  406148:	d1f9      	bne.n	40613e <_svfprintf_r+0x135a>
  40614a:	ab23      	add	r3, sp, #140	; 0x8c
  40614c:	1a1b      	subs	r3, r3, r0
  40614e:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  406152:	4413      	add	r3, r2
  406154:	aa1f      	add	r2, sp, #124	; 0x7c
  406156:	1a9b      	subs	r3, r3, r2
  406158:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  40615a:	9319      	str	r3, [sp, #100]	; 0x64
  40615c:	2a01      	cmp	r2, #1
  40615e:	4413      	add	r3, r2
  406160:	930d      	str	r3, [sp, #52]	; 0x34
  406162:	dd6b      	ble.n	40623c <_svfprintf_r+0x1458>
  406164:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  406166:	2200      	movs	r2, #0
  406168:	3301      	adds	r3, #1
  40616a:	930d      	str	r3, [sp, #52]	; 0x34
  40616c:	9212      	str	r2, [sp, #72]	; 0x48
  40616e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  406172:	e6cf      	b.n	405f14 <_svfprintf_r+0x1130>
  406174:	9808      	ldr	r0, [sp, #32]
  406176:	4631      	mov	r1, r6
  406178:	aa23      	add	r2, sp, #140	; 0x8c
  40617a:	f002 fa1b 	bl	4085b4 <__ssprint_r>
  40617e:	2800      	cmp	r0, #0
  406180:	f47e aef6 	bne.w	404f70 <_svfprintf_r+0x18c>
  406184:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  406186:	9925      	ldr	r1, [sp, #148]	; 0x94
  406188:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40618a:	463a      	mov	r2, r7
  40618c:	e601      	b.n	405d92 <_svfprintf_r+0xfae>
  40618e:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406190:	2b00      	cmp	r3, #0
  406192:	bfd8      	it	le
  406194:	f1c3 0802 	rsble	r8, r3, #2
  406198:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  40619a:	bfc8      	it	gt
  40619c:	f04f 0801 	movgt.w	r8, #1
  4061a0:	4443      	add	r3, r8
  4061a2:	930d      	str	r3, [sp, #52]	; 0x34
  4061a4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4061a8:	e6b4      	b.n	405f14 <_svfprintf_r+0x1130>
  4061aa:	2b00      	cmp	r3, #0
  4061ac:	dd30      	ble.n	406210 <_svfprintf_r+0x142c>
  4061ae:	f1bb 0f00 	cmp.w	fp, #0
  4061b2:	d125      	bne.n	406200 <_svfprintf_r+0x141c>
  4061b4:	9b07      	ldr	r3, [sp, #28]
  4061b6:	07db      	lsls	r3, r3, #31
  4061b8:	d422      	bmi.n	406200 <_svfprintf_r+0x141c>
  4061ba:	9a12      	ldr	r2, [sp, #72]	; 0x48
  4061bc:	920d      	str	r2, [sp, #52]	; 0x34
  4061be:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  4061c2:	e6a7      	b.n	405f14 <_svfprintf_r+0x1130>
  4061c4:	9b21      	ldr	r3, [sp, #132]	; 0x84
  4061c6:	e68a      	b.n	405ede <_svfprintf_r+0x10fa>
  4061c8:	9809      	ldr	r0, [sp, #36]	; 0x24
  4061ca:	4651      	mov	r1, sl
  4061cc:	2200      	movs	r2, #0
  4061ce:	2300      	movs	r3, #0
  4061d0:	f002 ff14 	bl	408ffc <__aeabi_dcmpeq>
  4061d4:	2800      	cmp	r0, #0
  4061d6:	f47f af13 	bne.w	406000 <_svfprintf_r+0x121c>
  4061da:	f1c9 0301 	rsb	r3, r9, #1
  4061de:	931d      	str	r3, [sp, #116]	; 0x74
  4061e0:	4498      	add	r8, r3
  4061e2:	e669      	b.n	405eb8 <_svfprintf_r+0x10d4>
  4061e4:	3330      	adds	r3, #48	; 0x30
  4061e6:	2230      	movs	r2, #48	; 0x30
  4061e8:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
  4061ec:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
  4061f0:	ab20      	add	r3, sp, #128	; 0x80
  4061f2:	e7af      	b.n	406154 <_svfprintf_r+0x1370>
  4061f4:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4061f6:	3301      	adds	r3, #1
  4061f8:	930d      	str	r3, [sp, #52]	; 0x34
  4061fa:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4061fe:	e689      	b.n	405f14 <_svfprintf_r+0x1130>
  406200:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406202:	f10b 0801 	add.w	r8, fp, #1
  406206:	4443      	add	r3, r8
  406208:	930d      	str	r3, [sp, #52]	; 0x34
  40620a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  40620e:	e681      	b.n	405f14 <_svfprintf_r+0x1130>
  406210:	f1bb 0f00 	cmp.w	fp, #0
  406214:	d11b      	bne.n	40624e <_svfprintf_r+0x146a>
  406216:	9b07      	ldr	r3, [sp, #28]
  406218:	07d8      	lsls	r0, r3, #31
  40621a:	d418      	bmi.n	40624e <_svfprintf_r+0x146a>
  40621c:	2301      	movs	r3, #1
  40621e:	930d      	str	r3, [sp, #52]	; 0x34
  406220:	e678      	b.n	405f14 <_svfprintf_r+0x1130>
  406222:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  406224:	f8d5 a000 	ldr.w	sl, [r5]
  406228:	4628      	mov	r0, r5
  40622a:	3004      	adds	r0, #4
  40622c:	f1ba 0f00 	cmp.w	sl, #0
  406230:	785d      	ldrb	r5, [r3, #1]
  406232:	900e      	str	r0, [sp, #56]	; 0x38
  406234:	f6be ae29 	bge.w	404e8a <_svfprintf_r+0xa6>
  406238:	f7fe be25 	b.w	404e86 <_svfprintf_r+0xa2>
  40623c:	9b07      	ldr	r3, [sp, #28]
  40623e:	f013 0301 	ands.w	r3, r3, #1
  406242:	d18f      	bne.n	406164 <_svfprintf_r+0x1380>
  406244:	9312      	str	r3, [sp, #72]	; 0x48
  406246:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  406248:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  40624c:	e662      	b.n	405f14 <_svfprintf_r+0x1130>
  40624e:	f10b 0302 	add.w	r3, fp, #2
  406252:	930d      	str	r3, [sp, #52]	; 0x34
  406254:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  406258:	e65c      	b.n	405f14 <_svfprintf_r+0x1130>
  40625a:	9a08      	ldr	r2, [sp, #32]
  40625c:	230c      	movs	r3, #12
  40625e:	6013      	str	r3, [r2, #0]
  406260:	f04f 30ff 	mov.w	r0, #4294967295
  406264:	f7fe be8e 	b.w	404f84 <_svfprintf_r+0x1a0>
  406268:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
  40626c:	e772      	b.n	406154 <_svfprintf_r+0x1370>
  40626e:	bf00      	nop
  406270:	0040b13c 	.word	0x0040b13c
  406274:	66666667 	.word	0x66666667

00406278 <register_fini>:
  406278:	4b02      	ldr	r3, [pc, #8]	; (406284 <register_fini+0xc>)
  40627a:	b113      	cbz	r3, 406282 <register_fini+0xa>
  40627c:	4802      	ldr	r0, [pc, #8]	; (406288 <register_fini+0x10>)
  40627e:	f000 b805 	b.w	40628c <atexit>
  406282:	4770      	bx	lr
  406284:	00000000 	.word	0x00000000
  406288:	0040725d 	.word	0x0040725d

0040628c <atexit>:
  40628c:	4601      	mov	r1, r0
  40628e:	2000      	movs	r0, #0
  406290:	4602      	mov	r2, r0
  406292:	4603      	mov	r3, r0
  406294:	f002 ba10 	b.w	4086b8 <__register_exitproc>

00406298 <quorem>:
  406298:	6902      	ldr	r2, [r0, #16]
  40629a:	690b      	ldr	r3, [r1, #16]
  40629c:	4293      	cmp	r3, r2
  40629e:	f300 808f 	bgt.w	4063c0 <quorem+0x128>
  4062a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4062a6:	f103 38ff 	add.w	r8, r3, #4294967295
  4062aa:	f101 0714 	add.w	r7, r1, #20
  4062ae:	f100 0b14 	add.w	fp, r0, #20
  4062b2:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  4062b6:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  4062ba:	ea4f 0488 	mov.w	r4, r8, lsl #2
  4062be:	b083      	sub	sp, #12
  4062c0:	3201      	adds	r2, #1
  4062c2:	fbb3 f9f2 	udiv	r9, r3, r2
  4062c6:	eb0b 0304 	add.w	r3, fp, r4
  4062ca:	9400      	str	r4, [sp, #0]
  4062cc:	eb07 0a04 	add.w	sl, r7, r4
  4062d0:	9301      	str	r3, [sp, #4]
  4062d2:	f1b9 0f00 	cmp.w	r9, #0
  4062d6:	d03b      	beq.n	406350 <quorem+0xb8>
  4062d8:	2600      	movs	r6, #0
  4062da:	4632      	mov	r2, r6
  4062dc:	46bc      	mov	ip, r7
  4062de:	46de      	mov	lr, fp
  4062e0:	4634      	mov	r4, r6
  4062e2:	f85c 6b04 	ldr.w	r6, [ip], #4
  4062e6:	f8de 5000 	ldr.w	r5, [lr]
  4062ea:	b2b3      	uxth	r3, r6
  4062ec:	0c36      	lsrs	r6, r6, #16
  4062ee:	fb03 4409 	mla	r4, r3, r9, r4
  4062f2:	fb06 f609 	mul.w	r6, r6, r9
  4062f6:	eb06 4614 	add.w	r6, r6, r4, lsr #16
  4062fa:	b2a3      	uxth	r3, r4
  4062fc:	1ad3      	subs	r3, r2, r3
  4062fe:	b2b4      	uxth	r4, r6
  406300:	fa13 f385 	uxtah	r3, r3, r5
  406304:	ebc4 4415 	rsb	r4, r4, r5, lsr #16
  406308:	eb04 4423 	add.w	r4, r4, r3, asr #16
  40630c:	b29b      	uxth	r3, r3
  40630e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  406312:	45e2      	cmp	sl, ip
  406314:	ea4f 4224 	mov.w	r2, r4, asr #16
  406318:	f84e 3b04 	str.w	r3, [lr], #4
  40631c:	ea4f 4416 	mov.w	r4, r6, lsr #16
  406320:	d2df      	bcs.n	4062e2 <quorem+0x4a>
  406322:	9b00      	ldr	r3, [sp, #0]
  406324:	f85b 3003 	ldr.w	r3, [fp, r3]
  406328:	b993      	cbnz	r3, 406350 <quorem+0xb8>
  40632a:	9c01      	ldr	r4, [sp, #4]
  40632c:	1f23      	subs	r3, r4, #4
  40632e:	459b      	cmp	fp, r3
  406330:	d20c      	bcs.n	40634c <quorem+0xb4>
  406332:	f854 3c04 	ldr.w	r3, [r4, #-4]
  406336:	b94b      	cbnz	r3, 40634c <quorem+0xb4>
  406338:	f1a4 0308 	sub.w	r3, r4, #8
  40633c:	e002      	b.n	406344 <quorem+0xac>
  40633e:	681a      	ldr	r2, [r3, #0]
  406340:	3b04      	subs	r3, #4
  406342:	b91a      	cbnz	r2, 40634c <quorem+0xb4>
  406344:	459b      	cmp	fp, r3
  406346:	f108 38ff 	add.w	r8, r8, #4294967295
  40634a:	d3f8      	bcc.n	40633e <quorem+0xa6>
  40634c:	f8c0 8010 	str.w	r8, [r0, #16]
  406350:	4604      	mov	r4, r0
  406352:	f001 fe11 	bl	407f78 <__mcmp>
  406356:	2800      	cmp	r0, #0
  406358:	db2e      	blt.n	4063b8 <quorem+0x120>
  40635a:	f109 0901 	add.w	r9, r9, #1
  40635e:	465d      	mov	r5, fp
  406360:	2300      	movs	r3, #0
  406362:	f857 1b04 	ldr.w	r1, [r7], #4
  406366:	6828      	ldr	r0, [r5, #0]
  406368:	b28a      	uxth	r2, r1
  40636a:	1a9a      	subs	r2, r3, r2
  40636c:	0c09      	lsrs	r1, r1, #16
  40636e:	fa12 f280 	uxtah	r2, r2, r0
  406372:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
  406376:	eb03 4322 	add.w	r3, r3, r2, asr #16
  40637a:	b291      	uxth	r1, r2
  40637c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  406380:	45ba      	cmp	sl, r7
  406382:	f845 1b04 	str.w	r1, [r5], #4
  406386:	ea4f 4323 	mov.w	r3, r3, asr #16
  40638a:	d2ea      	bcs.n	406362 <quorem+0xca>
  40638c:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  406390:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  406394:	b982      	cbnz	r2, 4063b8 <quorem+0x120>
  406396:	1f1a      	subs	r2, r3, #4
  406398:	4593      	cmp	fp, r2
  40639a:	d20b      	bcs.n	4063b4 <quorem+0x11c>
  40639c:	f853 2c04 	ldr.w	r2, [r3, #-4]
  4063a0:	b942      	cbnz	r2, 4063b4 <quorem+0x11c>
  4063a2:	3b08      	subs	r3, #8
  4063a4:	e002      	b.n	4063ac <quorem+0x114>
  4063a6:	681a      	ldr	r2, [r3, #0]
  4063a8:	3b04      	subs	r3, #4
  4063aa:	b91a      	cbnz	r2, 4063b4 <quorem+0x11c>
  4063ac:	459b      	cmp	fp, r3
  4063ae:	f108 38ff 	add.w	r8, r8, #4294967295
  4063b2:	d3f8      	bcc.n	4063a6 <quorem+0x10e>
  4063b4:	f8c4 8010 	str.w	r8, [r4, #16]
  4063b8:	4648      	mov	r0, r9
  4063ba:	b003      	add	sp, #12
  4063bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4063c0:	2000      	movs	r0, #0
  4063c2:	4770      	bx	lr
  4063c4:	0000      	movs	r0, r0
	...

004063c8 <_dtoa_r>:
  4063c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4063cc:	6c01      	ldr	r1, [r0, #64]	; 0x40
  4063ce:	b097      	sub	sp, #92	; 0x5c
  4063d0:	4604      	mov	r4, r0
  4063d2:	9d23      	ldr	r5, [sp, #140]	; 0x8c
  4063d4:	e9cd 2302 	strd	r2, r3, [sp, #8]
  4063d8:	b141      	cbz	r1, 4063ec <_dtoa_r+0x24>
  4063da:	6c42      	ldr	r2, [r0, #68]	; 0x44
  4063dc:	604a      	str	r2, [r1, #4]
  4063de:	2301      	movs	r3, #1
  4063e0:	4093      	lsls	r3, r2
  4063e2:	608b      	str	r3, [r1, #8]
  4063e4:	f001 fbe4 	bl	407bb0 <_Bfree>
  4063e8:	2300      	movs	r3, #0
  4063ea:	6423      	str	r3, [r4, #64]	; 0x40
  4063ec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4063f0:	2b00      	cmp	r3, #0
  4063f2:	4699      	mov	r9, r3
  4063f4:	db36      	blt.n	406464 <_dtoa_r+0x9c>
  4063f6:	2300      	movs	r3, #0
  4063f8:	602b      	str	r3, [r5, #0]
  4063fa:	4ba5      	ldr	r3, [pc, #660]	; (406690 <_dtoa_r+0x2c8>)
  4063fc:	461a      	mov	r2, r3
  4063fe:	ea09 0303 	and.w	r3, r9, r3
  406402:	4293      	cmp	r3, r2
  406404:	d017      	beq.n	406436 <_dtoa_r+0x6e>
  406406:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  40640a:	2200      	movs	r2, #0
  40640c:	4630      	mov	r0, r6
  40640e:	4639      	mov	r1, r7
  406410:	2300      	movs	r3, #0
  406412:	f002 fdf3 	bl	408ffc <__aeabi_dcmpeq>
  406416:	4680      	mov	r8, r0
  406418:	2800      	cmp	r0, #0
  40641a:	d02b      	beq.n	406474 <_dtoa_r+0xac>
  40641c:	9a22      	ldr	r2, [sp, #136]	; 0x88
  40641e:	2301      	movs	r3, #1
  406420:	6013      	str	r3, [r2, #0]
  406422:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406424:	2b00      	cmp	r3, #0
  406426:	f000 80cb 	beq.w	4065c0 <_dtoa_r+0x1f8>
  40642a:	489a      	ldr	r0, [pc, #616]	; (406694 <_dtoa_r+0x2cc>)
  40642c:	6018      	str	r0, [r3, #0]
  40642e:	3801      	subs	r0, #1
  406430:	b017      	add	sp, #92	; 0x5c
  406432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406436:	9a22      	ldr	r2, [sp, #136]	; 0x88
  406438:	f242 730f 	movw	r3, #9999	; 0x270f
  40643c:	6013      	str	r3, [r2, #0]
  40643e:	9b02      	ldr	r3, [sp, #8]
  406440:	2b00      	cmp	r3, #0
  406442:	f000 80a6 	beq.w	406592 <_dtoa_r+0x1ca>
  406446:	4894      	ldr	r0, [pc, #592]	; (406698 <_dtoa_r+0x2d0>)
  406448:	9b24      	ldr	r3, [sp, #144]	; 0x90
  40644a:	2b00      	cmp	r3, #0
  40644c:	d0f0      	beq.n	406430 <_dtoa_r+0x68>
  40644e:	78c3      	ldrb	r3, [r0, #3]
  406450:	2b00      	cmp	r3, #0
  406452:	f000 80b7 	beq.w	4065c4 <_dtoa_r+0x1fc>
  406456:	f100 0308 	add.w	r3, r0, #8
  40645a:	9a24      	ldr	r2, [sp, #144]	; 0x90
  40645c:	6013      	str	r3, [r2, #0]
  40645e:	b017      	add	sp, #92	; 0x5c
  406460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406464:	9a03      	ldr	r2, [sp, #12]
  406466:	2301      	movs	r3, #1
  406468:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
  40646c:	602b      	str	r3, [r5, #0]
  40646e:	f8cd 900c 	str.w	r9, [sp, #12]
  406472:	e7c2      	b.n	4063fa <_dtoa_r+0x32>
  406474:	aa15      	add	r2, sp, #84	; 0x54
  406476:	ab14      	add	r3, sp, #80	; 0x50
  406478:	e88d 000c 	stmia.w	sp, {r2, r3}
  40647c:	4620      	mov	r0, r4
  40647e:	4632      	mov	r2, r6
  406480:	463b      	mov	r3, r7
  406482:	f001 fe07 	bl	408094 <__d2b>
  406486:	ea5f 5519 	movs.w	r5, r9, lsr #20
  40648a:	4683      	mov	fp, r0
  40648c:	f040 808a 	bne.w	4065a4 <_dtoa_r+0x1dc>
  406490:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  406494:	9d15      	ldr	r5, [sp, #84]	; 0x54
  406496:	f46f 6382 	mvn.w	r3, #1040	; 0x410
  40649a:	4445      	add	r5, r8
  40649c:	429d      	cmp	r5, r3
  40649e:	f2c0 8297 	blt.w	4069d0 <_dtoa_r+0x608>
  4064a2:	4a7e      	ldr	r2, [pc, #504]	; (40669c <_dtoa_r+0x2d4>)
  4064a4:	1b52      	subs	r2, r2, r5
  4064a6:	fa09 f902 	lsl.w	r9, r9, r2
  4064aa:	9a02      	ldr	r2, [sp, #8]
  4064ac:	f205 4312 	addw	r3, r5, #1042	; 0x412
  4064b0:	fa22 f003 	lsr.w	r0, r2, r3
  4064b4:	ea49 0000 	orr.w	r0, r9, r0
  4064b8:	f002 fac2 	bl	408a40 <__aeabi_ui2d>
  4064bc:	2301      	movs	r3, #1
  4064be:	3d01      	subs	r5, #1
  4064c0:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  4064c4:	930d      	str	r3, [sp, #52]	; 0x34
  4064c6:	2200      	movs	r2, #0
  4064c8:	4b75      	ldr	r3, [pc, #468]	; (4066a0 <_dtoa_r+0x2d8>)
  4064ca:	f002 f97b 	bl	4087c4 <__aeabi_dsub>
  4064ce:	a36a      	add	r3, pc, #424	; (adr r3, 406678 <_dtoa_r+0x2b0>)
  4064d0:	e9d3 2300 	ldrd	r2, r3, [r3]
  4064d4:	f002 fb2a 	bl	408b2c <__aeabi_dmul>
  4064d8:	a369      	add	r3, pc, #420	; (adr r3, 406680 <_dtoa_r+0x2b8>)
  4064da:	e9d3 2300 	ldrd	r2, r3, [r3]
  4064de:	f002 f973 	bl	4087c8 <__adddf3>
  4064e2:	4606      	mov	r6, r0
  4064e4:	4628      	mov	r0, r5
  4064e6:	460f      	mov	r7, r1
  4064e8:	f002 faba 	bl	408a60 <__aeabi_i2d>
  4064ec:	a366      	add	r3, pc, #408	; (adr r3, 406688 <_dtoa_r+0x2c0>)
  4064ee:	e9d3 2300 	ldrd	r2, r3, [r3]
  4064f2:	f002 fb1b 	bl	408b2c <__aeabi_dmul>
  4064f6:	4602      	mov	r2, r0
  4064f8:	460b      	mov	r3, r1
  4064fa:	4630      	mov	r0, r6
  4064fc:	4639      	mov	r1, r7
  4064fe:	f002 f963 	bl	4087c8 <__adddf3>
  406502:	4606      	mov	r6, r0
  406504:	460f      	mov	r7, r1
  406506:	f002 fdab 	bl	409060 <__aeabi_d2iz>
  40650a:	4639      	mov	r1, r7
  40650c:	9004      	str	r0, [sp, #16]
  40650e:	2200      	movs	r2, #0
  406510:	4630      	mov	r0, r6
  406512:	2300      	movs	r3, #0
  406514:	f002 fd7c 	bl	409010 <__aeabi_dcmplt>
  406518:	2800      	cmp	r0, #0
  40651a:	f040 81a6 	bne.w	40686a <_dtoa_r+0x4a2>
  40651e:	9b04      	ldr	r3, [sp, #16]
  406520:	2b16      	cmp	r3, #22
  406522:	f200 819f 	bhi.w	406864 <_dtoa_r+0x49c>
  406526:	9a04      	ldr	r2, [sp, #16]
  406528:	4b5e      	ldr	r3, [pc, #376]	; (4066a4 <_dtoa_r+0x2dc>)
  40652a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  40652e:	e9d3 0100 	ldrd	r0, r1, [r3]
  406532:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406536:	f002 fd89 	bl	40904c <__aeabi_dcmpgt>
  40653a:	2800      	cmp	r0, #0
  40653c:	f000 824e 	beq.w	4069dc <_dtoa_r+0x614>
  406540:	9b04      	ldr	r3, [sp, #16]
  406542:	3b01      	subs	r3, #1
  406544:	9304      	str	r3, [sp, #16]
  406546:	2300      	movs	r3, #0
  406548:	930b      	str	r3, [sp, #44]	; 0x2c
  40654a:	ebc5 0508 	rsb	r5, r5, r8
  40654e:	f1b5 0a01 	subs.w	sl, r5, #1
  406552:	f100 81a1 	bmi.w	406898 <_dtoa_r+0x4d0>
  406556:	2300      	movs	r3, #0
  406558:	9305      	str	r3, [sp, #20]
  40655a:	9b04      	ldr	r3, [sp, #16]
  40655c:	2b00      	cmp	r3, #0
  40655e:	f2c0 8192 	blt.w	406886 <_dtoa_r+0x4be>
  406562:	449a      	add	sl, r3
  406564:	930a      	str	r3, [sp, #40]	; 0x28
  406566:	2300      	movs	r3, #0
  406568:	9308      	str	r3, [sp, #32]
  40656a:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40656c:	2b09      	cmp	r3, #9
  40656e:	d82b      	bhi.n	4065c8 <_dtoa_r+0x200>
  406570:	2b05      	cmp	r3, #5
  406572:	f340 8670 	ble.w	407256 <_dtoa_r+0xe8e>
  406576:	3b04      	subs	r3, #4
  406578:	9320      	str	r3, [sp, #128]	; 0x80
  40657a:	2500      	movs	r5, #0
  40657c:	9b20      	ldr	r3, [sp, #128]	; 0x80
  40657e:	3b02      	subs	r3, #2
  406580:	2b03      	cmp	r3, #3
  406582:	f200 864e 	bhi.w	407222 <_dtoa_r+0xe5a>
  406586:	e8df f013 	tbh	[pc, r3, lsl #1]
  40658a:	03cc      	.short	0x03cc
  40658c:	02b203be 	.word	0x02b203be
  406590:	0663      	.short	0x0663
  406592:	4b41      	ldr	r3, [pc, #260]	; (406698 <_dtoa_r+0x2d0>)
  406594:	4a44      	ldr	r2, [pc, #272]	; (4066a8 <_dtoa_r+0x2e0>)
  406596:	f3c9 0013 	ubfx	r0, r9, #0, #20
  40659a:	2800      	cmp	r0, #0
  40659c:	bf14      	ite	ne
  40659e:	4618      	movne	r0, r3
  4065a0:	4610      	moveq	r0, r2
  4065a2:	e751      	b.n	406448 <_dtoa_r+0x80>
  4065a4:	f3c7 0313 	ubfx	r3, r7, #0, #20
  4065a8:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  4065ac:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
  4065b0:	4630      	mov	r0, r6
  4065b2:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  4065b6:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  4065ba:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  4065be:	e782      	b.n	4064c6 <_dtoa_r+0xfe>
  4065c0:	483a      	ldr	r0, [pc, #232]	; (4066ac <_dtoa_r+0x2e4>)
  4065c2:	e735      	b.n	406430 <_dtoa_r+0x68>
  4065c4:	1cc3      	adds	r3, r0, #3
  4065c6:	e748      	b.n	40645a <_dtoa_r+0x92>
  4065c8:	2100      	movs	r1, #0
  4065ca:	6461      	str	r1, [r4, #68]	; 0x44
  4065cc:	4620      	mov	r0, r4
  4065ce:	9120      	str	r1, [sp, #128]	; 0x80
  4065d0:	f001 fac8 	bl	407b64 <_Balloc>
  4065d4:	f04f 33ff 	mov.w	r3, #4294967295
  4065d8:	9306      	str	r3, [sp, #24]
  4065da:	9a20      	ldr	r2, [sp, #128]	; 0x80
  4065dc:	930c      	str	r3, [sp, #48]	; 0x30
  4065de:	2301      	movs	r3, #1
  4065e0:	9007      	str	r0, [sp, #28]
  4065e2:	9221      	str	r2, [sp, #132]	; 0x84
  4065e4:	6420      	str	r0, [r4, #64]	; 0x40
  4065e6:	9309      	str	r3, [sp, #36]	; 0x24
  4065e8:	9b15      	ldr	r3, [sp, #84]	; 0x54
  4065ea:	2b00      	cmp	r3, #0
  4065ec:	f2c0 80d2 	blt.w	406794 <_dtoa_r+0x3cc>
  4065f0:	9a04      	ldr	r2, [sp, #16]
  4065f2:	2a0e      	cmp	r2, #14
  4065f4:	f300 80ce 	bgt.w	406794 <_dtoa_r+0x3cc>
  4065f8:	4b2a      	ldr	r3, [pc, #168]	; (4066a4 <_dtoa_r+0x2dc>)
  4065fa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  4065fe:	e9d3 8900 	ldrd	r8, r9, [r3]
  406602:	9b21      	ldr	r3, [sp, #132]	; 0x84
  406604:	2b00      	cmp	r3, #0
  406606:	f2c0 838f 	blt.w	406d28 <_dtoa_r+0x960>
  40660a:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  40660e:	4642      	mov	r2, r8
  406610:	464b      	mov	r3, r9
  406612:	4630      	mov	r0, r6
  406614:	4639      	mov	r1, r7
  406616:	f002 fbb3 	bl	408d80 <__aeabi_ddiv>
  40661a:	f002 fd21 	bl	409060 <__aeabi_d2iz>
  40661e:	4682      	mov	sl, r0
  406620:	f002 fa1e 	bl	408a60 <__aeabi_i2d>
  406624:	4642      	mov	r2, r8
  406626:	464b      	mov	r3, r9
  406628:	f002 fa80 	bl	408b2c <__aeabi_dmul>
  40662c:	460b      	mov	r3, r1
  40662e:	4602      	mov	r2, r0
  406630:	4639      	mov	r1, r7
  406632:	4630      	mov	r0, r6
  406634:	f002 f8c6 	bl	4087c4 <__aeabi_dsub>
  406638:	9d07      	ldr	r5, [sp, #28]
  40663a:	f10a 0330 	add.w	r3, sl, #48	; 0x30
  40663e:	702b      	strb	r3, [r5, #0]
  406640:	9b06      	ldr	r3, [sp, #24]
  406642:	2b01      	cmp	r3, #1
  406644:	4606      	mov	r6, r0
  406646:	460f      	mov	r7, r1
  406648:	f105 0501 	add.w	r5, r5, #1
  40664c:	d062      	beq.n	406714 <_dtoa_r+0x34c>
  40664e:	2200      	movs	r2, #0
  406650:	4b17      	ldr	r3, [pc, #92]	; (4066b0 <_dtoa_r+0x2e8>)
  406652:	f002 fa6b 	bl	408b2c <__aeabi_dmul>
  406656:	2200      	movs	r2, #0
  406658:	2300      	movs	r3, #0
  40665a:	4606      	mov	r6, r0
  40665c:	460f      	mov	r7, r1
  40665e:	f002 fccd 	bl	408ffc <__aeabi_dcmpeq>
  406662:	2800      	cmp	r0, #0
  406664:	f040 8083 	bne.w	40676e <_dtoa_r+0x3a6>
  406668:	f8cd b008 	str.w	fp, [sp, #8]
  40666c:	9405      	str	r4, [sp, #20]
  40666e:	f8dd b01c 	ldr.w	fp, [sp, #28]
  406672:	9c06      	ldr	r4, [sp, #24]
  406674:	e029      	b.n	4066ca <_dtoa_r+0x302>
  406676:	bf00      	nop
  406678:	636f4361 	.word	0x636f4361
  40667c:	3fd287a7 	.word	0x3fd287a7
  406680:	8b60c8b3 	.word	0x8b60c8b3
  406684:	3fc68a28 	.word	0x3fc68a28
  406688:	509f79fb 	.word	0x509f79fb
  40668c:	3fd34413 	.word	0x3fd34413
  406690:	7ff00000 	.word	0x7ff00000
  406694:	0040b145 	.word	0x0040b145
  406698:	0040b258 	.word	0x0040b258
  40669c:	fffffc0e 	.word	0xfffffc0e
  4066a0:	3ff80000 	.word	0x3ff80000
  4066a4:	0040b268 	.word	0x0040b268
  4066a8:	0040b24c 	.word	0x0040b24c
  4066ac:	0040b144 	.word	0x0040b144
  4066b0:	40240000 	.word	0x40240000
  4066b4:	f002 fa3a 	bl	408b2c <__aeabi_dmul>
  4066b8:	2200      	movs	r2, #0
  4066ba:	2300      	movs	r3, #0
  4066bc:	4606      	mov	r6, r0
  4066be:	460f      	mov	r7, r1
  4066c0:	f002 fc9c 	bl	408ffc <__aeabi_dcmpeq>
  4066c4:	2800      	cmp	r0, #0
  4066c6:	f040 83de 	bne.w	406e86 <_dtoa_r+0xabe>
  4066ca:	4642      	mov	r2, r8
  4066cc:	464b      	mov	r3, r9
  4066ce:	4630      	mov	r0, r6
  4066d0:	4639      	mov	r1, r7
  4066d2:	f002 fb55 	bl	408d80 <__aeabi_ddiv>
  4066d6:	f002 fcc3 	bl	409060 <__aeabi_d2iz>
  4066da:	4682      	mov	sl, r0
  4066dc:	f002 f9c0 	bl	408a60 <__aeabi_i2d>
  4066e0:	4642      	mov	r2, r8
  4066e2:	464b      	mov	r3, r9
  4066e4:	f002 fa22 	bl	408b2c <__aeabi_dmul>
  4066e8:	4602      	mov	r2, r0
  4066ea:	460b      	mov	r3, r1
  4066ec:	4630      	mov	r0, r6
  4066ee:	4639      	mov	r1, r7
  4066f0:	f002 f868 	bl	4087c4 <__aeabi_dsub>
  4066f4:	f10a 0e30 	add.w	lr, sl, #48	; 0x30
  4066f8:	f805 eb01 	strb.w	lr, [r5], #1
  4066fc:	ebcb 0e05 	rsb	lr, fp, r5
  406700:	4574      	cmp	r4, lr
  406702:	4606      	mov	r6, r0
  406704:	460f      	mov	r7, r1
  406706:	f04f 0200 	mov.w	r2, #0
  40670a:	4bb5      	ldr	r3, [pc, #724]	; (4069e0 <_dtoa_r+0x618>)
  40670c:	d1d2      	bne.n	4066b4 <_dtoa_r+0x2ec>
  40670e:	f8dd b008 	ldr.w	fp, [sp, #8]
  406712:	9c05      	ldr	r4, [sp, #20]
  406714:	4632      	mov	r2, r6
  406716:	463b      	mov	r3, r7
  406718:	4630      	mov	r0, r6
  40671a:	4639      	mov	r1, r7
  40671c:	f002 f854 	bl	4087c8 <__adddf3>
  406720:	4606      	mov	r6, r0
  406722:	460f      	mov	r7, r1
  406724:	4640      	mov	r0, r8
  406726:	4649      	mov	r1, r9
  406728:	4632      	mov	r2, r6
  40672a:	463b      	mov	r3, r7
  40672c:	f002 fc70 	bl	409010 <__aeabi_dcmplt>
  406730:	b948      	cbnz	r0, 406746 <_dtoa_r+0x37e>
  406732:	4640      	mov	r0, r8
  406734:	4649      	mov	r1, r9
  406736:	4632      	mov	r2, r6
  406738:	463b      	mov	r3, r7
  40673a:	f002 fc5f 	bl	408ffc <__aeabi_dcmpeq>
  40673e:	b1b0      	cbz	r0, 40676e <_dtoa_r+0x3a6>
  406740:	f01a 0f01 	tst.w	sl, #1
  406744:	d013      	beq.n	40676e <_dtoa_r+0x3a6>
  406746:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  40674a:	9907      	ldr	r1, [sp, #28]
  40674c:	1e6b      	subs	r3, r5, #1
  40674e:	e004      	b.n	40675a <_dtoa_r+0x392>
  406750:	428b      	cmp	r3, r1
  406752:	f000 8440 	beq.w	406fd6 <_dtoa_r+0xc0e>
  406756:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
  40675a:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
  40675e:	f103 0501 	add.w	r5, r3, #1
  406762:	461a      	mov	r2, r3
  406764:	d0f4      	beq.n	406750 <_dtoa_r+0x388>
  406766:	f108 0301 	add.w	r3, r8, #1
  40676a:	b2db      	uxtb	r3, r3
  40676c:	7013      	strb	r3, [r2, #0]
  40676e:	4620      	mov	r0, r4
  406770:	4659      	mov	r1, fp
  406772:	f001 fa1d 	bl	407bb0 <_Bfree>
  406776:	2200      	movs	r2, #0
  406778:	9b04      	ldr	r3, [sp, #16]
  40677a:	702a      	strb	r2, [r5, #0]
  40677c:	9a22      	ldr	r2, [sp, #136]	; 0x88
  40677e:	3301      	adds	r3, #1
  406780:	6013      	str	r3, [r2, #0]
  406782:	9b24      	ldr	r3, [sp, #144]	; 0x90
  406784:	2b00      	cmp	r3, #0
  406786:	f000 8345 	beq.w	406e14 <_dtoa_r+0xa4c>
  40678a:	9807      	ldr	r0, [sp, #28]
  40678c:	601d      	str	r5, [r3, #0]
  40678e:	b017      	add	sp, #92	; 0x5c
  406790:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406794:	9a09      	ldr	r2, [sp, #36]	; 0x24
  406796:	2a00      	cmp	r2, #0
  406798:	f000 8084 	beq.w	4068a4 <_dtoa_r+0x4dc>
  40679c:	9a20      	ldr	r2, [sp, #128]	; 0x80
  40679e:	2a01      	cmp	r2, #1
  4067a0:	f340 8304 	ble.w	406dac <_dtoa_r+0x9e4>
  4067a4:	9b06      	ldr	r3, [sp, #24]
  4067a6:	1e5f      	subs	r7, r3, #1
  4067a8:	9b08      	ldr	r3, [sp, #32]
  4067aa:	42bb      	cmp	r3, r7
  4067ac:	f2c0 83a9 	blt.w	406f02 <_dtoa_r+0xb3a>
  4067b0:	1bdf      	subs	r7, r3, r7
  4067b2:	9b06      	ldr	r3, [sp, #24]
  4067b4:	2b00      	cmp	r3, #0
  4067b6:	f2c0 849c 	blt.w	4070f2 <_dtoa_r+0xd2a>
  4067ba:	9d05      	ldr	r5, [sp, #20]
  4067bc:	9b06      	ldr	r3, [sp, #24]
  4067be:	9a05      	ldr	r2, [sp, #20]
  4067c0:	4620      	mov	r0, r4
  4067c2:	441a      	add	r2, r3
  4067c4:	2101      	movs	r1, #1
  4067c6:	9205      	str	r2, [sp, #20]
  4067c8:	449a      	add	sl, r3
  4067ca:	f001 fa8b 	bl	407ce4 <__i2b>
  4067ce:	4606      	mov	r6, r0
  4067d0:	b165      	cbz	r5, 4067ec <_dtoa_r+0x424>
  4067d2:	f1ba 0f00 	cmp.w	sl, #0
  4067d6:	dd09      	ble.n	4067ec <_dtoa_r+0x424>
  4067d8:	45aa      	cmp	sl, r5
  4067da:	9a05      	ldr	r2, [sp, #20]
  4067dc:	4653      	mov	r3, sl
  4067de:	bfa8      	it	ge
  4067e0:	462b      	movge	r3, r5
  4067e2:	1ad2      	subs	r2, r2, r3
  4067e4:	9205      	str	r2, [sp, #20]
  4067e6:	1aed      	subs	r5, r5, r3
  4067e8:	ebc3 0a0a 	rsb	sl, r3, sl
  4067ec:	9b08      	ldr	r3, [sp, #32]
  4067ee:	2b00      	cmp	r3, #0
  4067f0:	dd1a      	ble.n	406828 <_dtoa_r+0x460>
  4067f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4067f4:	2b00      	cmp	r3, #0
  4067f6:	f000 837d 	beq.w	406ef4 <_dtoa_r+0xb2c>
  4067fa:	2f00      	cmp	r7, #0
  4067fc:	dd10      	ble.n	406820 <_dtoa_r+0x458>
  4067fe:	4631      	mov	r1, r6
  406800:	463a      	mov	r2, r7
  406802:	4620      	mov	r0, r4
  406804:	f001 fb12 	bl	407e2c <__pow5mult>
  406808:	4606      	mov	r6, r0
  40680a:	465a      	mov	r2, fp
  40680c:	4631      	mov	r1, r6
  40680e:	4620      	mov	r0, r4
  406810:	f001 fa72 	bl	407cf8 <__multiply>
  406814:	4659      	mov	r1, fp
  406816:	4680      	mov	r8, r0
  406818:	4620      	mov	r0, r4
  40681a:	f001 f9c9 	bl	407bb0 <_Bfree>
  40681e:	46c3      	mov	fp, r8
  406820:	9b08      	ldr	r3, [sp, #32]
  406822:	1bda      	subs	r2, r3, r7
  406824:	f040 82a2 	bne.w	406d6c <_dtoa_r+0x9a4>
  406828:	4620      	mov	r0, r4
  40682a:	2101      	movs	r1, #1
  40682c:	f001 fa5a 	bl	407ce4 <__i2b>
  406830:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  406832:	2b00      	cmp	r3, #0
  406834:	4680      	mov	r8, r0
  406836:	dd39      	ble.n	4068ac <_dtoa_r+0x4e4>
  406838:	4601      	mov	r1, r0
  40683a:	461a      	mov	r2, r3
  40683c:	4620      	mov	r0, r4
  40683e:	f001 faf5 	bl	407e2c <__pow5mult>
  406842:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406844:	2b01      	cmp	r3, #1
  406846:	4680      	mov	r8, r0
  406848:	f340 8296 	ble.w	406d78 <_dtoa_r+0x9b0>
  40684c:	f04f 0900 	mov.w	r9, #0
  406850:	f8d8 3010 	ldr.w	r3, [r8, #16]
  406854:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  406858:	6918      	ldr	r0, [r3, #16]
  40685a:	f001 f9f5 	bl	407c48 <__hi0bits>
  40685e:	f1c0 0020 	rsb	r0, r0, #32
  406862:	e02d      	b.n	4068c0 <_dtoa_r+0x4f8>
  406864:	2301      	movs	r3, #1
  406866:	930b      	str	r3, [sp, #44]	; 0x2c
  406868:	e66f      	b.n	40654a <_dtoa_r+0x182>
  40686a:	9804      	ldr	r0, [sp, #16]
  40686c:	f002 f8f8 	bl	408a60 <__aeabi_i2d>
  406870:	4632      	mov	r2, r6
  406872:	463b      	mov	r3, r7
  406874:	f002 fbc2 	bl	408ffc <__aeabi_dcmpeq>
  406878:	2800      	cmp	r0, #0
  40687a:	f47f ae50 	bne.w	40651e <_dtoa_r+0x156>
  40687e:	9b04      	ldr	r3, [sp, #16]
  406880:	3b01      	subs	r3, #1
  406882:	9304      	str	r3, [sp, #16]
  406884:	e64b      	b.n	40651e <_dtoa_r+0x156>
  406886:	9a05      	ldr	r2, [sp, #20]
  406888:	9b04      	ldr	r3, [sp, #16]
  40688a:	1ad2      	subs	r2, r2, r3
  40688c:	425b      	negs	r3, r3
  40688e:	9308      	str	r3, [sp, #32]
  406890:	2300      	movs	r3, #0
  406892:	9205      	str	r2, [sp, #20]
  406894:	930a      	str	r3, [sp, #40]	; 0x28
  406896:	e668      	b.n	40656a <_dtoa_r+0x1a2>
  406898:	f1ca 0300 	rsb	r3, sl, #0
  40689c:	9305      	str	r3, [sp, #20]
  40689e:	f04f 0a00 	mov.w	sl, #0
  4068a2:	e65a      	b.n	40655a <_dtoa_r+0x192>
  4068a4:	9f08      	ldr	r7, [sp, #32]
  4068a6:	9d05      	ldr	r5, [sp, #20]
  4068a8:	9e09      	ldr	r6, [sp, #36]	; 0x24
  4068aa:	e791      	b.n	4067d0 <_dtoa_r+0x408>
  4068ac:	9b20      	ldr	r3, [sp, #128]	; 0x80
  4068ae:	2b01      	cmp	r3, #1
  4068b0:	f340 82b3 	ble.w	406e1a <_dtoa_r+0xa52>
  4068b4:	f04f 0900 	mov.w	r9, #0
  4068b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4068ba:	2b00      	cmp	r3, #0
  4068bc:	d1c8      	bne.n	406850 <_dtoa_r+0x488>
  4068be:	2001      	movs	r0, #1
  4068c0:	4450      	add	r0, sl
  4068c2:	f010 001f 	ands.w	r0, r0, #31
  4068c6:	f000 8081 	beq.w	4069cc <_dtoa_r+0x604>
  4068ca:	f1c0 0320 	rsb	r3, r0, #32
  4068ce:	2b04      	cmp	r3, #4
  4068d0:	f340 84b8 	ble.w	407244 <_dtoa_r+0xe7c>
  4068d4:	f1c0 001c 	rsb	r0, r0, #28
  4068d8:	9b05      	ldr	r3, [sp, #20]
  4068da:	4403      	add	r3, r0
  4068dc:	9305      	str	r3, [sp, #20]
  4068de:	4405      	add	r5, r0
  4068e0:	4482      	add	sl, r0
  4068e2:	9b05      	ldr	r3, [sp, #20]
  4068e4:	2b00      	cmp	r3, #0
  4068e6:	dd05      	ble.n	4068f4 <_dtoa_r+0x52c>
  4068e8:	4659      	mov	r1, fp
  4068ea:	461a      	mov	r2, r3
  4068ec:	4620      	mov	r0, r4
  4068ee:	f001 faed 	bl	407ecc <__lshift>
  4068f2:	4683      	mov	fp, r0
  4068f4:	f1ba 0f00 	cmp.w	sl, #0
  4068f8:	dd05      	ble.n	406906 <_dtoa_r+0x53e>
  4068fa:	4641      	mov	r1, r8
  4068fc:	4652      	mov	r2, sl
  4068fe:	4620      	mov	r0, r4
  406900:	f001 fae4 	bl	407ecc <__lshift>
  406904:	4680      	mov	r8, r0
  406906:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  406908:	2b00      	cmp	r3, #0
  40690a:	f040 8268 	bne.w	406dde <_dtoa_r+0xa16>
  40690e:	9b06      	ldr	r3, [sp, #24]
  406910:	2b00      	cmp	r3, #0
  406912:	f340 8295 	ble.w	406e40 <_dtoa_r+0xa78>
  406916:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406918:	2b00      	cmp	r3, #0
  40691a:	d171      	bne.n	406a00 <_dtoa_r+0x638>
  40691c:	f8dd 901c 	ldr.w	r9, [sp, #28]
  406920:	9f06      	ldr	r7, [sp, #24]
  406922:	464d      	mov	r5, r9
  406924:	e002      	b.n	40692c <_dtoa_r+0x564>
  406926:	f001 f94d 	bl	407bc4 <__multadd>
  40692a:	4683      	mov	fp, r0
  40692c:	4641      	mov	r1, r8
  40692e:	4658      	mov	r0, fp
  406930:	f7ff fcb2 	bl	406298 <quorem>
  406934:	f100 0c30 	add.w	ip, r0, #48	; 0x30
  406938:	f805 cb01 	strb.w	ip, [r5], #1
  40693c:	ebc9 0305 	rsb	r3, r9, r5
  406940:	42bb      	cmp	r3, r7
  406942:	4620      	mov	r0, r4
  406944:	4659      	mov	r1, fp
  406946:	f04f 020a 	mov.w	r2, #10
  40694a:	f04f 0300 	mov.w	r3, #0
  40694e:	dbea      	blt.n	406926 <_dtoa_r+0x55e>
  406950:	9b07      	ldr	r3, [sp, #28]
  406952:	9a06      	ldr	r2, [sp, #24]
  406954:	2a01      	cmp	r2, #1
  406956:	bfac      	ite	ge
  406958:	189b      	addge	r3, r3, r2
  40695a:	3301      	addlt	r3, #1
  40695c:	461d      	mov	r5, r3
  40695e:	f04f 0a00 	mov.w	sl, #0
  406962:	4659      	mov	r1, fp
  406964:	2201      	movs	r2, #1
  406966:	4620      	mov	r0, r4
  406968:	f8cd c008 	str.w	ip, [sp, #8]
  40696c:	f001 faae 	bl	407ecc <__lshift>
  406970:	4641      	mov	r1, r8
  406972:	4683      	mov	fp, r0
  406974:	f001 fb00 	bl	407f78 <__mcmp>
  406978:	2800      	cmp	r0, #0
  40697a:	f8dd c008 	ldr.w	ip, [sp, #8]
  40697e:	f340 82f6 	ble.w	406f6e <_dtoa_r+0xba6>
  406982:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  406986:	9907      	ldr	r1, [sp, #28]
  406988:	1e6b      	subs	r3, r5, #1
  40698a:	e004      	b.n	406996 <_dtoa_r+0x5ce>
  40698c:	428b      	cmp	r3, r1
  40698e:	f000 8273 	beq.w	406e78 <_dtoa_r+0xab0>
  406992:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  406996:	2a39      	cmp	r2, #57	; 0x39
  406998:	f103 0501 	add.w	r5, r3, #1
  40699c:	d0f6      	beq.n	40698c <_dtoa_r+0x5c4>
  40699e:	3201      	adds	r2, #1
  4069a0:	701a      	strb	r2, [r3, #0]
  4069a2:	4641      	mov	r1, r8
  4069a4:	4620      	mov	r0, r4
  4069a6:	f001 f903 	bl	407bb0 <_Bfree>
  4069aa:	2e00      	cmp	r6, #0
  4069ac:	f43f aedf 	beq.w	40676e <_dtoa_r+0x3a6>
  4069b0:	f1ba 0f00 	cmp.w	sl, #0
  4069b4:	d005      	beq.n	4069c2 <_dtoa_r+0x5fa>
  4069b6:	45b2      	cmp	sl, r6
  4069b8:	d003      	beq.n	4069c2 <_dtoa_r+0x5fa>
  4069ba:	4651      	mov	r1, sl
  4069bc:	4620      	mov	r0, r4
  4069be:	f001 f8f7 	bl	407bb0 <_Bfree>
  4069c2:	4631      	mov	r1, r6
  4069c4:	4620      	mov	r0, r4
  4069c6:	f001 f8f3 	bl	407bb0 <_Bfree>
  4069ca:	e6d0      	b.n	40676e <_dtoa_r+0x3a6>
  4069cc:	201c      	movs	r0, #28
  4069ce:	e783      	b.n	4068d8 <_dtoa_r+0x510>
  4069d0:	4b04      	ldr	r3, [pc, #16]	; (4069e4 <_dtoa_r+0x61c>)
  4069d2:	9a02      	ldr	r2, [sp, #8]
  4069d4:	1b5b      	subs	r3, r3, r5
  4069d6:	fa02 f003 	lsl.w	r0, r2, r3
  4069da:	e56d      	b.n	4064b8 <_dtoa_r+0xf0>
  4069dc:	900b      	str	r0, [sp, #44]	; 0x2c
  4069de:	e5b4      	b.n	40654a <_dtoa_r+0x182>
  4069e0:	40240000 	.word	0x40240000
  4069e4:	fffffbee 	.word	0xfffffbee
  4069e8:	4631      	mov	r1, r6
  4069ea:	2300      	movs	r3, #0
  4069ec:	4620      	mov	r0, r4
  4069ee:	220a      	movs	r2, #10
  4069f0:	f001 f8e8 	bl	407bc4 <__multadd>
  4069f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4069f6:	2b00      	cmp	r3, #0
  4069f8:	4606      	mov	r6, r0
  4069fa:	f340 840c 	ble.w	407216 <_dtoa_r+0xe4e>
  4069fe:	9306      	str	r3, [sp, #24]
  406a00:	2d00      	cmp	r5, #0
  406a02:	dd05      	ble.n	406a10 <_dtoa_r+0x648>
  406a04:	4631      	mov	r1, r6
  406a06:	462a      	mov	r2, r5
  406a08:	4620      	mov	r0, r4
  406a0a:	f001 fa5f 	bl	407ecc <__lshift>
  406a0e:	4606      	mov	r6, r0
  406a10:	f1b9 0f00 	cmp.w	r9, #0
  406a14:	f040 82e9 	bne.w	406fea <_dtoa_r+0xc22>
  406a18:	46b1      	mov	r9, r6
  406a1a:	9b06      	ldr	r3, [sp, #24]
  406a1c:	9a07      	ldr	r2, [sp, #28]
  406a1e:	3b01      	subs	r3, #1
  406a20:	18d3      	adds	r3, r2, r3
  406a22:	9308      	str	r3, [sp, #32]
  406a24:	9b02      	ldr	r3, [sp, #8]
  406a26:	f003 0301 	and.w	r3, r3, #1
  406a2a:	9309      	str	r3, [sp, #36]	; 0x24
  406a2c:	4617      	mov	r7, r2
  406a2e:	4641      	mov	r1, r8
  406a30:	4658      	mov	r0, fp
  406a32:	f7ff fc31 	bl	406298 <quorem>
  406a36:	4631      	mov	r1, r6
  406a38:	4605      	mov	r5, r0
  406a3a:	4658      	mov	r0, fp
  406a3c:	f001 fa9c 	bl	407f78 <__mcmp>
  406a40:	464a      	mov	r2, r9
  406a42:	4682      	mov	sl, r0
  406a44:	4641      	mov	r1, r8
  406a46:	4620      	mov	r0, r4
  406a48:	f001 faba 	bl	407fc0 <__mdiff>
  406a4c:	68c2      	ldr	r2, [r0, #12]
  406a4e:	4603      	mov	r3, r0
  406a50:	f105 0c30 	add.w	ip, r5, #48	; 0x30
  406a54:	2a00      	cmp	r2, #0
  406a56:	f040 81b8 	bne.w	406dca <_dtoa_r+0xa02>
  406a5a:	4619      	mov	r1, r3
  406a5c:	4658      	mov	r0, fp
  406a5e:	f8cd c018 	str.w	ip, [sp, #24]
  406a62:	9305      	str	r3, [sp, #20]
  406a64:	f001 fa88 	bl	407f78 <__mcmp>
  406a68:	9b05      	ldr	r3, [sp, #20]
  406a6a:	9002      	str	r0, [sp, #8]
  406a6c:	4619      	mov	r1, r3
  406a6e:	4620      	mov	r0, r4
  406a70:	f001 f89e 	bl	407bb0 <_Bfree>
  406a74:	9a02      	ldr	r2, [sp, #8]
  406a76:	f8dd c018 	ldr.w	ip, [sp, #24]
  406a7a:	b92a      	cbnz	r2, 406a88 <_dtoa_r+0x6c0>
  406a7c:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406a7e:	b91b      	cbnz	r3, 406a88 <_dtoa_r+0x6c0>
  406a80:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406a82:	2b00      	cmp	r3, #0
  406a84:	f000 83a7 	beq.w	4071d6 <_dtoa_r+0xe0e>
  406a88:	f1ba 0f00 	cmp.w	sl, #0
  406a8c:	f2c0 8251 	blt.w	406f32 <_dtoa_r+0xb6a>
  406a90:	d105      	bne.n	406a9e <_dtoa_r+0x6d6>
  406a92:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406a94:	b91b      	cbnz	r3, 406a9e <_dtoa_r+0x6d6>
  406a96:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406a98:	2b00      	cmp	r3, #0
  406a9a:	f000 824a 	beq.w	406f32 <_dtoa_r+0xb6a>
  406a9e:	2a00      	cmp	r2, #0
  406aa0:	f300 82b7 	bgt.w	407012 <_dtoa_r+0xc4a>
  406aa4:	9b08      	ldr	r3, [sp, #32]
  406aa6:	f887 c000 	strb.w	ip, [r7]
  406aaa:	f107 0a01 	add.w	sl, r7, #1
  406aae:	429f      	cmp	r7, r3
  406ab0:	4655      	mov	r5, sl
  406ab2:	f000 82ba 	beq.w	40702a <_dtoa_r+0xc62>
  406ab6:	4659      	mov	r1, fp
  406ab8:	220a      	movs	r2, #10
  406aba:	2300      	movs	r3, #0
  406abc:	4620      	mov	r0, r4
  406abe:	f001 f881 	bl	407bc4 <__multadd>
  406ac2:	454e      	cmp	r6, r9
  406ac4:	4683      	mov	fp, r0
  406ac6:	4631      	mov	r1, r6
  406ac8:	4620      	mov	r0, r4
  406aca:	f04f 020a 	mov.w	r2, #10
  406ace:	f04f 0300 	mov.w	r3, #0
  406ad2:	f000 8174 	beq.w	406dbe <_dtoa_r+0x9f6>
  406ad6:	f001 f875 	bl	407bc4 <__multadd>
  406ada:	4649      	mov	r1, r9
  406adc:	4606      	mov	r6, r0
  406ade:	220a      	movs	r2, #10
  406ae0:	4620      	mov	r0, r4
  406ae2:	2300      	movs	r3, #0
  406ae4:	f001 f86e 	bl	407bc4 <__multadd>
  406ae8:	4657      	mov	r7, sl
  406aea:	4681      	mov	r9, r0
  406aec:	e79f      	b.n	406a2e <_dtoa_r+0x666>
  406aee:	2301      	movs	r3, #1
  406af0:	9309      	str	r3, [sp, #36]	; 0x24
  406af2:	9b21      	ldr	r3, [sp, #132]	; 0x84
  406af4:	2b00      	cmp	r3, #0
  406af6:	f340 8213 	ble.w	406f20 <_dtoa_r+0xb58>
  406afa:	461f      	mov	r7, r3
  406afc:	461e      	mov	r6, r3
  406afe:	930c      	str	r3, [sp, #48]	; 0x30
  406b00:	9306      	str	r3, [sp, #24]
  406b02:	2100      	movs	r1, #0
  406b04:	2f17      	cmp	r7, #23
  406b06:	6461      	str	r1, [r4, #68]	; 0x44
  406b08:	d90a      	bls.n	406b20 <_dtoa_r+0x758>
  406b0a:	2201      	movs	r2, #1
  406b0c:	2304      	movs	r3, #4
  406b0e:	005b      	lsls	r3, r3, #1
  406b10:	f103 0014 	add.w	r0, r3, #20
  406b14:	4287      	cmp	r7, r0
  406b16:	4611      	mov	r1, r2
  406b18:	f102 0201 	add.w	r2, r2, #1
  406b1c:	d2f7      	bcs.n	406b0e <_dtoa_r+0x746>
  406b1e:	6461      	str	r1, [r4, #68]	; 0x44
  406b20:	4620      	mov	r0, r4
  406b22:	f001 f81f 	bl	407b64 <_Balloc>
  406b26:	2e0e      	cmp	r6, #14
  406b28:	9007      	str	r0, [sp, #28]
  406b2a:	6420      	str	r0, [r4, #64]	; 0x40
  406b2c:	f63f ad5c 	bhi.w	4065e8 <_dtoa_r+0x220>
  406b30:	2d00      	cmp	r5, #0
  406b32:	f43f ad59 	beq.w	4065e8 <_dtoa_r+0x220>
  406b36:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406b3a:	9904      	ldr	r1, [sp, #16]
  406b3c:	2900      	cmp	r1, #0
  406b3e:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  406b42:	f340 8221 	ble.w	406f88 <_dtoa_r+0xbc0>
  406b46:	4bb7      	ldr	r3, [pc, #732]	; (406e24 <_dtoa_r+0xa5c>)
  406b48:	f001 020f 	and.w	r2, r1, #15
  406b4c:	110d      	asrs	r5, r1, #4
  406b4e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  406b52:	06e9      	lsls	r1, r5, #27
  406b54:	e9d3 6700 	ldrd	r6, r7, [r3]
  406b58:	f140 81db 	bpl.w	406f12 <_dtoa_r+0xb4a>
  406b5c:	4bb2      	ldr	r3, [pc, #712]	; (406e28 <_dtoa_r+0xa60>)
  406b5e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  406b62:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  406b66:	f002 f90b 	bl	408d80 <__aeabi_ddiv>
  406b6a:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406b6e:	f005 050f 	and.w	r5, r5, #15
  406b72:	f04f 0803 	mov.w	r8, #3
  406b76:	b18d      	cbz	r5, 406b9c <_dtoa_r+0x7d4>
  406b78:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 406e28 <_dtoa_r+0xa60>
  406b7c:	4630      	mov	r0, r6
  406b7e:	4639      	mov	r1, r7
  406b80:	07ea      	lsls	r2, r5, #31
  406b82:	d505      	bpl.n	406b90 <_dtoa_r+0x7c8>
  406b84:	e9d9 2300 	ldrd	r2, r3, [r9]
  406b88:	f108 0801 	add.w	r8, r8, #1
  406b8c:	f001 ffce 	bl	408b2c <__aeabi_dmul>
  406b90:	106d      	asrs	r5, r5, #1
  406b92:	f109 0908 	add.w	r9, r9, #8
  406b96:	d1f3      	bne.n	406b80 <_dtoa_r+0x7b8>
  406b98:	4606      	mov	r6, r0
  406b9a:	460f      	mov	r7, r1
  406b9c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406ba0:	4632      	mov	r2, r6
  406ba2:	463b      	mov	r3, r7
  406ba4:	f002 f8ec 	bl	408d80 <__aeabi_ddiv>
  406ba8:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406bac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  406bae:	b143      	cbz	r3, 406bc2 <_dtoa_r+0x7fa>
  406bb0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406bb4:	2200      	movs	r2, #0
  406bb6:	4b9d      	ldr	r3, [pc, #628]	; (406e2c <_dtoa_r+0xa64>)
  406bb8:	f002 fa2a 	bl	409010 <__aeabi_dcmplt>
  406bbc:	2800      	cmp	r0, #0
  406bbe:	f040 82ac 	bne.w	40711a <_dtoa_r+0xd52>
  406bc2:	4640      	mov	r0, r8
  406bc4:	f001 ff4c 	bl	408a60 <__aeabi_i2d>
  406bc8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406bcc:	f001 ffae 	bl	408b2c <__aeabi_dmul>
  406bd0:	4b97      	ldr	r3, [pc, #604]	; (406e30 <_dtoa_r+0xa68>)
  406bd2:	2200      	movs	r2, #0
  406bd4:	f001 fdf8 	bl	4087c8 <__adddf3>
  406bd8:	9b06      	ldr	r3, [sp, #24]
  406bda:	4606      	mov	r6, r0
  406bdc:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  406be0:	2b00      	cmp	r3, #0
  406be2:	f000 8162 	beq.w	406eaa <_dtoa_r+0xae2>
  406be6:	9b04      	ldr	r3, [sp, #16]
  406be8:	f8dd 9018 	ldr.w	r9, [sp, #24]
  406bec:	9312      	str	r3, [sp, #72]	; 0x48
  406bee:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406bf0:	2b00      	cmp	r3, #0
  406bf2:	f000 8221 	beq.w	407038 <_dtoa_r+0xc70>
  406bf6:	4b8b      	ldr	r3, [pc, #556]	; (406e24 <_dtoa_r+0xa5c>)
  406bf8:	498e      	ldr	r1, [pc, #568]	; (406e34 <_dtoa_r+0xa6c>)
  406bfa:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
  406bfe:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  406c02:	2000      	movs	r0, #0
  406c04:	f002 f8bc 	bl	408d80 <__aeabi_ddiv>
  406c08:	4632      	mov	r2, r6
  406c0a:	463b      	mov	r3, r7
  406c0c:	f001 fdda 	bl	4087c4 <__aeabi_dsub>
  406c10:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  406c14:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  406c18:	4639      	mov	r1, r7
  406c1a:	4630      	mov	r0, r6
  406c1c:	f002 fa20 	bl	409060 <__aeabi_d2iz>
  406c20:	4605      	mov	r5, r0
  406c22:	f001 ff1d 	bl	408a60 <__aeabi_i2d>
  406c26:	3530      	adds	r5, #48	; 0x30
  406c28:	4602      	mov	r2, r0
  406c2a:	460b      	mov	r3, r1
  406c2c:	4630      	mov	r0, r6
  406c2e:	4639      	mov	r1, r7
  406c30:	f001 fdc8 	bl	4087c4 <__aeabi_dsub>
  406c34:	fa5f f885 	uxtb.w	r8, r5
  406c38:	9d07      	ldr	r5, [sp, #28]
  406c3a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
  406c3e:	f885 8000 	strb.w	r8, [r5]
  406c42:	4606      	mov	r6, r0
  406c44:	460f      	mov	r7, r1
  406c46:	3501      	adds	r5, #1
  406c48:	f002 f9e2 	bl	409010 <__aeabi_dcmplt>
  406c4c:	2800      	cmp	r0, #0
  406c4e:	f040 82b2 	bne.w	4071b6 <_dtoa_r+0xdee>
  406c52:	4632      	mov	r2, r6
  406c54:	463b      	mov	r3, r7
  406c56:	2000      	movs	r0, #0
  406c58:	4974      	ldr	r1, [pc, #464]	; (406e2c <_dtoa_r+0xa64>)
  406c5a:	f001 fdb3 	bl	4087c4 <__aeabi_dsub>
  406c5e:	4602      	mov	r2, r0
  406c60:	460b      	mov	r3, r1
  406c62:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  406c66:	f002 f9f1 	bl	40904c <__aeabi_dcmpgt>
  406c6a:	2800      	cmp	r0, #0
  406c6c:	f040 82ac 	bne.w	4071c8 <_dtoa_r+0xe00>
  406c70:	f1b9 0f01 	cmp.w	r9, #1
  406c74:	f340 8138 	ble.w	406ee8 <_dtoa_r+0xb20>
  406c78:	9b07      	ldr	r3, [sp, #28]
  406c7a:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  406c7e:	f8cd b008 	str.w	fp, [sp, #8]
  406c82:	4499      	add	r9, r3
  406c84:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
  406c88:	46a0      	mov	r8, r4
  406c8a:	e00d      	b.n	406ca8 <_dtoa_r+0x8e0>
  406c8c:	2000      	movs	r0, #0
  406c8e:	4967      	ldr	r1, [pc, #412]	; (406e2c <_dtoa_r+0xa64>)
  406c90:	f001 fd98 	bl	4087c4 <__aeabi_dsub>
  406c94:	4652      	mov	r2, sl
  406c96:	465b      	mov	r3, fp
  406c98:	f002 f9ba 	bl	409010 <__aeabi_dcmplt>
  406c9c:	2800      	cmp	r0, #0
  406c9e:	f040 828e 	bne.w	4071be <_dtoa_r+0xdf6>
  406ca2:	454d      	cmp	r5, r9
  406ca4:	f000 811b 	beq.w	406ede <_dtoa_r+0xb16>
  406ca8:	4650      	mov	r0, sl
  406caa:	4659      	mov	r1, fp
  406cac:	2200      	movs	r2, #0
  406cae:	4b62      	ldr	r3, [pc, #392]	; (406e38 <_dtoa_r+0xa70>)
  406cb0:	f001 ff3c 	bl	408b2c <__aeabi_dmul>
  406cb4:	2200      	movs	r2, #0
  406cb6:	4b60      	ldr	r3, [pc, #384]	; (406e38 <_dtoa_r+0xa70>)
  406cb8:	4682      	mov	sl, r0
  406cba:	468b      	mov	fp, r1
  406cbc:	4630      	mov	r0, r6
  406cbe:	4639      	mov	r1, r7
  406cc0:	f001 ff34 	bl	408b2c <__aeabi_dmul>
  406cc4:	460f      	mov	r7, r1
  406cc6:	4606      	mov	r6, r0
  406cc8:	f002 f9ca 	bl	409060 <__aeabi_d2iz>
  406ccc:	4604      	mov	r4, r0
  406cce:	f001 fec7 	bl	408a60 <__aeabi_i2d>
  406cd2:	4602      	mov	r2, r0
  406cd4:	460b      	mov	r3, r1
  406cd6:	4630      	mov	r0, r6
  406cd8:	4639      	mov	r1, r7
  406cda:	f001 fd73 	bl	4087c4 <__aeabi_dsub>
  406cde:	3430      	adds	r4, #48	; 0x30
  406ce0:	b2e4      	uxtb	r4, r4
  406ce2:	4652      	mov	r2, sl
  406ce4:	465b      	mov	r3, fp
  406ce6:	f805 4b01 	strb.w	r4, [r5], #1
  406cea:	4606      	mov	r6, r0
  406cec:	460f      	mov	r7, r1
  406cee:	f002 f98f 	bl	409010 <__aeabi_dcmplt>
  406cf2:	4632      	mov	r2, r6
  406cf4:	463b      	mov	r3, r7
  406cf6:	2800      	cmp	r0, #0
  406cf8:	d0c8      	beq.n	406c8c <_dtoa_r+0x8c4>
  406cfa:	9b12      	ldr	r3, [sp, #72]	; 0x48
  406cfc:	f8dd b008 	ldr.w	fp, [sp, #8]
  406d00:	9304      	str	r3, [sp, #16]
  406d02:	4644      	mov	r4, r8
  406d04:	e533      	b.n	40676e <_dtoa_r+0x3a6>
  406d06:	2300      	movs	r3, #0
  406d08:	9309      	str	r3, [sp, #36]	; 0x24
  406d0a:	9b21      	ldr	r3, [sp, #132]	; 0x84
  406d0c:	9a04      	ldr	r2, [sp, #16]
  406d0e:	4413      	add	r3, r2
  406d10:	930c      	str	r3, [sp, #48]	; 0x30
  406d12:	3301      	adds	r3, #1
  406d14:	2b00      	cmp	r3, #0
  406d16:	9306      	str	r3, [sp, #24]
  406d18:	f340 8109 	ble.w	406f2e <_dtoa_r+0xb66>
  406d1c:	9e06      	ldr	r6, [sp, #24]
  406d1e:	4637      	mov	r7, r6
  406d20:	e6ef      	b.n	406b02 <_dtoa_r+0x73a>
  406d22:	2300      	movs	r3, #0
  406d24:	9309      	str	r3, [sp, #36]	; 0x24
  406d26:	e6e4      	b.n	406af2 <_dtoa_r+0x72a>
  406d28:	9b06      	ldr	r3, [sp, #24]
  406d2a:	2b00      	cmp	r3, #0
  406d2c:	f73f ac6d 	bgt.w	40660a <_dtoa_r+0x242>
  406d30:	f040 8262 	bne.w	4071f8 <_dtoa_r+0xe30>
  406d34:	4640      	mov	r0, r8
  406d36:	2200      	movs	r2, #0
  406d38:	4b40      	ldr	r3, [pc, #256]	; (406e3c <_dtoa_r+0xa74>)
  406d3a:	4649      	mov	r1, r9
  406d3c:	f001 fef6 	bl	408b2c <__aeabi_dmul>
  406d40:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406d44:	f002 f978 	bl	409038 <__aeabi_dcmpge>
  406d48:	f8dd 8018 	ldr.w	r8, [sp, #24]
  406d4c:	4646      	mov	r6, r8
  406d4e:	2800      	cmp	r0, #0
  406d50:	f000 808a 	beq.w	406e68 <_dtoa_r+0xaa0>
  406d54:	9b21      	ldr	r3, [sp, #132]	; 0x84
  406d56:	9d07      	ldr	r5, [sp, #28]
  406d58:	43db      	mvns	r3, r3
  406d5a:	9304      	str	r3, [sp, #16]
  406d5c:	4641      	mov	r1, r8
  406d5e:	4620      	mov	r0, r4
  406d60:	f000 ff26 	bl	407bb0 <_Bfree>
  406d64:	2e00      	cmp	r6, #0
  406d66:	f47f ae2c 	bne.w	4069c2 <_dtoa_r+0x5fa>
  406d6a:	e500      	b.n	40676e <_dtoa_r+0x3a6>
  406d6c:	4659      	mov	r1, fp
  406d6e:	4620      	mov	r0, r4
  406d70:	f001 f85c 	bl	407e2c <__pow5mult>
  406d74:	4683      	mov	fp, r0
  406d76:	e557      	b.n	406828 <_dtoa_r+0x460>
  406d78:	9b02      	ldr	r3, [sp, #8]
  406d7a:	2b00      	cmp	r3, #0
  406d7c:	f47f ad66 	bne.w	40684c <_dtoa_r+0x484>
  406d80:	9b03      	ldr	r3, [sp, #12]
  406d82:	f3c3 0313 	ubfx	r3, r3, #0, #20
  406d86:	2b00      	cmp	r3, #0
  406d88:	f47f ad94 	bne.w	4068b4 <_dtoa_r+0x4ec>
  406d8c:	9b03      	ldr	r3, [sp, #12]
  406d8e:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
  406d92:	0d3f      	lsrs	r7, r7, #20
  406d94:	053f      	lsls	r7, r7, #20
  406d96:	2f00      	cmp	r7, #0
  406d98:	f000 821a 	beq.w	4071d0 <_dtoa_r+0xe08>
  406d9c:	9b05      	ldr	r3, [sp, #20]
  406d9e:	3301      	adds	r3, #1
  406da0:	9305      	str	r3, [sp, #20]
  406da2:	f10a 0a01 	add.w	sl, sl, #1
  406da6:	f04f 0901 	mov.w	r9, #1
  406daa:	e585      	b.n	4068b8 <_dtoa_r+0x4f0>
  406dac:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  406dae:	2a00      	cmp	r2, #0
  406db0:	f000 81a5 	beq.w	4070fe <_dtoa_r+0xd36>
  406db4:	f203 4333 	addw	r3, r3, #1075	; 0x433
  406db8:	9f08      	ldr	r7, [sp, #32]
  406dba:	9d05      	ldr	r5, [sp, #20]
  406dbc:	e4ff      	b.n	4067be <_dtoa_r+0x3f6>
  406dbe:	f000 ff01 	bl	407bc4 <__multadd>
  406dc2:	4657      	mov	r7, sl
  406dc4:	4606      	mov	r6, r0
  406dc6:	4681      	mov	r9, r0
  406dc8:	e631      	b.n	406a2e <_dtoa_r+0x666>
  406dca:	4601      	mov	r1, r0
  406dcc:	4620      	mov	r0, r4
  406dce:	f8cd c008 	str.w	ip, [sp, #8]
  406dd2:	f000 feed 	bl	407bb0 <_Bfree>
  406dd6:	2201      	movs	r2, #1
  406dd8:	f8dd c008 	ldr.w	ip, [sp, #8]
  406ddc:	e654      	b.n	406a88 <_dtoa_r+0x6c0>
  406dde:	4658      	mov	r0, fp
  406de0:	4641      	mov	r1, r8
  406de2:	f001 f8c9 	bl	407f78 <__mcmp>
  406de6:	2800      	cmp	r0, #0
  406de8:	f6bf ad91 	bge.w	40690e <_dtoa_r+0x546>
  406dec:	9f04      	ldr	r7, [sp, #16]
  406dee:	4659      	mov	r1, fp
  406df0:	2300      	movs	r3, #0
  406df2:	4620      	mov	r0, r4
  406df4:	220a      	movs	r2, #10
  406df6:	3f01      	subs	r7, #1
  406df8:	9704      	str	r7, [sp, #16]
  406dfa:	f000 fee3 	bl	407bc4 <__multadd>
  406dfe:	9b09      	ldr	r3, [sp, #36]	; 0x24
  406e00:	4683      	mov	fp, r0
  406e02:	2b00      	cmp	r3, #0
  406e04:	f47f adf0 	bne.w	4069e8 <_dtoa_r+0x620>
  406e08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  406e0a:	2b00      	cmp	r3, #0
  406e0c:	f340 81f8 	ble.w	407200 <_dtoa_r+0xe38>
  406e10:	9306      	str	r3, [sp, #24]
  406e12:	e583      	b.n	40691c <_dtoa_r+0x554>
  406e14:	9807      	ldr	r0, [sp, #28]
  406e16:	f7ff bb0b 	b.w	406430 <_dtoa_r+0x68>
  406e1a:	9b02      	ldr	r3, [sp, #8]
  406e1c:	2b00      	cmp	r3, #0
  406e1e:	f47f ad49 	bne.w	4068b4 <_dtoa_r+0x4ec>
  406e22:	e7ad      	b.n	406d80 <_dtoa_r+0x9b8>
  406e24:	0040b268 	.word	0x0040b268
  406e28:	0040b340 	.word	0x0040b340
  406e2c:	3ff00000 	.word	0x3ff00000
  406e30:	401c0000 	.word	0x401c0000
  406e34:	3fe00000 	.word	0x3fe00000
  406e38:	40240000 	.word	0x40240000
  406e3c:	40140000 	.word	0x40140000
  406e40:	9b20      	ldr	r3, [sp, #128]	; 0x80
  406e42:	2b02      	cmp	r3, #2
  406e44:	f77f ad67 	ble.w	406916 <_dtoa_r+0x54e>
  406e48:	9b06      	ldr	r3, [sp, #24]
  406e4a:	2b00      	cmp	r3, #0
  406e4c:	d182      	bne.n	406d54 <_dtoa_r+0x98c>
  406e4e:	4641      	mov	r1, r8
  406e50:	2205      	movs	r2, #5
  406e52:	4620      	mov	r0, r4
  406e54:	f000 feb6 	bl	407bc4 <__multadd>
  406e58:	4680      	mov	r8, r0
  406e5a:	4641      	mov	r1, r8
  406e5c:	4658      	mov	r0, fp
  406e5e:	f001 f88b 	bl	407f78 <__mcmp>
  406e62:	2800      	cmp	r0, #0
  406e64:	f77f af76 	ble.w	406d54 <_dtoa_r+0x98c>
  406e68:	9a04      	ldr	r2, [sp, #16]
  406e6a:	9907      	ldr	r1, [sp, #28]
  406e6c:	2331      	movs	r3, #49	; 0x31
  406e6e:	3201      	adds	r2, #1
  406e70:	9204      	str	r2, [sp, #16]
  406e72:	700b      	strb	r3, [r1, #0]
  406e74:	1c4d      	adds	r5, r1, #1
  406e76:	e771      	b.n	406d5c <_dtoa_r+0x994>
  406e78:	9a04      	ldr	r2, [sp, #16]
  406e7a:	3201      	adds	r2, #1
  406e7c:	9204      	str	r2, [sp, #16]
  406e7e:	9a07      	ldr	r2, [sp, #28]
  406e80:	2331      	movs	r3, #49	; 0x31
  406e82:	7013      	strb	r3, [r2, #0]
  406e84:	e58d      	b.n	4069a2 <_dtoa_r+0x5da>
  406e86:	f8dd b008 	ldr.w	fp, [sp, #8]
  406e8a:	9c05      	ldr	r4, [sp, #20]
  406e8c:	e46f      	b.n	40676e <_dtoa_r+0x3a6>
  406e8e:	4640      	mov	r0, r8
  406e90:	f001 fde6 	bl	408a60 <__aeabi_i2d>
  406e94:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  406e98:	f001 fe48 	bl	408b2c <__aeabi_dmul>
  406e9c:	2200      	movs	r2, #0
  406e9e:	4bbc      	ldr	r3, [pc, #752]	; (407190 <_dtoa_r+0xdc8>)
  406ea0:	f001 fc92 	bl	4087c8 <__adddf3>
  406ea4:	4606      	mov	r6, r0
  406ea6:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  406eaa:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406eae:	2200      	movs	r2, #0
  406eb0:	4bb8      	ldr	r3, [pc, #736]	; (407194 <_dtoa_r+0xdcc>)
  406eb2:	f001 fc87 	bl	4087c4 <__aeabi_dsub>
  406eb6:	4632      	mov	r2, r6
  406eb8:	463b      	mov	r3, r7
  406eba:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406ebe:	f002 f8c5 	bl	40904c <__aeabi_dcmpgt>
  406ec2:	4680      	mov	r8, r0
  406ec4:	2800      	cmp	r0, #0
  406ec6:	f040 80b3 	bne.w	407030 <_dtoa_r+0xc68>
  406eca:	4632      	mov	r2, r6
  406ecc:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
  406ed0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  406ed4:	f002 f89c 	bl	409010 <__aeabi_dcmplt>
  406ed8:	b130      	cbz	r0, 406ee8 <_dtoa_r+0xb20>
  406eda:	4646      	mov	r6, r8
  406edc:	e73a      	b.n	406d54 <_dtoa_r+0x98c>
  406ede:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
  406ee2:	f8dd b008 	ldr.w	fp, [sp, #8]
  406ee6:	4644      	mov	r4, r8
  406ee8:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  406eec:	e9cd 2302 	strd	r2, r3, [sp, #8]
  406ef0:	f7ff bb7a 	b.w	4065e8 <_dtoa_r+0x220>
  406ef4:	4659      	mov	r1, fp
  406ef6:	9a08      	ldr	r2, [sp, #32]
  406ef8:	4620      	mov	r0, r4
  406efa:	f000 ff97 	bl	407e2c <__pow5mult>
  406efe:	4683      	mov	fp, r0
  406f00:	e492      	b.n	406828 <_dtoa_r+0x460>
  406f02:	9b08      	ldr	r3, [sp, #32]
  406f04:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  406f06:	9708      	str	r7, [sp, #32]
  406f08:	1afb      	subs	r3, r7, r3
  406f0a:	441a      	add	r2, r3
  406f0c:	920a      	str	r2, [sp, #40]	; 0x28
  406f0e:	2700      	movs	r7, #0
  406f10:	e44f      	b.n	4067b2 <_dtoa_r+0x3ea>
  406f12:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  406f16:	f04f 0802 	mov.w	r8, #2
  406f1a:	e9cd 2302 	strd	r2, r3, [sp, #8]
  406f1e:	e62a      	b.n	406b76 <_dtoa_r+0x7ae>
  406f20:	2601      	movs	r6, #1
  406f22:	9621      	str	r6, [sp, #132]	; 0x84
  406f24:	960c      	str	r6, [sp, #48]	; 0x30
  406f26:	9606      	str	r6, [sp, #24]
  406f28:	2100      	movs	r1, #0
  406f2a:	6461      	str	r1, [r4, #68]	; 0x44
  406f2c:	e5f8      	b.n	406b20 <_dtoa_r+0x758>
  406f2e:	461e      	mov	r6, r3
  406f30:	e7fa      	b.n	406f28 <_dtoa_r+0xb60>
  406f32:	2a00      	cmp	r2, #0
  406f34:	dd15      	ble.n	406f62 <_dtoa_r+0xb9a>
  406f36:	4659      	mov	r1, fp
  406f38:	2201      	movs	r2, #1
  406f3a:	4620      	mov	r0, r4
  406f3c:	f8cd c008 	str.w	ip, [sp, #8]
  406f40:	f000 ffc4 	bl	407ecc <__lshift>
  406f44:	4641      	mov	r1, r8
  406f46:	4683      	mov	fp, r0
  406f48:	f001 f816 	bl	407f78 <__mcmp>
  406f4c:	2800      	cmp	r0, #0
  406f4e:	f8dd c008 	ldr.w	ip, [sp, #8]
  406f52:	f340 814a 	ble.w	4071ea <_dtoa_r+0xe22>
  406f56:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  406f5a:	f000 8106 	beq.w	40716a <_dtoa_r+0xda2>
  406f5e:	f10c 0c01 	add.w	ip, ip, #1
  406f62:	46b2      	mov	sl, r6
  406f64:	f887 c000 	strb.w	ip, [r7]
  406f68:	1c7d      	adds	r5, r7, #1
  406f6a:	464e      	mov	r6, r9
  406f6c:	e519      	b.n	4069a2 <_dtoa_r+0x5da>
  406f6e:	d104      	bne.n	406f7a <_dtoa_r+0xbb2>
  406f70:	f01c 0f01 	tst.w	ip, #1
  406f74:	d001      	beq.n	406f7a <_dtoa_r+0xbb2>
  406f76:	e504      	b.n	406982 <_dtoa_r+0x5ba>
  406f78:	4615      	mov	r5, r2
  406f7a:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  406f7e:	2b30      	cmp	r3, #48	; 0x30
  406f80:	f105 32ff 	add.w	r2, r5, #4294967295
  406f84:	d0f8      	beq.n	406f78 <_dtoa_r+0xbb0>
  406f86:	e50c      	b.n	4069a2 <_dtoa_r+0x5da>
  406f88:	9b04      	ldr	r3, [sp, #16]
  406f8a:	425d      	negs	r5, r3
  406f8c:	2d00      	cmp	r5, #0
  406f8e:	f000 80bd 	beq.w	40710c <_dtoa_r+0xd44>
  406f92:	4b81      	ldr	r3, [pc, #516]	; (407198 <_dtoa_r+0xdd0>)
  406f94:	f005 020f 	and.w	r2, r5, #15
  406f98:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  406f9c:	e9d3 2300 	ldrd	r2, r3, [r3]
  406fa0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  406fa4:	f001 fdc2 	bl	408b2c <__aeabi_dmul>
  406fa8:	112d      	asrs	r5, r5, #4
  406faa:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406fae:	f000 812c 	beq.w	40720a <_dtoa_r+0xe42>
  406fb2:	4e7a      	ldr	r6, [pc, #488]	; (40719c <_dtoa_r+0xdd4>)
  406fb4:	f04f 0802 	mov.w	r8, #2
  406fb8:	07eb      	lsls	r3, r5, #31
  406fba:	d505      	bpl.n	406fc8 <_dtoa_r+0xc00>
  406fbc:	e9d6 2300 	ldrd	r2, r3, [r6]
  406fc0:	f108 0801 	add.w	r8, r8, #1
  406fc4:	f001 fdb2 	bl	408b2c <__aeabi_dmul>
  406fc8:	106d      	asrs	r5, r5, #1
  406fca:	f106 0608 	add.w	r6, r6, #8
  406fce:	d1f3      	bne.n	406fb8 <_dtoa_r+0xbf0>
  406fd0:	e9cd 0102 	strd	r0, r1, [sp, #8]
  406fd4:	e5ea      	b.n	406bac <_dtoa_r+0x7e4>
  406fd6:	9a04      	ldr	r2, [sp, #16]
  406fd8:	3201      	adds	r2, #1
  406fda:	9204      	str	r2, [sp, #16]
  406fdc:	9a07      	ldr	r2, [sp, #28]
  406fde:	2330      	movs	r3, #48	; 0x30
  406fe0:	7013      	strb	r3, [r2, #0]
  406fe2:	2331      	movs	r3, #49	; 0x31
  406fe4:	7013      	strb	r3, [r2, #0]
  406fe6:	f7ff bbc2 	b.w	40676e <_dtoa_r+0x3a6>
  406fea:	6871      	ldr	r1, [r6, #4]
  406fec:	4620      	mov	r0, r4
  406fee:	f000 fdb9 	bl	407b64 <_Balloc>
  406ff2:	6933      	ldr	r3, [r6, #16]
  406ff4:	1c9a      	adds	r2, r3, #2
  406ff6:	4605      	mov	r5, r0
  406ff8:	0092      	lsls	r2, r2, #2
  406ffa:	f106 010c 	add.w	r1, r6, #12
  406ffe:	300c      	adds	r0, #12
  407000:	f7fd fa74 	bl	4044ec <memcpy>
  407004:	4620      	mov	r0, r4
  407006:	4629      	mov	r1, r5
  407008:	2201      	movs	r2, #1
  40700a:	f000 ff5f 	bl	407ecc <__lshift>
  40700e:	4681      	mov	r9, r0
  407010:	e503      	b.n	406a1a <_dtoa_r+0x652>
  407012:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  407016:	f000 80a8 	beq.w	40716a <_dtoa_r+0xda2>
  40701a:	f10c 0c01 	add.w	ip, ip, #1
  40701e:	46b2      	mov	sl, r6
  407020:	f887 c000 	strb.w	ip, [r7]
  407024:	1c7d      	adds	r5, r7, #1
  407026:	464e      	mov	r6, r9
  407028:	e4bb      	b.n	4069a2 <_dtoa_r+0x5da>
  40702a:	46b2      	mov	sl, r6
  40702c:	464e      	mov	r6, r9
  40702e:	e498      	b.n	406962 <_dtoa_r+0x59a>
  407030:	f04f 0800 	mov.w	r8, #0
  407034:	4646      	mov	r6, r8
  407036:	e717      	b.n	406e68 <_dtoa_r+0xaa0>
  407038:	4957      	ldr	r1, [pc, #348]	; (407198 <_dtoa_r+0xdd0>)
  40703a:	f109 33ff 	add.w	r3, r9, #4294967295
  40703e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  407042:	4632      	mov	r2, r6
  407044:	9313      	str	r3, [sp, #76]	; 0x4c
  407046:	e9d1 0100 	ldrd	r0, r1, [r1]
  40704a:	463b      	mov	r3, r7
  40704c:	f001 fd6e 	bl	408b2c <__aeabi_dmul>
  407050:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
  407054:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  407058:	4639      	mov	r1, r7
  40705a:	4630      	mov	r0, r6
  40705c:	f002 f800 	bl	409060 <__aeabi_d2iz>
  407060:	4605      	mov	r5, r0
  407062:	f001 fcfd 	bl	408a60 <__aeabi_i2d>
  407066:	4602      	mov	r2, r0
  407068:	460b      	mov	r3, r1
  40706a:	4630      	mov	r0, r6
  40706c:	4639      	mov	r1, r7
  40706e:	f001 fba9 	bl	4087c4 <__aeabi_dsub>
  407072:	9a07      	ldr	r2, [sp, #28]
  407074:	3530      	adds	r5, #48	; 0x30
  407076:	f1b9 0f01 	cmp.w	r9, #1
  40707a:	7015      	strb	r5, [r2, #0]
  40707c:	4606      	mov	r6, r0
  40707e:	460f      	mov	r7, r1
  407080:	f102 0501 	add.w	r5, r2, #1
  407084:	d023      	beq.n	4070ce <_dtoa_r+0xd06>
  407086:	9b07      	ldr	r3, [sp, #28]
  407088:	f8cd a008 	str.w	sl, [sp, #8]
  40708c:	444b      	add	r3, r9
  40708e:	465e      	mov	r6, fp
  407090:	469a      	mov	sl, r3
  407092:	46ab      	mov	fp, r5
  407094:	2200      	movs	r2, #0
  407096:	4b42      	ldr	r3, [pc, #264]	; (4071a0 <_dtoa_r+0xdd8>)
  407098:	f001 fd48 	bl	408b2c <__aeabi_dmul>
  40709c:	4689      	mov	r9, r1
  40709e:	4680      	mov	r8, r0
  4070a0:	f001 ffde 	bl	409060 <__aeabi_d2iz>
  4070a4:	4607      	mov	r7, r0
  4070a6:	f001 fcdb 	bl	408a60 <__aeabi_i2d>
  4070aa:	3730      	adds	r7, #48	; 0x30
  4070ac:	4602      	mov	r2, r0
  4070ae:	460b      	mov	r3, r1
  4070b0:	4640      	mov	r0, r8
  4070b2:	4649      	mov	r1, r9
  4070b4:	f001 fb86 	bl	4087c4 <__aeabi_dsub>
  4070b8:	f80b 7b01 	strb.w	r7, [fp], #1
  4070bc:	45d3      	cmp	fp, sl
  4070be:	d1e9      	bne.n	407094 <_dtoa_r+0xccc>
  4070c0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  4070c2:	f8dd a008 	ldr.w	sl, [sp, #8]
  4070c6:	46b3      	mov	fp, r6
  4070c8:	460f      	mov	r7, r1
  4070ca:	4606      	mov	r6, r0
  4070cc:	441d      	add	r5, r3
  4070ce:	2200      	movs	r2, #0
  4070d0:	4b34      	ldr	r3, [pc, #208]	; (4071a4 <_dtoa_r+0xddc>)
  4070d2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  4070d6:	f001 fb77 	bl	4087c8 <__adddf3>
  4070da:	4632      	mov	r2, r6
  4070dc:	463b      	mov	r3, r7
  4070de:	f001 ff97 	bl	409010 <__aeabi_dcmplt>
  4070e2:	2800      	cmp	r0, #0
  4070e4:	d047      	beq.n	407176 <_dtoa_r+0xdae>
  4070e6:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4070e8:	9304      	str	r3, [sp, #16]
  4070ea:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  4070ee:	f7ff bb2c 	b.w	40674a <_dtoa_r+0x382>
  4070f2:	9b05      	ldr	r3, [sp, #20]
  4070f4:	9a06      	ldr	r2, [sp, #24]
  4070f6:	1a9d      	subs	r5, r3, r2
  4070f8:	2300      	movs	r3, #0
  4070fa:	f7ff bb60 	b.w	4067be <_dtoa_r+0x3f6>
  4070fe:	9b14      	ldr	r3, [sp, #80]	; 0x50
  407100:	9f08      	ldr	r7, [sp, #32]
  407102:	9d05      	ldr	r5, [sp, #20]
  407104:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  407108:	f7ff bb59 	b.w	4067be <_dtoa_r+0x3f6>
  40710c:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  407110:	f04f 0802 	mov.w	r8, #2
  407114:	e9cd 2302 	strd	r2, r3, [sp, #8]
  407118:	e548      	b.n	406bac <_dtoa_r+0x7e4>
  40711a:	9b06      	ldr	r3, [sp, #24]
  40711c:	2b00      	cmp	r3, #0
  40711e:	f43f aeb6 	beq.w	406e8e <_dtoa_r+0xac6>
  407122:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  407124:	2d00      	cmp	r5, #0
  407126:	f77f aedf 	ble.w	406ee8 <_dtoa_r+0xb20>
  40712a:	2200      	movs	r2, #0
  40712c:	4b1c      	ldr	r3, [pc, #112]	; (4071a0 <_dtoa_r+0xdd8>)
  40712e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  407132:	f001 fcfb 	bl	408b2c <__aeabi_dmul>
  407136:	4606      	mov	r6, r0
  407138:	460f      	mov	r7, r1
  40713a:	f108 0001 	add.w	r0, r8, #1
  40713e:	e9cd 6702 	strd	r6, r7, [sp, #8]
  407142:	f001 fc8d 	bl	408a60 <__aeabi_i2d>
  407146:	4602      	mov	r2, r0
  407148:	460b      	mov	r3, r1
  40714a:	4630      	mov	r0, r6
  40714c:	4639      	mov	r1, r7
  40714e:	f001 fced 	bl	408b2c <__aeabi_dmul>
  407152:	4b0f      	ldr	r3, [pc, #60]	; (407190 <_dtoa_r+0xdc8>)
  407154:	2200      	movs	r2, #0
  407156:	f001 fb37 	bl	4087c8 <__adddf3>
  40715a:	9b04      	ldr	r3, [sp, #16]
  40715c:	3b01      	subs	r3, #1
  40715e:	4606      	mov	r6, r0
  407160:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  407164:	9312      	str	r3, [sp, #72]	; 0x48
  407166:	46a9      	mov	r9, r5
  407168:	e541      	b.n	406bee <_dtoa_r+0x826>
  40716a:	2239      	movs	r2, #57	; 0x39
  40716c:	46b2      	mov	sl, r6
  40716e:	703a      	strb	r2, [r7, #0]
  407170:	464e      	mov	r6, r9
  407172:	1c7d      	adds	r5, r7, #1
  407174:	e407      	b.n	406986 <_dtoa_r+0x5be>
  407176:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
  40717a:	2000      	movs	r0, #0
  40717c:	4909      	ldr	r1, [pc, #36]	; (4071a4 <_dtoa_r+0xddc>)
  40717e:	f001 fb21 	bl	4087c4 <__aeabi_dsub>
  407182:	4632      	mov	r2, r6
  407184:	463b      	mov	r3, r7
  407186:	f001 ff61 	bl	40904c <__aeabi_dcmpgt>
  40718a:	b970      	cbnz	r0, 4071aa <_dtoa_r+0xde2>
  40718c:	e6ac      	b.n	406ee8 <_dtoa_r+0xb20>
  40718e:	bf00      	nop
  407190:	401c0000 	.word	0x401c0000
  407194:	40140000 	.word	0x40140000
  407198:	0040b268 	.word	0x0040b268
  40719c:	0040b340 	.word	0x0040b340
  4071a0:	40240000 	.word	0x40240000
  4071a4:	3fe00000 	.word	0x3fe00000
  4071a8:	4615      	mov	r5, r2
  4071aa:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  4071ae:	2b30      	cmp	r3, #48	; 0x30
  4071b0:	f105 32ff 	add.w	r2, r5, #4294967295
  4071b4:	d0f8      	beq.n	4071a8 <_dtoa_r+0xde0>
  4071b6:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4071b8:	9304      	str	r3, [sp, #16]
  4071ba:	f7ff bad8 	b.w	40676e <_dtoa_r+0x3a6>
  4071be:	4643      	mov	r3, r8
  4071c0:	f8dd b008 	ldr.w	fp, [sp, #8]
  4071c4:	46a0      	mov	r8, r4
  4071c6:	461c      	mov	r4, r3
  4071c8:	9b12      	ldr	r3, [sp, #72]	; 0x48
  4071ca:	9304      	str	r3, [sp, #16]
  4071cc:	f7ff babd 	b.w	40674a <_dtoa_r+0x382>
  4071d0:	46b9      	mov	r9, r7
  4071d2:	f7ff bb71 	b.w	4068b8 <_dtoa_r+0x4f0>
  4071d6:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
  4071da:	d0c6      	beq.n	40716a <_dtoa_r+0xda2>
  4071dc:	f1ba 0f00 	cmp.w	sl, #0
  4071e0:	f77f aebf 	ble.w	406f62 <_dtoa_r+0xb9a>
  4071e4:	f105 0c31 	add.w	ip, r5, #49	; 0x31
  4071e8:	e6bb      	b.n	406f62 <_dtoa_r+0xb9a>
  4071ea:	f47f aeba 	bne.w	406f62 <_dtoa_r+0xb9a>
  4071ee:	f01c 0f01 	tst.w	ip, #1
  4071f2:	f43f aeb6 	beq.w	406f62 <_dtoa_r+0xb9a>
  4071f6:	e6ae      	b.n	406f56 <_dtoa_r+0xb8e>
  4071f8:	f04f 0800 	mov.w	r8, #0
  4071fc:	4646      	mov	r6, r8
  4071fe:	e5a9      	b.n	406d54 <_dtoa_r+0x98c>
  407200:	9b20      	ldr	r3, [sp, #128]	; 0x80
  407202:	2b02      	cmp	r3, #2
  407204:	dc04      	bgt.n	407210 <_dtoa_r+0xe48>
  407206:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  407208:	e602      	b.n	406e10 <_dtoa_r+0xa48>
  40720a:	f04f 0802 	mov.w	r8, #2
  40720e:	e4cd      	b.n	406bac <_dtoa_r+0x7e4>
  407210:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  407212:	9306      	str	r3, [sp, #24]
  407214:	e618      	b.n	406e48 <_dtoa_r+0xa80>
  407216:	9b20      	ldr	r3, [sp, #128]	; 0x80
  407218:	2b02      	cmp	r3, #2
  40721a:	dcf9      	bgt.n	407210 <_dtoa_r+0xe48>
  40721c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40721e:	f7ff bbee 	b.w	4069fe <_dtoa_r+0x636>
  407222:	2500      	movs	r5, #0
  407224:	6465      	str	r5, [r4, #68]	; 0x44
  407226:	4629      	mov	r1, r5
  407228:	4620      	mov	r0, r4
  40722a:	f000 fc9b 	bl	407b64 <_Balloc>
  40722e:	f04f 33ff 	mov.w	r3, #4294967295
  407232:	9306      	str	r3, [sp, #24]
  407234:	930c      	str	r3, [sp, #48]	; 0x30
  407236:	2301      	movs	r3, #1
  407238:	9007      	str	r0, [sp, #28]
  40723a:	9521      	str	r5, [sp, #132]	; 0x84
  40723c:	6420      	str	r0, [r4, #64]	; 0x40
  40723e:	9309      	str	r3, [sp, #36]	; 0x24
  407240:	f7ff b9d2 	b.w	4065e8 <_dtoa_r+0x220>
  407244:	f43f ab4d 	beq.w	4068e2 <_dtoa_r+0x51a>
  407248:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  40724c:	f7ff bb44 	b.w	4068d8 <_dtoa_r+0x510>
  407250:	2301      	movs	r3, #1
  407252:	9309      	str	r3, [sp, #36]	; 0x24
  407254:	e559      	b.n	406d0a <_dtoa_r+0x942>
  407256:	2501      	movs	r5, #1
  407258:	f7ff b990 	b.w	40657c <_dtoa_r+0x1b4>

0040725c <__libc_fini_array>:
  40725c:	b538      	push	{r3, r4, r5, lr}
  40725e:	4b08      	ldr	r3, [pc, #32]	; (407280 <__libc_fini_array+0x24>)
  407260:	4d08      	ldr	r5, [pc, #32]	; (407284 <__libc_fini_array+0x28>)
  407262:	1aed      	subs	r5, r5, r3
  407264:	10ac      	asrs	r4, r5, #2
  407266:	bf18      	it	ne
  407268:	18ed      	addne	r5, r5, r3
  40726a:	d005      	beq.n	407278 <__libc_fini_array+0x1c>
  40726c:	3c01      	subs	r4, #1
  40726e:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  407272:	4798      	blx	r3
  407274:	2c00      	cmp	r4, #0
  407276:	d1f9      	bne.n	40726c <__libc_fini_array+0x10>
  407278:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40727c:	f004 b87e 	b.w	40b37c <_fini>
  407280:	0040b388 	.word	0x0040b388
  407284:	0040b38c 	.word	0x0040b38c

00407288 <_malloc_trim_r>:
  407288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40728a:	4f23      	ldr	r7, [pc, #140]	; (407318 <_malloc_trim_r+0x90>)
  40728c:	460c      	mov	r4, r1
  40728e:	4606      	mov	r6, r0
  407290:	f000 fc64 	bl	407b5c <__malloc_lock>
  407294:	68bb      	ldr	r3, [r7, #8]
  407296:	685d      	ldr	r5, [r3, #4]
  407298:	f025 0503 	bic.w	r5, r5, #3
  40729c:	1b29      	subs	r1, r5, r4
  40729e:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  4072a2:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  4072a6:	f021 010f 	bic.w	r1, r1, #15
  4072aa:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  4072ae:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  4072b2:	db07      	blt.n	4072c4 <_malloc_trim_r+0x3c>
  4072b4:	4630      	mov	r0, r6
  4072b6:	2100      	movs	r1, #0
  4072b8:	f001 f96a 	bl	408590 <_sbrk_r>
  4072bc:	68bb      	ldr	r3, [r7, #8]
  4072be:	442b      	add	r3, r5
  4072c0:	4298      	cmp	r0, r3
  4072c2:	d004      	beq.n	4072ce <_malloc_trim_r+0x46>
  4072c4:	4630      	mov	r0, r6
  4072c6:	f000 fc4b 	bl	407b60 <__malloc_unlock>
  4072ca:	2000      	movs	r0, #0
  4072cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4072ce:	4630      	mov	r0, r6
  4072d0:	4261      	negs	r1, r4
  4072d2:	f001 f95d 	bl	408590 <_sbrk_r>
  4072d6:	3001      	adds	r0, #1
  4072d8:	d00d      	beq.n	4072f6 <_malloc_trim_r+0x6e>
  4072da:	4b10      	ldr	r3, [pc, #64]	; (40731c <_malloc_trim_r+0x94>)
  4072dc:	68ba      	ldr	r2, [r7, #8]
  4072de:	6819      	ldr	r1, [r3, #0]
  4072e0:	1b2d      	subs	r5, r5, r4
  4072e2:	f045 0501 	orr.w	r5, r5, #1
  4072e6:	4630      	mov	r0, r6
  4072e8:	1b09      	subs	r1, r1, r4
  4072ea:	6055      	str	r5, [r2, #4]
  4072ec:	6019      	str	r1, [r3, #0]
  4072ee:	f000 fc37 	bl	407b60 <__malloc_unlock>
  4072f2:	2001      	movs	r0, #1
  4072f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4072f6:	4630      	mov	r0, r6
  4072f8:	2100      	movs	r1, #0
  4072fa:	f001 f949 	bl	408590 <_sbrk_r>
  4072fe:	68ba      	ldr	r2, [r7, #8]
  407300:	1a83      	subs	r3, r0, r2
  407302:	2b0f      	cmp	r3, #15
  407304:	ddde      	ble.n	4072c4 <_malloc_trim_r+0x3c>
  407306:	4c06      	ldr	r4, [pc, #24]	; (407320 <_malloc_trim_r+0x98>)
  407308:	4904      	ldr	r1, [pc, #16]	; (40731c <_malloc_trim_r+0x94>)
  40730a:	6824      	ldr	r4, [r4, #0]
  40730c:	f043 0301 	orr.w	r3, r3, #1
  407310:	1b00      	subs	r0, r0, r4
  407312:	6053      	str	r3, [r2, #4]
  407314:	6008      	str	r0, [r1, #0]
  407316:	e7d5      	b.n	4072c4 <_malloc_trim_r+0x3c>
  407318:	20000660 	.word	0x20000660
  40731c:	200051e4 	.word	0x200051e4
  407320:	20000a6c 	.word	0x20000a6c

00407324 <_free_r>:
  407324:	2900      	cmp	r1, #0
  407326:	d04e      	beq.n	4073c6 <_free_r+0xa2>
  407328:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40732c:	460c      	mov	r4, r1
  40732e:	4680      	mov	r8, r0
  407330:	f000 fc14 	bl	407b5c <__malloc_lock>
  407334:	f854 7c04 	ldr.w	r7, [r4, #-4]
  407338:	4962      	ldr	r1, [pc, #392]	; (4074c4 <_free_r+0x1a0>)
  40733a:	f027 0201 	bic.w	r2, r7, #1
  40733e:	f1a4 0508 	sub.w	r5, r4, #8
  407342:	18ab      	adds	r3, r5, r2
  407344:	688e      	ldr	r6, [r1, #8]
  407346:	6858      	ldr	r0, [r3, #4]
  407348:	429e      	cmp	r6, r3
  40734a:	f020 0003 	bic.w	r0, r0, #3
  40734e:	d05a      	beq.n	407406 <_free_r+0xe2>
  407350:	07fe      	lsls	r6, r7, #31
  407352:	6058      	str	r0, [r3, #4]
  407354:	d40b      	bmi.n	40736e <_free_r+0x4a>
  407356:	f854 7c08 	ldr.w	r7, [r4, #-8]
  40735a:	1bed      	subs	r5, r5, r7
  40735c:	f101 0e08 	add.w	lr, r1, #8
  407360:	68ac      	ldr	r4, [r5, #8]
  407362:	4574      	cmp	r4, lr
  407364:	443a      	add	r2, r7
  407366:	d067      	beq.n	407438 <_free_r+0x114>
  407368:	68ef      	ldr	r7, [r5, #12]
  40736a:	60e7      	str	r7, [r4, #12]
  40736c:	60bc      	str	r4, [r7, #8]
  40736e:	181c      	adds	r4, r3, r0
  407370:	6864      	ldr	r4, [r4, #4]
  407372:	07e4      	lsls	r4, r4, #31
  407374:	d40c      	bmi.n	407390 <_free_r+0x6c>
  407376:	4f54      	ldr	r7, [pc, #336]	; (4074c8 <_free_r+0x1a4>)
  407378:	689c      	ldr	r4, [r3, #8]
  40737a:	42bc      	cmp	r4, r7
  40737c:	4402      	add	r2, r0
  40737e:	d07c      	beq.n	40747a <_free_r+0x156>
  407380:	68d8      	ldr	r0, [r3, #12]
  407382:	60e0      	str	r0, [r4, #12]
  407384:	f042 0301 	orr.w	r3, r2, #1
  407388:	6084      	str	r4, [r0, #8]
  40738a:	606b      	str	r3, [r5, #4]
  40738c:	50aa      	str	r2, [r5, r2]
  40738e:	e003      	b.n	407398 <_free_r+0x74>
  407390:	f042 0301 	orr.w	r3, r2, #1
  407394:	606b      	str	r3, [r5, #4]
  407396:	50aa      	str	r2, [r5, r2]
  407398:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  40739c:	d214      	bcs.n	4073c8 <_free_r+0xa4>
  40739e:	08d2      	lsrs	r2, r2, #3
  4073a0:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
  4073a4:	6848      	ldr	r0, [r1, #4]
  4073a6:	689f      	ldr	r7, [r3, #8]
  4073a8:	60af      	str	r7, [r5, #8]
  4073aa:	1092      	asrs	r2, r2, #2
  4073ac:	2401      	movs	r4, #1
  4073ae:	fa04 f202 	lsl.w	r2, r4, r2
  4073b2:	4310      	orrs	r0, r2
  4073b4:	60eb      	str	r3, [r5, #12]
  4073b6:	6048      	str	r0, [r1, #4]
  4073b8:	609d      	str	r5, [r3, #8]
  4073ba:	60fd      	str	r5, [r7, #12]
  4073bc:	4640      	mov	r0, r8
  4073be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4073c2:	f000 bbcd 	b.w	407b60 <__malloc_unlock>
  4073c6:	4770      	bx	lr
  4073c8:	0a53      	lsrs	r3, r2, #9
  4073ca:	2b04      	cmp	r3, #4
  4073cc:	d847      	bhi.n	40745e <_free_r+0x13a>
  4073ce:	0993      	lsrs	r3, r2, #6
  4073d0:	f103 0438 	add.w	r4, r3, #56	; 0x38
  4073d4:	0060      	lsls	r0, r4, #1
  4073d6:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  4073da:	493a      	ldr	r1, [pc, #232]	; (4074c4 <_free_r+0x1a0>)
  4073dc:	6883      	ldr	r3, [r0, #8]
  4073de:	4283      	cmp	r3, r0
  4073e0:	d043      	beq.n	40746a <_free_r+0x146>
  4073e2:	6859      	ldr	r1, [r3, #4]
  4073e4:	f021 0103 	bic.w	r1, r1, #3
  4073e8:	4291      	cmp	r1, r2
  4073ea:	d902      	bls.n	4073f2 <_free_r+0xce>
  4073ec:	689b      	ldr	r3, [r3, #8]
  4073ee:	4298      	cmp	r0, r3
  4073f0:	d1f7      	bne.n	4073e2 <_free_r+0xbe>
  4073f2:	68da      	ldr	r2, [r3, #12]
  4073f4:	60ea      	str	r2, [r5, #12]
  4073f6:	60ab      	str	r3, [r5, #8]
  4073f8:	4640      	mov	r0, r8
  4073fa:	6095      	str	r5, [r2, #8]
  4073fc:	60dd      	str	r5, [r3, #12]
  4073fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  407402:	f000 bbad 	b.w	407b60 <__malloc_unlock>
  407406:	07ff      	lsls	r7, r7, #31
  407408:	4402      	add	r2, r0
  40740a:	d407      	bmi.n	40741c <_free_r+0xf8>
  40740c:	f854 3c08 	ldr.w	r3, [r4, #-8]
  407410:	1aed      	subs	r5, r5, r3
  407412:	441a      	add	r2, r3
  407414:	68a8      	ldr	r0, [r5, #8]
  407416:	68eb      	ldr	r3, [r5, #12]
  407418:	60c3      	str	r3, [r0, #12]
  40741a:	6098      	str	r0, [r3, #8]
  40741c:	4b2b      	ldr	r3, [pc, #172]	; (4074cc <_free_r+0x1a8>)
  40741e:	681b      	ldr	r3, [r3, #0]
  407420:	f042 0001 	orr.w	r0, r2, #1
  407424:	429a      	cmp	r2, r3
  407426:	6068      	str	r0, [r5, #4]
  407428:	608d      	str	r5, [r1, #8]
  40742a:	d3c7      	bcc.n	4073bc <_free_r+0x98>
  40742c:	4b28      	ldr	r3, [pc, #160]	; (4074d0 <_free_r+0x1ac>)
  40742e:	4640      	mov	r0, r8
  407430:	6819      	ldr	r1, [r3, #0]
  407432:	f7ff ff29 	bl	407288 <_malloc_trim_r>
  407436:	e7c1      	b.n	4073bc <_free_r+0x98>
  407438:	1819      	adds	r1, r3, r0
  40743a:	6849      	ldr	r1, [r1, #4]
  40743c:	07c9      	lsls	r1, r1, #31
  40743e:	d409      	bmi.n	407454 <_free_r+0x130>
  407440:	68d9      	ldr	r1, [r3, #12]
  407442:	689b      	ldr	r3, [r3, #8]
  407444:	4402      	add	r2, r0
  407446:	f042 0001 	orr.w	r0, r2, #1
  40744a:	60d9      	str	r1, [r3, #12]
  40744c:	608b      	str	r3, [r1, #8]
  40744e:	6068      	str	r0, [r5, #4]
  407450:	50aa      	str	r2, [r5, r2]
  407452:	e7b3      	b.n	4073bc <_free_r+0x98>
  407454:	f042 0301 	orr.w	r3, r2, #1
  407458:	606b      	str	r3, [r5, #4]
  40745a:	50aa      	str	r2, [r5, r2]
  40745c:	e7ae      	b.n	4073bc <_free_r+0x98>
  40745e:	2b14      	cmp	r3, #20
  407460:	d814      	bhi.n	40748c <_free_r+0x168>
  407462:	f103 045b 	add.w	r4, r3, #91	; 0x5b
  407466:	0060      	lsls	r0, r4, #1
  407468:	e7b5      	b.n	4073d6 <_free_r+0xb2>
  40746a:	684a      	ldr	r2, [r1, #4]
  40746c:	10a4      	asrs	r4, r4, #2
  40746e:	2001      	movs	r0, #1
  407470:	40a0      	lsls	r0, r4
  407472:	4302      	orrs	r2, r0
  407474:	604a      	str	r2, [r1, #4]
  407476:	461a      	mov	r2, r3
  407478:	e7bc      	b.n	4073f4 <_free_r+0xd0>
  40747a:	f042 0301 	orr.w	r3, r2, #1
  40747e:	614d      	str	r5, [r1, #20]
  407480:	610d      	str	r5, [r1, #16]
  407482:	60ec      	str	r4, [r5, #12]
  407484:	60ac      	str	r4, [r5, #8]
  407486:	606b      	str	r3, [r5, #4]
  407488:	50aa      	str	r2, [r5, r2]
  40748a:	e797      	b.n	4073bc <_free_r+0x98>
  40748c:	2b54      	cmp	r3, #84	; 0x54
  40748e:	d804      	bhi.n	40749a <_free_r+0x176>
  407490:	0b13      	lsrs	r3, r2, #12
  407492:	f103 046e 	add.w	r4, r3, #110	; 0x6e
  407496:	0060      	lsls	r0, r4, #1
  407498:	e79d      	b.n	4073d6 <_free_r+0xb2>
  40749a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  40749e:	d804      	bhi.n	4074aa <_free_r+0x186>
  4074a0:	0bd3      	lsrs	r3, r2, #15
  4074a2:	f103 0477 	add.w	r4, r3, #119	; 0x77
  4074a6:	0060      	lsls	r0, r4, #1
  4074a8:	e795      	b.n	4073d6 <_free_r+0xb2>
  4074aa:	f240 5054 	movw	r0, #1364	; 0x554
  4074ae:	4283      	cmp	r3, r0
  4074b0:	d804      	bhi.n	4074bc <_free_r+0x198>
  4074b2:	0c93      	lsrs	r3, r2, #18
  4074b4:	f103 047c 	add.w	r4, r3, #124	; 0x7c
  4074b8:	0060      	lsls	r0, r4, #1
  4074ba:	e78c      	b.n	4073d6 <_free_r+0xb2>
  4074bc:	20fc      	movs	r0, #252	; 0xfc
  4074be:	247e      	movs	r4, #126	; 0x7e
  4074c0:	e789      	b.n	4073d6 <_free_r+0xb2>
  4074c2:	bf00      	nop
  4074c4:	20000660 	.word	0x20000660
  4074c8:	20000668 	.word	0x20000668
  4074cc:	20000a68 	.word	0x20000a68
  4074d0:	200051e0 	.word	0x200051e0

004074d4 <_localeconv_r>:
  4074d4:	4800      	ldr	r0, [pc, #0]	; (4074d8 <_localeconv_r+0x4>)
  4074d6:	4770      	bx	lr
  4074d8:	20000628 	.word	0x20000628

004074dc <_malloc_r>:
  4074dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4074e0:	f101 050b 	add.w	r5, r1, #11
  4074e4:	2d16      	cmp	r5, #22
  4074e6:	b083      	sub	sp, #12
  4074e8:	4606      	mov	r6, r0
  4074ea:	d927      	bls.n	40753c <_malloc_r+0x60>
  4074ec:	f035 0507 	bics.w	r5, r5, #7
  4074f0:	f100 80b6 	bmi.w	407660 <_malloc_r+0x184>
  4074f4:	42a9      	cmp	r1, r5
  4074f6:	f200 80b3 	bhi.w	407660 <_malloc_r+0x184>
  4074fa:	f000 fb2f 	bl	407b5c <__malloc_lock>
  4074fe:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  407502:	d222      	bcs.n	40754a <_malloc_r+0x6e>
  407504:	4fc2      	ldr	r7, [pc, #776]	; (407810 <_malloc_r+0x334>)
  407506:	08e8      	lsrs	r0, r5, #3
  407508:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
  40750c:	68dc      	ldr	r4, [r3, #12]
  40750e:	429c      	cmp	r4, r3
  407510:	f000 81c8 	beq.w	4078a4 <_malloc_r+0x3c8>
  407514:	6863      	ldr	r3, [r4, #4]
  407516:	68e1      	ldr	r1, [r4, #12]
  407518:	68a5      	ldr	r5, [r4, #8]
  40751a:	f023 0303 	bic.w	r3, r3, #3
  40751e:	4423      	add	r3, r4
  407520:	4630      	mov	r0, r6
  407522:	685a      	ldr	r2, [r3, #4]
  407524:	60e9      	str	r1, [r5, #12]
  407526:	f042 0201 	orr.w	r2, r2, #1
  40752a:	608d      	str	r5, [r1, #8]
  40752c:	605a      	str	r2, [r3, #4]
  40752e:	f000 fb17 	bl	407b60 <__malloc_unlock>
  407532:	3408      	adds	r4, #8
  407534:	4620      	mov	r0, r4
  407536:	b003      	add	sp, #12
  407538:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40753c:	2910      	cmp	r1, #16
  40753e:	f200 808f 	bhi.w	407660 <_malloc_r+0x184>
  407542:	f000 fb0b 	bl	407b5c <__malloc_lock>
  407546:	2510      	movs	r5, #16
  407548:	e7dc      	b.n	407504 <_malloc_r+0x28>
  40754a:	0a68      	lsrs	r0, r5, #9
  40754c:	f000 808f 	beq.w	40766e <_malloc_r+0x192>
  407550:	2804      	cmp	r0, #4
  407552:	f200 8154 	bhi.w	4077fe <_malloc_r+0x322>
  407556:	09a8      	lsrs	r0, r5, #6
  407558:	3038      	adds	r0, #56	; 0x38
  40755a:	0041      	lsls	r1, r0, #1
  40755c:	4fac      	ldr	r7, [pc, #688]	; (407810 <_malloc_r+0x334>)
  40755e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  407562:	68cc      	ldr	r4, [r1, #12]
  407564:	42a1      	cmp	r1, r4
  407566:	d106      	bne.n	407576 <_malloc_r+0x9a>
  407568:	e00c      	b.n	407584 <_malloc_r+0xa8>
  40756a:	2a00      	cmp	r2, #0
  40756c:	f280 8082 	bge.w	407674 <_malloc_r+0x198>
  407570:	68e4      	ldr	r4, [r4, #12]
  407572:	42a1      	cmp	r1, r4
  407574:	d006      	beq.n	407584 <_malloc_r+0xa8>
  407576:	6863      	ldr	r3, [r4, #4]
  407578:	f023 0303 	bic.w	r3, r3, #3
  40757c:	1b5a      	subs	r2, r3, r5
  40757e:	2a0f      	cmp	r2, #15
  407580:	ddf3      	ble.n	40756a <_malloc_r+0x8e>
  407582:	3801      	subs	r0, #1
  407584:	3001      	adds	r0, #1
  407586:	49a2      	ldr	r1, [pc, #648]	; (407810 <_malloc_r+0x334>)
  407588:	693c      	ldr	r4, [r7, #16]
  40758a:	f101 0e08 	add.w	lr, r1, #8
  40758e:	4574      	cmp	r4, lr
  407590:	f000 817d 	beq.w	40788e <_malloc_r+0x3b2>
  407594:	6863      	ldr	r3, [r4, #4]
  407596:	f023 0303 	bic.w	r3, r3, #3
  40759a:	1b5a      	subs	r2, r3, r5
  40759c:	2a0f      	cmp	r2, #15
  40759e:	f300 8163 	bgt.w	407868 <_malloc_r+0x38c>
  4075a2:	2a00      	cmp	r2, #0
  4075a4:	f8c1 e014 	str.w	lr, [r1, #20]
  4075a8:	f8c1 e010 	str.w	lr, [r1, #16]
  4075ac:	da73      	bge.n	407696 <_malloc_r+0x1ba>
  4075ae:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4075b2:	f080 8139 	bcs.w	407828 <_malloc_r+0x34c>
  4075b6:	08db      	lsrs	r3, r3, #3
  4075b8:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
  4075bc:	ea4f 0ca3 	mov.w	ip, r3, asr #2
  4075c0:	684a      	ldr	r2, [r1, #4]
  4075c2:	f8d8 9008 	ldr.w	r9, [r8, #8]
  4075c6:	f8c4 9008 	str.w	r9, [r4, #8]
  4075ca:	2301      	movs	r3, #1
  4075cc:	fa03 f30c 	lsl.w	r3, r3, ip
  4075d0:	4313      	orrs	r3, r2
  4075d2:	f8c4 800c 	str.w	r8, [r4, #12]
  4075d6:	604b      	str	r3, [r1, #4]
  4075d8:	f8c8 4008 	str.w	r4, [r8, #8]
  4075dc:	f8c9 400c 	str.w	r4, [r9, #12]
  4075e0:	1082      	asrs	r2, r0, #2
  4075e2:	2401      	movs	r4, #1
  4075e4:	4094      	lsls	r4, r2
  4075e6:	429c      	cmp	r4, r3
  4075e8:	d862      	bhi.n	4076b0 <_malloc_r+0x1d4>
  4075ea:	4223      	tst	r3, r4
  4075ec:	d106      	bne.n	4075fc <_malloc_r+0x120>
  4075ee:	f020 0003 	bic.w	r0, r0, #3
  4075f2:	0064      	lsls	r4, r4, #1
  4075f4:	4223      	tst	r3, r4
  4075f6:	f100 0004 	add.w	r0, r0, #4
  4075fa:	d0fa      	beq.n	4075f2 <_malloc_r+0x116>
  4075fc:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
  407600:	46c4      	mov	ip, r8
  407602:	4681      	mov	r9, r0
  407604:	f8dc 300c 	ldr.w	r3, [ip, #12]
  407608:	459c      	cmp	ip, r3
  40760a:	d107      	bne.n	40761c <_malloc_r+0x140>
  40760c:	e141      	b.n	407892 <_malloc_r+0x3b6>
  40760e:	2900      	cmp	r1, #0
  407610:	f280 8151 	bge.w	4078b6 <_malloc_r+0x3da>
  407614:	68db      	ldr	r3, [r3, #12]
  407616:	459c      	cmp	ip, r3
  407618:	f000 813b 	beq.w	407892 <_malloc_r+0x3b6>
  40761c:	685a      	ldr	r2, [r3, #4]
  40761e:	f022 0203 	bic.w	r2, r2, #3
  407622:	1b51      	subs	r1, r2, r5
  407624:	290f      	cmp	r1, #15
  407626:	ddf2      	ble.n	40760e <_malloc_r+0x132>
  407628:	461c      	mov	r4, r3
  40762a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  40762e:	f854 8f08 	ldr.w	r8, [r4, #8]!
  407632:	195a      	adds	r2, r3, r5
  407634:	f045 0901 	orr.w	r9, r5, #1
  407638:	f041 0501 	orr.w	r5, r1, #1
  40763c:	f8c3 9004 	str.w	r9, [r3, #4]
  407640:	4630      	mov	r0, r6
  407642:	f8c8 c00c 	str.w	ip, [r8, #12]
  407646:	f8cc 8008 	str.w	r8, [ip, #8]
  40764a:	617a      	str	r2, [r7, #20]
  40764c:	613a      	str	r2, [r7, #16]
  40764e:	f8c2 e00c 	str.w	lr, [r2, #12]
  407652:	f8c2 e008 	str.w	lr, [r2, #8]
  407656:	6055      	str	r5, [r2, #4]
  407658:	5051      	str	r1, [r2, r1]
  40765a:	f000 fa81 	bl	407b60 <__malloc_unlock>
  40765e:	e769      	b.n	407534 <_malloc_r+0x58>
  407660:	2400      	movs	r4, #0
  407662:	230c      	movs	r3, #12
  407664:	4620      	mov	r0, r4
  407666:	6033      	str	r3, [r6, #0]
  407668:	b003      	add	sp, #12
  40766a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40766e:	217e      	movs	r1, #126	; 0x7e
  407670:	203f      	movs	r0, #63	; 0x3f
  407672:	e773      	b.n	40755c <_malloc_r+0x80>
  407674:	4423      	add	r3, r4
  407676:	68e1      	ldr	r1, [r4, #12]
  407678:	685a      	ldr	r2, [r3, #4]
  40767a:	68a5      	ldr	r5, [r4, #8]
  40767c:	f042 0201 	orr.w	r2, r2, #1
  407680:	60e9      	str	r1, [r5, #12]
  407682:	4630      	mov	r0, r6
  407684:	608d      	str	r5, [r1, #8]
  407686:	605a      	str	r2, [r3, #4]
  407688:	f000 fa6a 	bl	407b60 <__malloc_unlock>
  40768c:	3408      	adds	r4, #8
  40768e:	4620      	mov	r0, r4
  407690:	b003      	add	sp, #12
  407692:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407696:	4423      	add	r3, r4
  407698:	4630      	mov	r0, r6
  40769a:	685a      	ldr	r2, [r3, #4]
  40769c:	f042 0201 	orr.w	r2, r2, #1
  4076a0:	605a      	str	r2, [r3, #4]
  4076a2:	f000 fa5d 	bl	407b60 <__malloc_unlock>
  4076a6:	3408      	adds	r4, #8
  4076a8:	4620      	mov	r0, r4
  4076aa:	b003      	add	sp, #12
  4076ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4076b0:	68bc      	ldr	r4, [r7, #8]
  4076b2:	6863      	ldr	r3, [r4, #4]
  4076b4:	f023 0803 	bic.w	r8, r3, #3
  4076b8:	4545      	cmp	r5, r8
  4076ba:	d804      	bhi.n	4076c6 <_malloc_r+0x1ea>
  4076bc:	ebc5 0308 	rsb	r3, r5, r8
  4076c0:	2b0f      	cmp	r3, #15
  4076c2:	f300 808c 	bgt.w	4077de <_malloc_r+0x302>
  4076c6:	4b53      	ldr	r3, [pc, #332]	; (407814 <_malloc_r+0x338>)
  4076c8:	f8df a158 	ldr.w	sl, [pc, #344]	; 407824 <_malloc_r+0x348>
  4076cc:	681a      	ldr	r2, [r3, #0]
  4076ce:	f8da 3000 	ldr.w	r3, [sl]
  4076d2:	3301      	adds	r3, #1
  4076d4:	442a      	add	r2, r5
  4076d6:	eb04 0b08 	add.w	fp, r4, r8
  4076da:	f000 8150 	beq.w	40797e <_malloc_r+0x4a2>
  4076de:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  4076e2:	320f      	adds	r2, #15
  4076e4:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
  4076e8:	f022 020f 	bic.w	r2, r2, #15
  4076ec:	4611      	mov	r1, r2
  4076ee:	4630      	mov	r0, r6
  4076f0:	9201      	str	r2, [sp, #4]
  4076f2:	f000 ff4d 	bl	408590 <_sbrk_r>
  4076f6:	f1b0 3fff 	cmp.w	r0, #4294967295
  4076fa:	4681      	mov	r9, r0
  4076fc:	9a01      	ldr	r2, [sp, #4]
  4076fe:	f000 8147 	beq.w	407990 <_malloc_r+0x4b4>
  407702:	4583      	cmp	fp, r0
  407704:	f200 80ee 	bhi.w	4078e4 <_malloc_r+0x408>
  407708:	4b43      	ldr	r3, [pc, #268]	; (407818 <_malloc_r+0x33c>)
  40770a:	6819      	ldr	r1, [r3, #0]
  40770c:	45cb      	cmp	fp, r9
  40770e:	4411      	add	r1, r2
  407710:	6019      	str	r1, [r3, #0]
  407712:	f000 8142 	beq.w	40799a <_malloc_r+0x4be>
  407716:	f8da 0000 	ldr.w	r0, [sl]
  40771a:	f8df e108 	ldr.w	lr, [pc, #264]	; 407824 <_malloc_r+0x348>
  40771e:	3001      	adds	r0, #1
  407720:	bf1b      	ittet	ne
  407722:	ebcb 0b09 	rsbne	fp, fp, r9
  407726:	4459      	addne	r1, fp
  407728:	f8ce 9000 	streq.w	r9, [lr]
  40772c:	6019      	strne	r1, [r3, #0]
  40772e:	f019 0107 	ands.w	r1, r9, #7
  407732:	f000 8107 	beq.w	407944 <_malloc_r+0x468>
  407736:	f1c1 0008 	rsb	r0, r1, #8
  40773a:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  40773e:	4481      	add	r9, r0
  407740:	3108      	adds	r1, #8
  407742:	444a      	add	r2, r9
  407744:	f3c2 020b 	ubfx	r2, r2, #0, #12
  407748:	ebc2 0a01 	rsb	sl, r2, r1
  40774c:	4651      	mov	r1, sl
  40774e:	4630      	mov	r0, r6
  407750:	9301      	str	r3, [sp, #4]
  407752:	f000 ff1d 	bl	408590 <_sbrk_r>
  407756:	1c43      	adds	r3, r0, #1
  407758:	9b01      	ldr	r3, [sp, #4]
  40775a:	f000 812c 	beq.w	4079b6 <_malloc_r+0x4da>
  40775e:	ebc9 0200 	rsb	r2, r9, r0
  407762:	4452      	add	r2, sl
  407764:	f042 0201 	orr.w	r2, r2, #1
  407768:	6819      	ldr	r1, [r3, #0]
  40776a:	f8c7 9008 	str.w	r9, [r7, #8]
  40776e:	4451      	add	r1, sl
  407770:	42bc      	cmp	r4, r7
  407772:	f8c9 2004 	str.w	r2, [r9, #4]
  407776:	6019      	str	r1, [r3, #0]
  407778:	f8df a09c 	ldr.w	sl, [pc, #156]	; 407818 <_malloc_r+0x33c>
  40777c:	d016      	beq.n	4077ac <_malloc_r+0x2d0>
  40777e:	f1b8 0f0f 	cmp.w	r8, #15
  407782:	f240 80ee 	bls.w	407962 <_malloc_r+0x486>
  407786:	6862      	ldr	r2, [r4, #4]
  407788:	f1a8 030c 	sub.w	r3, r8, #12
  40778c:	f023 0307 	bic.w	r3, r3, #7
  407790:	18e0      	adds	r0, r4, r3
  407792:	f002 0201 	and.w	r2, r2, #1
  407796:	f04f 0e05 	mov.w	lr, #5
  40779a:	431a      	orrs	r2, r3
  40779c:	2b0f      	cmp	r3, #15
  40779e:	6062      	str	r2, [r4, #4]
  4077a0:	f8c0 e004 	str.w	lr, [r0, #4]
  4077a4:	f8c0 e008 	str.w	lr, [r0, #8]
  4077a8:	f200 8109 	bhi.w	4079be <_malloc_r+0x4e2>
  4077ac:	4b1b      	ldr	r3, [pc, #108]	; (40781c <_malloc_r+0x340>)
  4077ae:	68bc      	ldr	r4, [r7, #8]
  4077b0:	681a      	ldr	r2, [r3, #0]
  4077b2:	4291      	cmp	r1, r2
  4077b4:	bf88      	it	hi
  4077b6:	6019      	strhi	r1, [r3, #0]
  4077b8:	4b19      	ldr	r3, [pc, #100]	; (407820 <_malloc_r+0x344>)
  4077ba:	681a      	ldr	r2, [r3, #0]
  4077bc:	4291      	cmp	r1, r2
  4077be:	6862      	ldr	r2, [r4, #4]
  4077c0:	bf88      	it	hi
  4077c2:	6019      	strhi	r1, [r3, #0]
  4077c4:	f022 0203 	bic.w	r2, r2, #3
  4077c8:	4295      	cmp	r5, r2
  4077ca:	eba2 0305 	sub.w	r3, r2, r5
  4077ce:	d801      	bhi.n	4077d4 <_malloc_r+0x2f8>
  4077d0:	2b0f      	cmp	r3, #15
  4077d2:	dc04      	bgt.n	4077de <_malloc_r+0x302>
  4077d4:	4630      	mov	r0, r6
  4077d6:	f000 f9c3 	bl	407b60 <__malloc_unlock>
  4077da:	2400      	movs	r4, #0
  4077dc:	e6aa      	b.n	407534 <_malloc_r+0x58>
  4077de:	1962      	adds	r2, r4, r5
  4077e0:	f043 0301 	orr.w	r3, r3, #1
  4077e4:	f045 0501 	orr.w	r5, r5, #1
  4077e8:	6065      	str	r5, [r4, #4]
  4077ea:	4630      	mov	r0, r6
  4077ec:	60ba      	str	r2, [r7, #8]
  4077ee:	6053      	str	r3, [r2, #4]
  4077f0:	f000 f9b6 	bl	407b60 <__malloc_unlock>
  4077f4:	3408      	adds	r4, #8
  4077f6:	4620      	mov	r0, r4
  4077f8:	b003      	add	sp, #12
  4077fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4077fe:	2814      	cmp	r0, #20
  407800:	d968      	bls.n	4078d4 <_malloc_r+0x3f8>
  407802:	2854      	cmp	r0, #84	; 0x54
  407804:	f200 8097 	bhi.w	407936 <_malloc_r+0x45a>
  407808:	0b28      	lsrs	r0, r5, #12
  40780a:	306e      	adds	r0, #110	; 0x6e
  40780c:	0041      	lsls	r1, r0, #1
  40780e:	e6a5      	b.n	40755c <_malloc_r+0x80>
  407810:	20000660 	.word	0x20000660
  407814:	200051e0 	.word	0x200051e0
  407818:	200051e4 	.word	0x200051e4
  40781c:	200051dc 	.word	0x200051dc
  407820:	200051d8 	.word	0x200051d8
  407824:	20000a6c 	.word	0x20000a6c
  407828:	0a5a      	lsrs	r2, r3, #9
  40782a:	2a04      	cmp	r2, #4
  40782c:	d955      	bls.n	4078da <_malloc_r+0x3fe>
  40782e:	2a14      	cmp	r2, #20
  407830:	f200 80a7 	bhi.w	407982 <_malloc_r+0x4a6>
  407834:	325b      	adds	r2, #91	; 0x5b
  407836:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40783a:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
  40783e:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 4079fc <_malloc_r+0x520>
  407842:	f8dc 1008 	ldr.w	r1, [ip, #8]
  407846:	4561      	cmp	r1, ip
  407848:	d07f      	beq.n	40794a <_malloc_r+0x46e>
  40784a:	684a      	ldr	r2, [r1, #4]
  40784c:	f022 0203 	bic.w	r2, r2, #3
  407850:	4293      	cmp	r3, r2
  407852:	d202      	bcs.n	40785a <_malloc_r+0x37e>
  407854:	6889      	ldr	r1, [r1, #8]
  407856:	458c      	cmp	ip, r1
  407858:	d1f7      	bne.n	40784a <_malloc_r+0x36e>
  40785a:	68ca      	ldr	r2, [r1, #12]
  40785c:	687b      	ldr	r3, [r7, #4]
  40785e:	60e2      	str	r2, [r4, #12]
  407860:	60a1      	str	r1, [r4, #8]
  407862:	6094      	str	r4, [r2, #8]
  407864:	60cc      	str	r4, [r1, #12]
  407866:	e6bb      	b.n	4075e0 <_malloc_r+0x104>
  407868:	1963      	adds	r3, r4, r5
  40786a:	f042 0701 	orr.w	r7, r2, #1
  40786e:	f045 0501 	orr.w	r5, r5, #1
  407872:	6065      	str	r5, [r4, #4]
  407874:	4630      	mov	r0, r6
  407876:	614b      	str	r3, [r1, #20]
  407878:	610b      	str	r3, [r1, #16]
  40787a:	f8c3 e00c 	str.w	lr, [r3, #12]
  40787e:	f8c3 e008 	str.w	lr, [r3, #8]
  407882:	605f      	str	r7, [r3, #4]
  407884:	509a      	str	r2, [r3, r2]
  407886:	3408      	adds	r4, #8
  407888:	f000 f96a 	bl	407b60 <__malloc_unlock>
  40788c:	e652      	b.n	407534 <_malloc_r+0x58>
  40788e:	684b      	ldr	r3, [r1, #4]
  407890:	e6a6      	b.n	4075e0 <_malloc_r+0x104>
  407892:	f109 0901 	add.w	r9, r9, #1
  407896:	f019 0f03 	tst.w	r9, #3
  40789a:	f10c 0c08 	add.w	ip, ip, #8
  40789e:	f47f aeb1 	bne.w	407604 <_malloc_r+0x128>
  4078a2:	e02c      	b.n	4078fe <_malloc_r+0x422>
  4078a4:	f104 0308 	add.w	r3, r4, #8
  4078a8:	6964      	ldr	r4, [r4, #20]
  4078aa:	42a3      	cmp	r3, r4
  4078ac:	bf08      	it	eq
  4078ae:	3002      	addeq	r0, #2
  4078b0:	f43f ae69 	beq.w	407586 <_malloc_r+0xaa>
  4078b4:	e62e      	b.n	407514 <_malloc_r+0x38>
  4078b6:	441a      	add	r2, r3
  4078b8:	461c      	mov	r4, r3
  4078ba:	6851      	ldr	r1, [r2, #4]
  4078bc:	68db      	ldr	r3, [r3, #12]
  4078be:	f854 5f08 	ldr.w	r5, [r4, #8]!
  4078c2:	f041 0101 	orr.w	r1, r1, #1
  4078c6:	6051      	str	r1, [r2, #4]
  4078c8:	4630      	mov	r0, r6
  4078ca:	60eb      	str	r3, [r5, #12]
  4078cc:	609d      	str	r5, [r3, #8]
  4078ce:	f000 f947 	bl	407b60 <__malloc_unlock>
  4078d2:	e62f      	b.n	407534 <_malloc_r+0x58>
  4078d4:	305b      	adds	r0, #91	; 0x5b
  4078d6:	0041      	lsls	r1, r0, #1
  4078d8:	e640      	b.n	40755c <_malloc_r+0x80>
  4078da:	099a      	lsrs	r2, r3, #6
  4078dc:	3238      	adds	r2, #56	; 0x38
  4078de:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  4078e2:	e7aa      	b.n	40783a <_malloc_r+0x35e>
  4078e4:	42bc      	cmp	r4, r7
  4078e6:	4b45      	ldr	r3, [pc, #276]	; (4079fc <_malloc_r+0x520>)
  4078e8:	f43f af0e 	beq.w	407708 <_malloc_r+0x22c>
  4078ec:	689c      	ldr	r4, [r3, #8]
  4078ee:	6862      	ldr	r2, [r4, #4]
  4078f0:	f022 0203 	bic.w	r2, r2, #3
  4078f4:	e768      	b.n	4077c8 <_malloc_r+0x2ec>
  4078f6:	f8d8 8000 	ldr.w	r8, [r8]
  4078fa:	4598      	cmp	r8, r3
  4078fc:	d17c      	bne.n	4079f8 <_malloc_r+0x51c>
  4078fe:	f010 0f03 	tst.w	r0, #3
  407902:	f1a8 0308 	sub.w	r3, r8, #8
  407906:	f100 30ff 	add.w	r0, r0, #4294967295
  40790a:	d1f4      	bne.n	4078f6 <_malloc_r+0x41a>
  40790c:	687b      	ldr	r3, [r7, #4]
  40790e:	ea23 0304 	bic.w	r3, r3, r4
  407912:	607b      	str	r3, [r7, #4]
  407914:	0064      	lsls	r4, r4, #1
  407916:	429c      	cmp	r4, r3
  407918:	f63f aeca 	bhi.w	4076b0 <_malloc_r+0x1d4>
  40791c:	2c00      	cmp	r4, #0
  40791e:	f43f aec7 	beq.w	4076b0 <_malloc_r+0x1d4>
  407922:	4223      	tst	r3, r4
  407924:	4648      	mov	r0, r9
  407926:	f47f ae69 	bne.w	4075fc <_malloc_r+0x120>
  40792a:	0064      	lsls	r4, r4, #1
  40792c:	4223      	tst	r3, r4
  40792e:	f100 0004 	add.w	r0, r0, #4
  407932:	d0fa      	beq.n	40792a <_malloc_r+0x44e>
  407934:	e662      	b.n	4075fc <_malloc_r+0x120>
  407936:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
  40793a:	d818      	bhi.n	40796e <_malloc_r+0x492>
  40793c:	0be8      	lsrs	r0, r5, #15
  40793e:	3077      	adds	r0, #119	; 0x77
  407940:	0041      	lsls	r1, r0, #1
  407942:	e60b      	b.n	40755c <_malloc_r+0x80>
  407944:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  407948:	e6fb      	b.n	407742 <_malloc_r+0x266>
  40794a:	f8d8 3004 	ldr.w	r3, [r8, #4]
  40794e:	1092      	asrs	r2, r2, #2
  407950:	f04f 0c01 	mov.w	ip, #1
  407954:	fa0c f202 	lsl.w	r2, ip, r2
  407958:	4313      	orrs	r3, r2
  40795a:	f8c8 3004 	str.w	r3, [r8, #4]
  40795e:	460a      	mov	r2, r1
  407960:	e77d      	b.n	40785e <_malloc_r+0x382>
  407962:	2301      	movs	r3, #1
  407964:	f8c9 3004 	str.w	r3, [r9, #4]
  407968:	464c      	mov	r4, r9
  40796a:	2200      	movs	r2, #0
  40796c:	e72c      	b.n	4077c8 <_malloc_r+0x2ec>
  40796e:	f240 5354 	movw	r3, #1364	; 0x554
  407972:	4298      	cmp	r0, r3
  407974:	d81c      	bhi.n	4079b0 <_malloc_r+0x4d4>
  407976:	0ca8      	lsrs	r0, r5, #18
  407978:	307c      	adds	r0, #124	; 0x7c
  40797a:	0041      	lsls	r1, r0, #1
  40797c:	e5ee      	b.n	40755c <_malloc_r+0x80>
  40797e:	3210      	adds	r2, #16
  407980:	e6b4      	b.n	4076ec <_malloc_r+0x210>
  407982:	2a54      	cmp	r2, #84	; 0x54
  407984:	d823      	bhi.n	4079ce <_malloc_r+0x4f2>
  407986:	0b1a      	lsrs	r2, r3, #12
  407988:	326e      	adds	r2, #110	; 0x6e
  40798a:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40798e:	e754      	b.n	40783a <_malloc_r+0x35e>
  407990:	68bc      	ldr	r4, [r7, #8]
  407992:	6862      	ldr	r2, [r4, #4]
  407994:	f022 0203 	bic.w	r2, r2, #3
  407998:	e716      	b.n	4077c8 <_malloc_r+0x2ec>
  40799a:	f3cb 000b 	ubfx	r0, fp, #0, #12
  40799e:	2800      	cmp	r0, #0
  4079a0:	f47f aeb9 	bne.w	407716 <_malloc_r+0x23a>
  4079a4:	4442      	add	r2, r8
  4079a6:	68bb      	ldr	r3, [r7, #8]
  4079a8:	f042 0201 	orr.w	r2, r2, #1
  4079ac:	605a      	str	r2, [r3, #4]
  4079ae:	e6fd      	b.n	4077ac <_malloc_r+0x2d0>
  4079b0:	21fc      	movs	r1, #252	; 0xfc
  4079b2:	207e      	movs	r0, #126	; 0x7e
  4079b4:	e5d2      	b.n	40755c <_malloc_r+0x80>
  4079b6:	2201      	movs	r2, #1
  4079b8:	f04f 0a00 	mov.w	sl, #0
  4079bc:	e6d4      	b.n	407768 <_malloc_r+0x28c>
  4079be:	f104 0108 	add.w	r1, r4, #8
  4079c2:	4630      	mov	r0, r6
  4079c4:	f7ff fcae 	bl	407324 <_free_r>
  4079c8:	f8da 1000 	ldr.w	r1, [sl]
  4079cc:	e6ee      	b.n	4077ac <_malloc_r+0x2d0>
  4079ce:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  4079d2:	d804      	bhi.n	4079de <_malloc_r+0x502>
  4079d4:	0bda      	lsrs	r2, r3, #15
  4079d6:	3277      	adds	r2, #119	; 0x77
  4079d8:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  4079dc:	e72d      	b.n	40783a <_malloc_r+0x35e>
  4079de:	f240 5154 	movw	r1, #1364	; 0x554
  4079e2:	428a      	cmp	r2, r1
  4079e4:	d804      	bhi.n	4079f0 <_malloc_r+0x514>
  4079e6:	0c9a      	lsrs	r2, r3, #18
  4079e8:	327c      	adds	r2, #124	; 0x7c
  4079ea:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  4079ee:	e724      	b.n	40783a <_malloc_r+0x35e>
  4079f0:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
  4079f4:	227e      	movs	r2, #126	; 0x7e
  4079f6:	e720      	b.n	40783a <_malloc_r+0x35e>
  4079f8:	687b      	ldr	r3, [r7, #4]
  4079fa:	e78b      	b.n	407914 <_malloc_r+0x438>
  4079fc:	20000660 	.word	0x20000660

00407a00 <memchr>:
  407a00:	0783      	lsls	r3, r0, #30
  407a02:	b470      	push	{r4, r5, r6}
  407a04:	b2c9      	uxtb	r1, r1
  407a06:	d040      	beq.n	407a8a <memchr+0x8a>
  407a08:	1e54      	subs	r4, r2, #1
  407a0a:	2a00      	cmp	r2, #0
  407a0c:	d03f      	beq.n	407a8e <memchr+0x8e>
  407a0e:	7803      	ldrb	r3, [r0, #0]
  407a10:	428b      	cmp	r3, r1
  407a12:	bf18      	it	ne
  407a14:	1c43      	addne	r3, r0, #1
  407a16:	d106      	bne.n	407a26 <memchr+0x26>
  407a18:	e01d      	b.n	407a56 <memchr+0x56>
  407a1a:	b1f4      	cbz	r4, 407a5a <memchr+0x5a>
  407a1c:	7802      	ldrb	r2, [r0, #0]
  407a1e:	428a      	cmp	r2, r1
  407a20:	f104 34ff 	add.w	r4, r4, #4294967295
  407a24:	d017      	beq.n	407a56 <memchr+0x56>
  407a26:	f013 0f03 	tst.w	r3, #3
  407a2a:	4618      	mov	r0, r3
  407a2c:	f103 0301 	add.w	r3, r3, #1
  407a30:	d1f3      	bne.n	407a1a <memchr+0x1a>
  407a32:	2c03      	cmp	r4, #3
  407a34:	d814      	bhi.n	407a60 <memchr+0x60>
  407a36:	b184      	cbz	r4, 407a5a <memchr+0x5a>
  407a38:	7803      	ldrb	r3, [r0, #0]
  407a3a:	428b      	cmp	r3, r1
  407a3c:	d00b      	beq.n	407a56 <memchr+0x56>
  407a3e:	1905      	adds	r5, r0, r4
  407a40:	1c43      	adds	r3, r0, #1
  407a42:	e002      	b.n	407a4a <memchr+0x4a>
  407a44:	7802      	ldrb	r2, [r0, #0]
  407a46:	428a      	cmp	r2, r1
  407a48:	d005      	beq.n	407a56 <memchr+0x56>
  407a4a:	42ab      	cmp	r3, r5
  407a4c:	4618      	mov	r0, r3
  407a4e:	f103 0301 	add.w	r3, r3, #1
  407a52:	d1f7      	bne.n	407a44 <memchr+0x44>
  407a54:	2000      	movs	r0, #0
  407a56:	bc70      	pop	{r4, r5, r6}
  407a58:	4770      	bx	lr
  407a5a:	4620      	mov	r0, r4
  407a5c:	bc70      	pop	{r4, r5, r6}
  407a5e:	4770      	bx	lr
  407a60:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
  407a64:	4602      	mov	r2, r0
  407a66:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
  407a6a:	4610      	mov	r0, r2
  407a6c:	3204      	adds	r2, #4
  407a6e:	6803      	ldr	r3, [r0, #0]
  407a70:	4073      	eors	r3, r6
  407a72:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
  407a76:	ea25 0303 	bic.w	r3, r5, r3
  407a7a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  407a7e:	d1da      	bne.n	407a36 <memchr+0x36>
  407a80:	3c04      	subs	r4, #4
  407a82:	2c03      	cmp	r4, #3
  407a84:	4610      	mov	r0, r2
  407a86:	d8f0      	bhi.n	407a6a <memchr+0x6a>
  407a88:	e7d5      	b.n	407a36 <memchr+0x36>
  407a8a:	4614      	mov	r4, r2
  407a8c:	e7d1      	b.n	407a32 <memchr+0x32>
  407a8e:	4610      	mov	r0, r2
  407a90:	e7e1      	b.n	407a56 <memchr+0x56>
  407a92:	bf00      	nop

00407a94 <memmove>:
  407a94:	4288      	cmp	r0, r1
  407a96:	b5f0      	push	{r4, r5, r6, r7, lr}
  407a98:	d90d      	bls.n	407ab6 <memmove+0x22>
  407a9a:	188b      	adds	r3, r1, r2
  407a9c:	4298      	cmp	r0, r3
  407a9e:	d20a      	bcs.n	407ab6 <memmove+0x22>
  407aa0:	1881      	adds	r1, r0, r2
  407aa2:	2a00      	cmp	r2, #0
  407aa4:	d054      	beq.n	407b50 <memmove+0xbc>
  407aa6:	1a9a      	subs	r2, r3, r2
  407aa8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  407aac:	f801 4d01 	strb.w	r4, [r1, #-1]!
  407ab0:	4293      	cmp	r3, r2
  407ab2:	d1f9      	bne.n	407aa8 <memmove+0x14>
  407ab4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407ab6:	2a0f      	cmp	r2, #15
  407ab8:	d948      	bls.n	407b4c <memmove+0xb8>
  407aba:	ea40 0301 	orr.w	r3, r0, r1
  407abe:	079b      	lsls	r3, r3, #30
  407ac0:	d147      	bne.n	407b52 <memmove+0xbe>
  407ac2:	f100 0410 	add.w	r4, r0, #16
  407ac6:	f101 0310 	add.w	r3, r1, #16
  407aca:	4615      	mov	r5, r2
  407acc:	f853 6c10 	ldr.w	r6, [r3, #-16]
  407ad0:	f844 6c10 	str.w	r6, [r4, #-16]
  407ad4:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  407ad8:	f844 6c0c 	str.w	r6, [r4, #-12]
  407adc:	f853 6c08 	ldr.w	r6, [r3, #-8]
  407ae0:	f844 6c08 	str.w	r6, [r4, #-8]
  407ae4:	3d10      	subs	r5, #16
  407ae6:	f853 6c04 	ldr.w	r6, [r3, #-4]
  407aea:	f844 6c04 	str.w	r6, [r4, #-4]
  407aee:	2d0f      	cmp	r5, #15
  407af0:	f103 0310 	add.w	r3, r3, #16
  407af4:	f104 0410 	add.w	r4, r4, #16
  407af8:	d8e8      	bhi.n	407acc <memmove+0x38>
  407afa:	f1a2 0310 	sub.w	r3, r2, #16
  407afe:	f023 030f 	bic.w	r3, r3, #15
  407b02:	f002 0e0f 	and.w	lr, r2, #15
  407b06:	3310      	adds	r3, #16
  407b08:	f1be 0f03 	cmp.w	lr, #3
  407b0c:	4419      	add	r1, r3
  407b0e:	4403      	add	r3, r0
  407b10:	d921      	bls.n	407b56 <memmove+0xc2>
  407b12:	1f1e      	subs	r6, r3, #4
  407b14:	460d      	mov	r5, r1
  407b16:	4674      	mov	r4, lr
  407b18:	3c04      	subs	r4, #4
  407b1a:	f855 7b04 	ldr.w	r7, [r5], #4
  407b1e:	f846 7f04 	str.w	r7, [r6, #4]!
  407b22:	2c03      	cmp	r4, #3
  407b24:	d8f8      	bhi.n	407b18 <memmove+0x84>
  407b26:	f1ae 0404 	sub.w	r4, lr, #4
  407b2a:	f024 0403 	bic.w	r4, r4, #3
  407b2e:	3404      	adds	r4, #4
  407b30:	4423      	add	r3, r4
  407b32:	4421      	add	r1, r4
  407b34:	f002 0203 	and.w	r2, r2, #3
  407b38:	b152      	cbz	r2, 407b50 <memmove+0xbc>
  407b3a:	3b01      	subs	r3, #1
  407b3c:	440a      	add	r2, r1
  407b3e:	f811 4b01 	ldrb.w	r4, [r1], #1
  407b42:	f803 4f01 	strb.w	r4, [r3, #1]!
  407b46:	4291      	cmp	r1, r2
  407b48:	d1f9      	bne.n	407b3e <memmove+0xaa>
  407b4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407b4c:	4603      	mov	r3, r0
  407b4e:	e7f3      	b.n	407b38 <memmove+0xa4>
  407b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407b52:	4603      	mov	r3, r0
  407b54:	e7f1      	b.n	407b3a <memmove+0xa6>
  407b56:	4672      	mov	r2, lr
  407b58:	e7ee      	b.n	407b38 <memmove+0xa4>
  407b5a:	bf00      	nop

00407b5c <__malloc_lock>:
  407b5c:	4770      	bx	lr
  407b5e:	bf00      	nop

00407b60 <__malloc_unlock>:
  407b60:	4770      	bx	lr
  407b62:	bf00      	nop

00407b64 <_Balloc>:
  407b64:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  407b66:	b570      	push	{r4, r5, r6, lr}
  407b68:	4605      	mov	r5, r0
  407b6a:	460c      	mov	r4, r1
  407b6c:	b14b      	cbz	r3, 407b82 <_Balloc+0x1e>
  407b6e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  407b72:	b180      	cbz	r0, 407b96 <_Balloc+0x32>
  407b74:	6802      	ldr	r2, [r0, #0]
  407b76:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  407b7a:	2300      	movs	r3, #0
  407b7c:	6103      	str	r3, [r0, #16]
  407b7e:	60c3      	str	r3, [r0, #12]
  407b80:	bd70      	pop	{r4, r5, r6, pc}
  407b82:	2104      	movs	r1, #4
  407b84:	2221      	movs	r2, #33	; 0x21
  407b86:	f000 fde9 	bl	40875c <_calloc_r>
  407b8a:	64e8      	str	r0, [r5, #76]	; 0x4c
  407b8c:	4603      	mov	r3, r0
  407b8e:	2800      	cmp	r0, #0
  407b90:	d1ed      	bne.n	407b6e <_Balloc+0xa>
  407b92:	2000      	movs	r0, #0
  407b94:	bd70      	pop	{r4, r5, r6, pc}
  407b96:	2101      	movs	r1, #1
  407b98:	fa01 f604 	lsl.w	r6, r1, r4
  407b9c:	1d72      	adds	r2, r6, #5
  407b9e:	4628      	mov	r0, r5
  407ba0:	0092      	lsls	r2, r2, #2
  407ba2:	f000 fddb 	bl	40875c <_calloc_r>
  407ba6:	2800      	cmp	r0, #0
  407ba8:	d0f3      	beq.n	407b92 <_Balloc+0x2e>
  407baa:	6044      	str	r4, [r0, #4]
  407bac:	6086      	str	r6, [r0, #8]
  407bae:	e7e4      	b.n	407b7a <_Balloc+0x16>

00407bb0 <_Bfree>:
  407bb0:	b131      	cbz	r1, 407bc0 <_Bfree+0x10>
  407bb2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  407bb4:	684a      	ldr	r2, [r1, #4]
  407bb6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  407bba:	6008      	str	r0, [r1, #0]
  407bbc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  407bc0:	4770      	bx	lr
  407bc2:	bf00      	nop

00407bc4 <__multadd>:
  407bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  407bc6:	690c      	ldr	r4, [r1, #16]
  407bc8:	b083      	sub	sp, #12
  407bca:	460d      	mov	r5, r1
  407bcc:	4606      	mov	r6, r0
  407bce:	f101 0e14 	add.w	lr, r1, #20
  407bd2:	2700      	movs	r7, #0
  407bd4:	f8de 1000 	ldr.w	r1, [lr]
  407bd8:	b288      	uxth	r0, r1
  407bda:	0c09      	lsrs	r1, r1, #16
  407bdc:	fb02 3300 	mla	r3, r2, r0, r3
  407be0:	fb02 f101 	mul.w	r1, r2, r1
  407be4:	eb01 4113 	add.w	r1, r1, r3, lsr #16
  407be8:	3701      	adds	r7, #1
  407bea:	b29b      	uxth	r3, r3
  407bec:	eb03 4301 	add.w	r3, r3, r1, lsl #16
  407bf0:	42bc      	cmp	r4, r7
  407bf2:	f84e 3b04 	str.w	r3, [lr], #4
  407bf6:	ea4f 4311 	mov.w	r3, r1, lsr #16
  407bfa:	dceb      	bgt.n	407bd4 <__multadd+0x10>
  407bfc:	b13b      	cbz	r3, 407c0e <__multadd+0x4a>
  407bfe:	68aa      	ldr	r2, [r5, #8]
  407c00:	4294      	cmp	r4, r2
  407c02:	da07      	bge.n	407c14 <__multadd+0x50>
  407c04:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  407c08:	3401      	adds	r4, #1
  407c0a:	6153      	str	r3, [r2, #20]
  407c0c:	612c      	str	r4, [r5, #16]
  407c0e:	4628      	mov	r0, r5
  407c10:	b003      	add	sp, #12
  407c12:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407c14:	6869      	ldr	r1, [r5, #4]
  407c16:	9301      	str	r3, [sp, #4]
  407c18:	3101      	adds	r1, #1
  407c1a:	4630      	mov	r0, r6
  407c1c:	f7ff ffa2 	bl	407b64 <_Balloc>
  407c20:	692a      	ldr	r2, [r5, #16]
  407c22:	3202      	adds	r2, #2
  407c24:	f105 010c 	add.w	r1, r5, #12
  407c28:	4607      	mov	r7, r0
  407c2a:	0092      	lsls	r2, r2, #2
  407c2c:	300c      	adds	r0, #12
  407c2e:	f7fc fc5d 	bl	4044ec <memcpy>
  407c32:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  407c34:	6869      	ldr	r1, [r5, #4]
  407c36:	9b01      	ldr	r3, [sp, #4]
  407c38:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  407c3c:	6028      	str	r0, [r5, #0]
  407c3e:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  407c42:	463d      	mov	r5, r7
  407c44:	e7de      	b.n	407c04 <__multadd+0x40>
  407c46:	bf00      	nop

00407c48 <__hi0bits>:
  407c48:	0c03      	lsrs	r3, r0, #16
  407c4a:	041b      	lsls	r3, r3, #16
  407c4c:	b9b3      	cbnz	r3, 407c7c <__hi0bits+0x34>
  407c4e:	0400      	lsls	r0, r0, #16
  407c50:	2310      	movs	r3, #16
  407c52:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
  407c56:	bf04      	itt	eq
  407c58:	0200      	lsleq	r0, r0, #8
  407c5a:	3308      	addeq	r3, #8
  407c5c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
  407c60:	bf04      	itt	eq
  407c62:	0100      	lsleq	r0, r0, #4
  407c64:	3304      	addeq	r3, #4
  407c66:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
  407c6a:	bf04      	itt	eq
  407c6c:	0080      	lsleq	r0, r0, #2
  407c6e:	3302      	addeq	r3, #2
  407c70:	2800      	cmp	r0, #0
  407c72:	db07      	blt.n	407c84 <__hi0bits+0x3c>
  407c74:	0042      	lsls	r2, r0, #1
  407c76:	d403      	bmi.n	407c80 <__hi0bits+0x38>
  407c78:	2020      	movs	r0, #32
  407c7a:	4770      	bx	lr
  407c7c:	2300      	movs	r3, #0
  407c7e:	e7e8      	b.n	407c52 <__hi0bits+0xa>
  407c80:	1c58      	adds	r0, r3, #1
  407c82:	4770      	bx	lr
  407c84:	4618      	mov	r0, r3
  407c86:	4770      	bx	lr

00407c88 <__lo0bits>:
  407c88:	6803      	ldr	r3, [r0, #0]
  407c8a:	f013 0207 	ands.w	r2, r3, #7
  407c8e:	d007      	beq.n	407ca0 <__lo0bits+0x18>
  407c90:	07d9      	lsls	r1, r3, #31
  407c92:	d420      	bmi.n	407cd6 <__lo0bits+0x4e>
  407c94:	079a      	lsls	r2, r3, #30
  407c96:	d420      	bmi.n	407cda <__lo0bits+0x52>
  407c98:	089b      	lsrs	r3, r3, #2
  407c9a:	6003      	str	r3, [r0, #0]
  407c9c:	2002      	movs	r0, #2
  407c9e:	4770      	bx	lr
  407ca0:	b299      	uxth	r1, r3
  407ca2:	b909      	cbnz	r1, 407ca8 <__lo0bits+0x20>
  407ca4:	0c1b      	lsrs	r3, r3, #16
  407ca6:	2210      	movs	r2, #16
  407ca8:	f013 0fff 	tst.w	r3, #255	; 0xff
  407cac:	bf04      	itt	eq
  407cae:	0a1b      	lsreq	r3, r3, #8
  407cb0:	3208      	addeq	r2, #8
  407cb2:	0719      	lsls	r1, r3, #28
  407cb4:	bf04      	itt	eq
  407cb6:	091b      	lsreq	r3, r3, #4
  407cb8:	3204      	addeq	r2, #4
  407cba:	0799      	lsls	r1, r3, #30
  407cbc:	bf04      	itt	eq
  407cbe:	089b      	lsreq	r3, r3, #2
  407cc0:	3202      	addeq	r2, #2
  407cc2:	07d9      	lsls	r1, r3, #31
  407cc4:	d404      	bmi.n	407cd0 <__lo0bits+0x48>
  407cc6:	085b      	lsrs	r3, r3, #1
  407cc8:	d101      	bne.n	407cce <__lo0bits+0x46>
  407cca:	2020      	movs	r0, #32
  407ccc:	4770      	bx	lr
  407cce:	3201      	adds	r2, #1
  407cd0:	6003      	str	r3, [r0, #0]
  407cd2:	4610      	mov	r0, r2
  407cd4:	4770      	bx	lr
  407cd6:	2000      	movs	r0, #0
  407cd8:	4770      	bx	lr
  407cda:	085b      	lsrs	r3, r3, #1
  407cdc:	6003      	str	r3, [r0, #0]
  407cde:	2001      	movs	r0, #1
  407ce0:	4770      	bx	lr
  407ce2:	bf00      	nop

00407ce4 <__i2b>:
  407ce4:	b510      	push	{r4, lr}
  407ce6:	460c      	mov	r4, r1
  407ce8:	2101      	movs	r1, #1
  407cea:	f7ff ff3b 	bl	407b64 <_Balloc>
  407cee:	2201      	movs	r2, #1
  407cf0:	6144      	str	r4, [r0, #20]
  407cf2:	6102      	str	r2, [r0, #16]
  407cf4:	bd10      	pop	{r4, pc}
  407cf6:	bf00      	nop

00407cf8 <__multiply>:
  407cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  407cfc:	690f      	ldr	r7, [r1, #16]
  407cfe:	6916      	ldr	r6, [r2, #16]
  407d00:	42b7      	cmp	r7, r6
  407d02:	b083      	sub	sp, #12
  407d04:	460d      	mov	r5, r1
  407d06:	4614      	mov	r4, r2
  407d08:	f2c0 808d 	blt.w	407e26 <__multiply+0x12e>
  407d0c:	4633      	mov	r3, r6
  407d0e:	463e      	mov	r6, r7
  407d10:	461f      	mov	r7, r3
  407d12:	68ab      	ldr	r3, [r5, #8]
  407d14:	6869      	ldr	r1, [r5, #4]
  407d16:	eb06 0807 	add.w	r8, r6, r7
  407d1a:	4598      	cmp	r8, r3
  407d1c:	bfc8      	it	gt
  407d1e:	3101      	addgt	r1, #1
  407d20:	f7ff ff20 	bl	407b64 <_Balloc>
  407d24:	f100 0c14 	add.w	ip, r0, #20
  407d28:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
  407d2c:	45cc      	cmp	ip, r9
  407d2e:	9000      	str	r0, [sp, #0]
  407d30:	d205      	bcs.n	407d3e <__multiply+0x46>
  407d32:	4663      	mov	r3, ip
  407d34:	2100      	movs	r1, #0
  407d36:	f843 1b04 	str.w	r1, [r3], #4
  407d3a:	4599      	cmp	r9, r3
  407d3c:	d8fb      	bhi.n	407d36 <__multiply+0x3e>
  407d3e:	f104 0214 	add.w	r2, r4, #20
  407d42:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
  407d46:	f105 0314 	add.w	r3, r5, #20
  407d4a:	4552      	cmp	r2, sl
  407d4c:	eb03 0e86 	add.w	lr, r3, r6, lsl #2
  407d50:	d254      	bcs.n	407dfc <__multiply+0x104>
  407d52:	f8cd 9004 	str.w	r9, [sp, #4]
  407d56:	4699      	mov	r9, r3
  407d58:	f852 3b04 	ldr.w	r3, [r2], #4
  407d5c:	fa1f fb83 	uxth.w	fp, r3
  407d60:	f1bb 0f00 	cmp.w	fp, #0
  407d64:	d020      	beq.n	407da8 <__multiply+0xb0>
  407d66:	2000      	movs	r0, #0
  407d68:	464f      	mov	r7, r9
  407d6a:	4666      	mov	r6, ip
  407d6c:	4605      	mov	r5, r0
  407d6e:	e000      	b.n	407d72 <__multiply+0x7a>
  407d70:	461e      	mov	r6, r3
  407d72:	f857 4b04 	ldr.w	r4, [r7], #4
  407d76:	6830      	ldr	r0, [r6, #0]
  407d78:	b2a1      	uxth	r1, r4
  407d7a:	b283      	uxth	r3, r0
  407d7c:	fb0b 3101 	mla	r1, fp, r1, r3
  407d80:	0c24      	lsrs	r4, r4, #16
  407d82:	0c00      	lsrs	r0, r0, #16
  407d84:	194b      	adds	r3, r1, r5
  407d86:	fb0b 0004 	mla	r0, fp, r4, r0
  407d8a:	eb00 4013 	add.w	r0, r0, r3, lsr #16
  407d8e:	b299      	uxth	r1, r3
  407d90:	4633      	mov	r3, r6
  407d92:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
  407d96:	45be      	cmp	lr, r7
  407d98:	ea4f 4510 	mov.w	r5, r0, lsr #16
  407d9c:	f843 1b04 	str.w	r1, [r3], #4
  407da0:	d8e6      	bhi.n	407d70 <__multiply+0x78>
  407da2:	6075      	str	r5, [r6, #4]
  407da4:	f852 3c04 	ldr.w	r3, [r2, #-4]
  407da8:	ea5f 4b13 	movs.w	fp, r3, lsr #16
  407dac:	d020      	beq.n	407df0 <__multiply+0xf8>
  407dae:	f8dc 3000 	ldr.w	r3, [ip]
  407db2:	4667      	mov	r7, ip
  407db4:	4618      	mov	r0, r3
  407db6:	464d      	mov	r5, r9
  407db8:	2100      	movs	r1, #0
  407dba:	e000      	b.n	407dbe <__multiply+0xc6>
  407dbc:	4637      	mov	r7, r6
  407dbe:	882c      	ldrh	r4, [r5, #0]
  407dc0:	0c00      	lsrs	r0, r0, #16
  407dc2:	fb0b 0004 	mla	r0, fp, r4, r0
  407dc6:	4401      	add	r1, r0
  407dc8:	b29c      	uxth	r4, r3
  407dca:	463e      	mov	r6, r7
  407dcc:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
  407dd0:	f846 3b04 	str.w	r3, [r6], #4
  407dd4:	6878      	ldr	r0, [r7, #4]
  407dd6:	f855 4b04 	ldr.w	r4, [r5], #4
  407dda:	b283      	uxth	r3, r0
  407ddc:	0c24      	lsrs	r4, r4, #16
  407dde:	fb0b 3404 	mla	r4, fp, r4, r3
  407de2:	eb04 4311 	add.w	r3, r4, r1, lsr #16
  407de6:	45ae      	cmp	lr, r5
  407de8:	ea4f 4113 	mov.w	r1, r3, lsr #16
  407dec:	d8e6      	bhi.n	407dbc <__multiply+0xc4>
  407dee:	607b      	str	r3, [r7, #4]
  407df0:	4592      	cmp	sl, r2
  407df2:	f10c 0c04 	add.w	ip, ip, #4
  407df6:	d8af      	bhi.n	407d58 <__multiply+0x60>
  407df8:	f8dd 9004 	ldr.w	r9, [sp, #4]
  407dfc:	f1b8 0f00 	cmp.w	r8, #0
  407e00:	dd0b      	ble.n	407e1a <__multiply+0x122>
  407e02:	f859 3c04 	ldr.w	r3, [r9, #-4]
  407e06:	f1a9 0904 	sub.w	r9, r9, #4
  407e0a:	b11b      	cbz	r3, 407e14 <__multiply+0x11c>
  407e0c:	e005      	b.n	407e1a <__multiply+0x122>
  407e0e:	f859 3d04 	ldr.w	r3, [r9, #-4]!
  407e12:	b913      	cbnz	r3, 407e1a <__multiply+0x122>
  407e14:	f1b8 0801 	subs.w	r8, r8, #1
  407e18:	d1f9      	bne.n	407e0e <__multiply+0x116>
  407e1a:	9800      	ldr	r0, [sp, #0]
  407e1c:	f8c0 8010 	str.w	r8, [r0, #16]
  407e20:	b003      	add	sp, #12
  407e22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407e26:	4615      	mov	r5, r2
  407e28:	460c      	mov	r4, r1
  407e2a:	e772      	b.n	407d12 <__multiply+0x1a>

00407e2c <__pow5mult>:
  407e2c:	f012 0303 	ands.w	r3, r2, #3
  407e30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  407e34:	4614      	mov	r4, r2
  407e36:	4607      	mov	r7, r0
  407e38:	460e      	mov	r6, r1
  407e3a:	d12d      	bne.n	407e98 <__pow5mult+0x6c>
  407e3c:	10a4      	asrs	r4, r4, #2
  407e3e:	d01c      	beq.n	407e7a <__pow5mult+0x4e>
  407e40:	6cbd      	ldr	r5, [r7, #72]	; 0x48
  407e42:	b395      	cbz	r5, 407eaa <__pow5mult+0x7e>
  407e44:	07e3      	lsls	r3, r4, #31
  407e46:	f04f 0800 	mov.w	r8, #0
  407e4a:	d406      	bmi.n	407e5a <__pow5mult+0x2e>
  407e4c:	1064      	asrs	r4, r4, #1
  407e4e:	d014      	beq.n	407e7a <__pow5mult+0x4e>
  407e50:	6828      	ldr	r0, [r5, #0]
  407e52:	b1a8      	cbz	r0, 407e80 <__pow5mult+0x54>
  407e54:	4605      	mov	r5, r0
  407e56:	07e3      	lsls	r3, r4, #31
  407e58:	d5f8      	bpl.n	407e4c <__pow5mult+0x20>
  407e5a:	4638      	mov	r0, r7
  407e5c:	4631      	mov	r1, r6
  407e5e:	462a      	mov	r2, r5
  407e60:	f7ff ff4a 	bl	407cf8 <__multiply>
  407e64:	b1b6      	cbz	r6, 407e94 <__pow5mult+0x68>
  407e66:	6872      	ldr	r2, [r6, #4]
  407e68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  407e6a:	1064      	asrs	r4, r4, #1
  407e6c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  407e70:	6031      	str	r1, [r6, #0]
  407e72:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  407e76:	4606      	mov	r6, r0
  407e78:	d1ea      	bne.n	407e50 <__pow5mult+0x24>
  407e7a:	4630      	mov	r0, r6
  407e7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  407e80:	4629      	mov	r1, r5
  407e82:	462a      	mov	r2, r5
  407e84:	4638      	mov	r0, r7
  407e86:	f7ff ff37 	bl	407cf8 <__multiply>
  407e8a:	6028      	str	r0, [r5, #0]
  407e8c:	f8c0 8000 	str.w	r8, [r0]
  407e90:	4605      	mov	r5, r0
  407e92:	e7e0      	b.n	407e56 <__pow5mult+0x2a>
  407e94:	4606      	mov	r6, r0
  407e96:	e7d9      	b.n	407e4c <__pow5mult+0x20>
  407e98:	1e5a      	subs	r2, r3, #1
  407e9a:	4d0b      	ldr	r5, [pc, #44]	; (407ec8 <__pow5mult+0x9c>)
  407e9c:	2300      	movs	r3, #0
  407e9e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  407ea2:	f7ff fe8f 	bl	407bc4 <__multadd>
  407ea6:	4606      	mov	r6, r0
  407ea8:	e7c8      	b.n	407e3c <__pow5mult+0x10>
  407eaa:	2101      	movs	r1, #1
  407eac:	4638      	mov	r0, r7
  407eae:	f7ff fe59 	bl	407b64 <_Balloc>
  407eb2:	f240 2171 	movw	r1, #625	; 0x271
  407eb6:	2201      	movs	r2, #1
  407eb8:	2300      	movs	r3, #0
  407eba:	6141      	str	r1, [r0, #20]
  407ebc:	6102      	str	r2, [r0, #16]
  407ebe:	4605      	mov	r5, r0
  407ec0:	64b8      	str	r0, [r7, #72]	; 0x48
  407ec2:	6003      	str	r3, [r0, #0]
  407ec4:	e7be      	b.n	407e44 <__pow5mult+0x18>
  407ec6:	bf00      	nop
  407ec8:	0040b330 	.word	0x0040b330

00407ecc <__lshift>:
  407ecc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  407ed0:	690f      	ldr	r7, [r1, #16]
  407ed2:	688b      	ldr	r3, [r1, #8]
  407ed4:	ea4f 1962 	mov.w	r9, r2, asr #5
  407ed8:	444f      	add	r7, r9
  407eda:	1c7d      	adds	r5, r7, #1
  407edc:	429d      	cmp	r5, r3
  407ede:	460e      	mov	r6, r1
  407ee0:	4614      	mov	r4, r2
  407ee2:	6849      	ldr	r1, [r1, #4]
  407ee4:	4680      	mov	r8, r0
  407ee6:	dd04      	ble.n	407ef2 <__lshift+0x26>
  407ee8:	005b      	lsls	r3, r3, #1
  407eea:	429d      	cmp	r5, r3
  407eec:	f101 0101 	add.w	r1, r1, #1
  407ef0:	dcfa      	bgt.n	407ee8 <__lshift+0x1c>
  407ef2:	4640      	mov	r0, r8
  407ef4:	f7ff fe36 	bl	407b64 <_Balloc>
  407ef8:	f1b9 0f00 	cmp.w	r9, #0
  407efc:	f100 0114 	add.w	r1, r0, #20
  407f00:	dd09      	ble.n	407f16 <__lshift+0x4a>
  407f02:	2300      	movs	r3, #0
  407f04:	469e      	mov	lr, r3
  407f06:	460a      	mov	r2, r1
  407f08:	3301      	adds	r3, #1
  407f0a:	454b      	cmp	r3, r9
  407f0c:	f842 eb04 	str.w	lr, [r2], #4
  407f10:	d1fa      	bne.n	407f08 <__lshift+0x3c>
  407f12:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  407f16:	6932      	ldr	r2, [r6, #16]
  407f18:	f106 0314 	add.w	r3, r6, #20
  407f1c:	f014 0c1f 	ands.w	ip, r4, #31
  407f20:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
  407f24:	d01f      	beq.n	407f66 <__lshift+0x9a>
  407f26:	f1cc 0920 	rsb	r9, ip, #32
  407f2a:	2200      	movs	r2, #0
  407f2c:	681c      	ldr	r4, [r3, #0]
  407f2e:	fa04 f40c 	lsl.w	r4, r4, ip
  407f32:	4314      	orrs	r4, r2
  407f34:	468a      	mov	sl, r1
  407f36:	f841 4b04 	str.w	r4, [r1], #4
  407f3a:	f853 4b04 	ldr.w	r4, [r3], #4
  407f3e:	459e      	cmp	lr, r3
  407f40:	fa24 f209 	lsr.w	r2, r4, r9
  407f44:	d8f2      	bhi.n	407f2c <__lshift+0x60>
  407f46:	f8ca 2004 	str.w	r2, [sl, #4]
  407f4a:	b102      	cbz	r2, 407f4e <__lshift+0x82>
  407f4c:	1cbd      	adds	r5, r7, #2
  407f4e:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
  407f52:	6872      	ldr	r2, [r6, #4]
  407f54:	3d01      	subs	r5, #1
  407f56:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  407f5a:	6105      	str	r5, [r0, #16]
  407f5c:	6031      	str	r1, [r6, #0]
  407f5e:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  407f62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  407f66:	3904      	subs	r1, #4
  407f68:	f853 2b04 	ldr.w	r2, [r3], #4
  407f6c:	f841 2f04 	str.w	r2, [r1, #4]!
  407f70:	459e      	cmp	lr, r3
  407f72:	d8f9      	bhi.n	407f68 <__lshift+0x9c>
  407f74:	e7eb      	b.n	407f4e <__lshift+0x82>
  407f76:	bf00      	nop

00407f78 <__mcmp>:
  407f78:	6902      	ldr	r2, [r0, #16]
  407f7a:	690b      	ldr	r3, [r1, #16]
  407f7c:	1ad2      	subs	r2, r2, r3
  407f7e:	d113      	bne.n	407fa8 <__mcmp+0x30>
  407f80:	009b      	lsls	r3, r3, #2
  407f82:	3014      	adds	r0, #20
  407f84:	3114      	adds	r1, #20
  407f86:	4419      	add	r1, r3
  407f88:	b410      	push	{r4}
  407f8a:	4403      	add	r3, r0
  407f8c:	e001      	b.n	407f92 <__mcmp+0x1a>
  407f8e:	4298      	cmp	r0, r3
  407f90:	d20c      	bcs.n	407fac <__mcmp+0x34>
  407f92:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  407f96:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  407f9a:	4294      	cmp	r4, r2
  407f9c:	d0f7      	beq.n	407f8e <__mcmp+0x16>
  407f9e:	d309      	bcc.n	407fb4 <__mcmp+0x3c>
  407fa0:	2001      	movs	r0, #1
  407fa2:	f85d 4b04 	ldr.w	r4, [sp], #4
  407fa6:	4770      	bx	lr
  407fa8:	4610      	mov	r0, r2
  407faa:	4770      	bx	lr
  407fac:	2000      	movs	r0, #0
  407fae:	f85d 4b04 	ldr.w	r4, [sp], #4
  407fb2:	4770      	bx	lr
  407fb4:	f04f 30ff 	mov.w	r0, #4294967295
  407fb8:	f85d 4b04 	ldr.w	r4, [sp], #4
  407fbc:	4770      	bx	lr
  407fbe:	bf00      	nop

00407fc0 <__mdiff>:
  407fc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  407fc4:	460e      	mov	r6, r1
  407fc6:	4605      	mov	r5, r0
  407fc8:	4611      	mov	r1, r2
  407fca:	4630      	mov	r0, r6
  407fcc:	4614      	mov	r4, r2
  407fce:	f7ff ffd3 	bl	407f78 <__mcmp>
  407fd2:	1e07      	subs	r7, r0, #0
  407fd4:	d054      	beq.n	408080 <__mdiff+0xc0>
  407fd6:	db4d      	blt.n	408074 <__mdiff+0xb4>
  407fd8:	f04f 0800 	mov.w	r8, #0
  407fdc:	6871      	ldr	r1, [r6, #4]
  407fde:	4628      	mov	r0, r5
  407fe0:	f7ff fdc0 	bl	407b64 <_Balloc>
  407fe4:	6937      	ldr	r7, [r6, #16]
  407fe6:	6923      	ldr	r3, [r4, #16]
  407fe8:	f8c0 800c 	str.w	r8, [r0, #12]
  407fec:	3614      	adds	r6, #20
  407fee:	f104 0214 	add.w	r2, r4, #20
  407ff2:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
  407ff6:	f100 0514 	add.w	r5, r0, #20
  407ffa:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
  407ffe:	2300      	movs	r3, #0
  408000:	f856 8b04 	ldr.w	r8, [r6], #4
  408004:	f852 4b04 	ldr.w	r4, [r2], #4
  408008:	fa13 f388 	uxtah	r3, r3, r8
  40800c:	b2a1      	uxth	r1, r4
  40800e:	0c24      	lsrs	r4, r4, #16
  408010:	1a59      	subs	r1, r3, r1
  408012:	ebc4 4318 	rsb	r3, r4, r8, lsr #16
  408016:	eb03 4321 	add.w	r3, r3, r1, asr #16
  40801a:	b289      	uxth	r1, r1
  40801c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  408020:	4594      	cmp	ip, r2
  408022:	f845 1b04 	str.w	r1, [r5], #4
  408026:	ea4f 4323 	mov.w	r3, r3, asr #16
  40802a:	4634      	mov	r4, r6
  40802c:	d8e8      	bhi.n	408000 <__mdiff+0x40>
  40802e:	45b6      	cmp	lr, r6
  408030:	46ac      	mov	ip, r5
  408032:	d915      	bls.n	408060 <__mdiff+0xa0>
  408034:	f854 2b04 	ldr.w	r2, [r4], #4
  408038:	fa13 f182 	uxtah	r1, r3, r2
  40803c:	0c13      	lsrs	r3, r2, #16
  40803e:	eb03 4321 	add.w	r3, r3, r1, asr #16
  408042:	b289      	uxth	r1, r1
  408044:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
  408048:	45a6      	cmp	lr, r4
  40804a:	f845 1b04 	str.w	r1, [r5], #4
  40804e:	ea4f 4323 	mov.w	r3, r3, asr #16
  408052:	d8ef      	bhi.n	408034 <__mdiff+0x74>
  408054:	43f6      	mvns	r6, r6
  408056:	4476      	add	r6, lr
  408058:	f026 0503 	bic.w	r5, r6, #3
  40805c:	3504      	adds	r5, #4
  40805e:	4465      	add	r5, ip
  408060:	3d04      	subs	r5, #4
  408062:	b921      	cbnz	r1, 40806e <__mdiff+0xae>
  408064:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  408068:	3f01      	subs	r7, #1
  40806a:	2b00      	cmp	r3, #0
  40806c:	d0fa      	beq.n	408064 <__mdiff+0xa4>
  40806e:	6107      	str	r7, [r0, #16]
  408070:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408074:	4633      	mov	r3, r6
  408076:	f04f 0801 	mov.w	r8, #1
  40807a:	4626      	mov	r6, r4
  40807c:	461c      	mov	r4, r3
  40807e:	e7ad      	b.n	407fdc <__mdiff+0x1c>
  408080:	4628      	mov	r0, r5
  408082:	4639      	mov	r1, r7
  408084:	f7ff fd6e 	bl	407b64 <_Balloc>
  408088:	2301      	movs	r3, #1
  40808a:	6147      	str	r7, [r0, #20]
  40808c:	6103      	str	r3, [r0, #16]
  40808e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408092:	bf00      	nop

00408094 <__d2b>:
  408094:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  408098:	b082      	sub	sp, #8
  40809a:	2101      	movs	r1, #1
  40809c:	461c      	mov	r4, r3
  40809e:	f3c3 570a 	ubfx	r7, r3, #20, #11
  4080a2:	4615      	mov	r5, r2
  4080a4:	9e08      	ldr	r6, [sp, #32]
  4080a6:	f7ff fd5d 	bl	407b64 <_Balloc>
  4080aa:	f3c4 0413 	ubfx	r4, r4, #0, #20
  4080ae:	4680      	mov	r8, r0
  4080b0:	b10f      	cbz	r7, 4080b6 <__d2b+0x22>
  4080b2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  4080b6:	9401      	str	r4, [sp, #4]
  4080b8:	b31d      	cbz	r5, 408102 <__d2b+0x6e>
  4080ba:	a802      	add	r0, sp, #8
  4080bc:	f840 5d08 	str.w	r5, [r0, #-8]!
  4080c0:	f7ff fde2 	bl	407c88 <__lo0bits>
  4080c4:	2800      	cmp	r0, #0
  4080c6:	d134      	bne.n	408132 <__d2b+0x9e>
  4080c8:	e89d 000c 	ldmia.w	sp, {r2, r3}
  4080cc:	f8c8 2014 	str.w	r2, [r8, #20]
  4080d0:	2b00      	cmp	r3, #0
  4080d2:	bf14      	ite	ne
  4080d4:	2402      	movne	r4, #2
  4080d6:	2401      	moveq	r4, #1
  4080d8:	f8c8 3018 	str.w	r3, [r8, #24]
  4080dc:	f8c8 4010 	str.w	r4, [r8, #16]
  4080e0:	b9df      	cbnz	r7, 40811a <__d2b+0x86>
  4080e2:	eb08 0384 	add.w	r3, r8, r4, lsl #2
  4080e6:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  4080ea:	6030      	str	r0, [r6, #0]
  4080ec:	6918      	ldr	r0, [r3, #16]
  4080ee:	f7ff fdab 	bl	407c48 <__hi0bits>
  4080f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4080f4:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
  4080f8:	6018      	str	r0, [r3, #0]
  4080fa:	4640      	mov	r0, r8
  4080fc:	b002      	add	sp, #8
  4080fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408102:	a801      	add	r0, sp, #4
  408104:	f7ff fdc0 	bl	407c88 <__lo0bits>
  408108:	2401      	movs	r4, #1
  40810a:	9b01      	ldr	r3, [sp, #4]
  40810c:	f8c8 3014 	str.w	r3, [r8, #20]
  408110:	3020      	adds	r0, #32
  408112:	f8c8 4010 	str.w	r4, [r8, #16]
  408116:	2f00      	cmp	r7, #0
  408118:	d0e3      	beq.n	4080e2 <__d2b+0x4e>
  40811a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40811c:	f2a7 4733 	subw	r7, r7, #1075	; 0x433
  408120:	4407      	add	r7, r0
  408122:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  408126:	6037      	str	r7, [r6, #0]
  408128:	6018      	str	r0, [r3, #0]
  40812a:	4640      	mov	r0, r8
  40812c:	b002      	add	sp, #8
  40812e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408132:	e89d 000c 	ldmia.w	sp, {r2, r3}
  408136:	f1c0 0120 	rsb	r1, r0, #32
  40813a:	fa03 f101 	lsl.w	r1, r3, r1
  40813e:	430a      	orrs	r2, r1
  408140:	40c3      	lsrs	r3, r0
  408142:	9301      	str	r3, [sp, #4]
  408144:	f8c8 2014 	str.w	r2, [r8, #20]
  408148:	e7c2      	b.n	4080d0 <__d2b+0x3c>
  40814a:	bf00      	nop

0040814c <_realloc_r>:
  40814c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408150:	4617      	mov	r7, r2
  408152:	b083      	sub	sp, #12
  408154:	460e      	mov	r6, r1
  408156:	2900      	cmp	r1, #0
  408158:	f000 80e7 	beq.w	40832a <_realloc_r+0x1de>
  40815c:	4681      	mov	r9, r0
  40815e:	f107 050b 	add.w	r5, r7, #11
  408162:	f7ff fcfb 	bl	407b5c <__malloc_lock>
  408166:	f856 3c04 	ldr.w	r3, [r6, #-4]
  40816a:	2d16      	cmp	r5, #22
  40816c:	f023 0403 	bic.w	r4, r3, #3
  408170:	f1a6 0808 	sub.w	r8, r6, #8
  408174:	d84c      	bhi.n	408210 <_realloc_r+0xc4>
  408176:	2210      	movs	r2, #16
  408178:	4615      	mov	r5, r2
  40817a:	42af      	cmp	r7, r5
  40817c:	d84d      	bhi.n	40821a <_realloc_r+0xce>
  40817e:	4294      	cmp	r4, r2
  408180:	f280 8084 	bge.w	40828c <_realloc_r+0x140>
  408184:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 408534 <_realloc_r+0x3e8>
  408188:	f8db 0008 	ldr.w	r0, [fp, #8]
  40818c:	eb08 0104 	add.w	r1, r8, r4
  408190:	4288      	cmp	r0, r1
  408192:	f000 80d6 	beq.w	408342 <_realloc_r+0x1f6>
  408196:	6848      	ldr	r0, [r1, #4]
  408198:	f020 0e01 	bic.w	lr, r0, #1
  40819c:	448e      	add	lr, r1
  40819e:	f8de e004 	ldr.w	lr, [lr, #4]
  4081a2:	f01e 0f01 	tst.w	lr, #1
  4081a6:	d13f      	bne.n	408228 <_realloc_r+0xdc>
  4081a8:	f020 0003 	bic.w	r0, r0, #3
  4081ac:	4420      	add	r0, r4
  4081ae:	4290      	cmp	r0, r2
  4081b0:	f280 80c1 	bge.w	408336 <_realloc_r+0x1ea>
  4081b4:	07db      	lsls	r3, r3, #31
  4081b6:	f100 808f 	bmi.w	4082d8 <_realloc_r+0x18c>
  4081ba:	f856 3c08 	ldr.w	r3, [r6, #-8]
  4081be:	ebc3 0a08 	rsb	sl, r3, r8
  4081c2:	f8da 3004 	ldr.w	r3, [sl, #4]
  4081c6:	f023 0303 	bic.w	r3, r3, #3
  4081ca:	eb00 0e03 	add.w	lr, r0, r3
  4081ce:	4596      	cmp	lr, r2
  4081d0:	db34      	blt.n	40823c <_realloc_r+0xf0>
  4081d2:	68cb      	ldr	r3, [r1, #12]
  4081d4:	688a      	ldr	r2, [r1, #8]
  4081d6:	4657      	mov	r7, sl
  4081d8:	60d3      	str	r3, [r2, #12]
  4081da:	609a      	str	r2, [r3, #8]
  4081dc:	f857 1f08 	ldr.w	r1, [r7, #8]!
  4081e0:	f8da 300c 	ldr.w	r3, [sl, #12]
  4081e4:	60cb      	str	r3, [r1, #12]
  4081e6:	1f22      	subs	r2, r4, #4
  4081e8:	2a24      	cmp	r2, #36	; 0x24
  4081ea:	6099      	str	r1, [r3, #8]
  4081ec:	f200 8136 	bhi.w	40845c <_realloc_r+0x310>
  4081f0:	2a13      	cmp	r2, #19
  4081f2:	f240 80fd 	bls.w	4083f0 <_realloc_r+0x2a4>
  4081f6:	6833      	ldr	r3, [r6, #0]
  4081f8:	f8ca 3008 	str.w	r3, [sl, #8]
  4081fc:	6873      	ldr	r3, [r6, #4]
  4081fe:	f8ca 300c 	str.w	r3, [sl, #12]
  408202:	2a1b      	cmp	r2, #27
  408204:	f200 8140 	bhi.w	408488 <_realloc_r+0x33c>
  408208:	3608      	adds	r6, #8
  40820a:	f10a 0310 	add.w	r3, sl, #16
  40820e:	e0f0      	b.n	4083f2 <_realloc_r+0x2a6>
  408210:	f025 0507 	bic.w	r5, r5, #7
  408214:	2d00      	cmp	r5, #0
  408216:	462a      	mov	r2, r5
  408218:	daaf      	bge.n	40817a <_realloc_r+0x2e>
  40821a:	230c      	movs	r3, #12
  40821c:	2000      	movs	r0, #0
  40821e:	f8c9 3000 	str.w	r3, [r9]
  408222:	b003      	add	sp, #12
  408224:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408228:	07d9      	lsls	r1, r3, #31
  40822a:	d455      	bmi.n	4082d8 <_realloc_r+0x18c>
  40822c:	f856 3c08 	ldr.w	r3, [r6, #-8]
  408230:	ebc3 0a08 	rsb	sl, r3, r8
  408234:	f8da 3004 	ldr.w	r3, [sl, #4]
  408238:	f023 0303 	bic.w	r3, r3, #3
  40823c:	4423      	add	r3, r4
  40823e:	4293      	cmp	r3, r2
  408240:	db4a      	blt.n	4082d8 <_realloc_r+0x18c>
  408242:	4657      	mov	r7, sl
  408244:	f8da 100c 	ldr.w	r1, [sl, #12]
  408248:	f857 0f08 	ldr.w	r0, [r7, #8]!
  40824c:	1f22      	subs	r2, r4, #4
  40824e:	2a24      	cmp	r2, #36	; 0x24
  408250:	60c1      	str	r1, [r0, #12]
  408252:	6088      	str	r0, [r1, #8]
  408254:	f200 810e 	bhi.w	408474 <_realloc_r+0x328>
  408258:	2a13      	cmp	r2, #19
  40825a:	f240 8109 	bls.w	408470 <_realloc_r+0x324>
  40825e:	6831      	ldr	r1, [r6, #0]
  408260:	f8ca 1008 	str.w	r1, [sl, #8]
  408264:	6871      	ldr	r1, [r6, #4]
  408266:	f8ca 100c 	str.w	r1, [sl, #12]
  40826a:	2a1b      	cmp	r2, #27
  40826c:	f200 8121 	bhi.w	4084b2 <_realloc_r+0x366>
  408270:	3608      	adds	r6, #8
  408272:	f10a 0210 	add.w	r2, sl, #16
  408276:	6831      	ldr	r1, [r6, #0]
  408278:	6011      	str	r1, [r2, #0]
  40827a:	6871      	ldr	r1, [r6, #4]
  40827c:	6051      	str	r1, [r2, #4]
  40827e:	68b1      	ldr	r1, [r6, #8]
  408280:	6091      	str	r1, [r2, #8]
  408282:	461c      	mov	r4, r3
  408284:	f8da 3004 	ldr.w	r3, [sl, #4]
  408288:	463e      	mov	r6, r7
  40828a:	46d0      	mov	r8, sl
  40828c:	1b62      	subs	r2, r4, r5
  40828e:	2a0f      	cmp	r2, #15
  408290:	f003 0301 	and.w	r3, r3, #1
  408294:	d80e      	bhi.n	4082b4 <_realloc_r+0x168>
  408296:	4323      	orrs	r3, r4
  408298:	4444      	add	r4, r8
  40829a:	f8c8 3004 	str.w	r3, [r8, #4]
  40829e:	6863      	ldr	r3, [r4, #4]
  4082a0:	f043 0301 	orr.w	r3, r3, #1
  4082a4:	6063      	str	r3, [r4, #4]
  4082a6:	4648      	mov	r0, r9
  4082a8:	f7ff fc5a 	bl	407b60 <__malloc_unlock>
  4082ac:	4630      	mov	r0, r6
  4082ae:	b003      	add	sp, #12
  4082b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4082b4:	eb08 0105 	add.w	r1, r8, r5
  4082b8:	431d      	orrs	r5, r3
  4082ba:	f042 0301 	orr.w	r3, r2, #1
  4082be:	440a      	add	r2, r1
  4082c0:	f8c8 5004 	str.w	r5, [r8, #4]
  4082c4:	604b      	str	r3, [r1, #4]
  4082c6:	6853      	ldr	r3, [r2, #4]
  4082c8:	f043 0301 	orr.w	r3, r3, #1
  4082cc:	3108      	adds	r1, #8
  4082ce:	6053      	str	r3, [r2, #4]
  4082d0:	4648      	mov	r0, r9
  4082d2:	f7ff f827 	bl	407324 <_free_r>
  4082d6:	e7e6      	b.n	4082a6 <_realloc_r+0x15a>
  4082d8:	4639      	mov	r1, r7
  4082da:	4648      	mov	r0, r9
  4082dc:	f7ff f8fe 	bl	4074dc <_malloc_r>
  4082e0:	4607      	mov	r7, r0
  4082e2:	b1d8      	cbz	r0, 40831c <_realloc_r+0x1d0>
  4082e4:	f856 3c04 	ldr.w	r3, [r6, #-4]
  4082e8:	f023 0201 	bic.w	r2, r3, #1
  4082ec:	4442      	add	r2, r8
  4082ee:	f1a0 0108 	sub.w	r1, r0, #8
  4082f2:	4291      	cmp	r1, r2
  4082f4:	f000 80ac 	beq.w	408450 <_realloc_r+0x304>
  4082f8:	1f22      	subs	r2, r4, #4
  4082fa:	2a24      	cmp	r2, #36	; 0x24
  4082fc:	f200 8099 	bhi.w	408432 <_realloc_r+0x2e6>
  408300:	2a13      	cmp	r2, #19
  408302:	d86a      	bhi.n	4083da <_realloc_r+0x28e>
  408304:	4603      	mov	r3, r0
  408306:	4632      	mov	r2, r6
  408308:	6811      	ldr	r1, [r2, #0]
  40830a:	6019      	str	r1, [r3, #0]
  40830c:	6851      	ldr	r1, [r2, #4]
  40830e:	6059      	str	r1, [r3, #4]
  408310:	6892      	ldr	r2, [r2, #8]
  408312:	609a      	str	r2, [r3, #8]
  408314:	4631      	mov	r1, r6
  408316:	4648      	mov	r0, r9
  408318:	f7ff f804 	bl	407324 <_free_r>
  40831c:	4648      	mov	r0, r9
  40831e:	f7ff fc1f 	bl	407b60 <__malloc_unlock>
  408322:	4638      	mov	r0, r7
  408324:	b003      	add	sp, #12
  408326:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40832a:	4611      	mov	r1, r2
  40832c:	b003      	add	sp, #12
  40832e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408332:	f7ff b8d3 	b.w	4074dc <_malloc_r>
  408336:	68ca      	ldr	r2, [r1, #12]
  408338:	6889      	ldr	r1, [r1, #8]
  40833a:	4604      	mov	r4, r0
  40833c:	60ca      	str	r2, [r1, #12]
  40833e:	6091      	str	r1, [r2, #8]
  408340:	e7a4      	b.n	40828c <_realloc_r+0x140>
  408342:	6841      	ldr	r1, [r0, #4]
  408344:	f021 0103 	bic.w	r1, r1, #3
  408348:	4421      	add	r1, r4
  40834a:	f105 0010 	add.w	r0, r5, #16
  40834e:	4281      	cmp	r1, r0
  408350:	da5b      	bge.n	40840a <_realloc_r+0x2be>
  408352:	07db      	lsls	r3, r3, #31
  408354:	d4c0      	bmi.n	4082d8 <_realloc_r+0x18c>
  408356:	f856 3c08 	ldr.w	r3, [r6, #-8]
  40835a:	ebc3 0a08 	rsb	sl, r3, r8
  40835e:	f8da 3004 	ldr.w	r3, [sl, #4]
  408362:	f023 0303 	bic.w	r3, r3, #3
  408366:	eb01 0c03 	add.w	ip, r1, r3
  40836a:	4560      	cmp	r0, ip
  40836c:	f73f af66 	bgt.w	40823c <_realloc_r+0xf0>
  408370:	4657      	mov	r7, sl
  408372:	f8da 300c 	ldr.w	r3, [sl, #12]
  408376:	f857 1f08 	ldr.w	r1, [r7, #8]!
  40837a:	1f22      	subs	r2, r4, #4
  40837c:	2a24      	cmp	r2, #36	; 0x24
  40837e:	60cb      	str	r3, [r1, #12]
  408380:	6099      	str	r1, [r3, #8]
  408382:	f200 80b8 	bhi.w	4084f6 <_realloc_r+0x3aa>
  408386:	2a13      	cmp	r2, #19
  408388:	f240 80a9 	bls.w	4084de <_realloc_r+0x392>
  40838c:	6833      	ldr	r3, [r6, #0]
  40838e:	f8ca 3008 	str.w	r3, [sl, #8]
  408392:	6873      	ldr	r3, [r6, #4]
  408394:	f8ca 300c 	str.w	r3, [sl, #12]
  408398:	2a1b      	cmp	r2, #27
  40839a:	f200 80b5 	bhi.w	408508 <_realloc_r+0x3bc>
  40839e:	3608      	adds	r6, #8
  4083a0:	f10a 0310 	add.w	r3, sl, #16
  4083a4:	6832      	ldr	r2, [r6, #0]
  4083a6:	601a      	str	r2, [r3, #0]
  4083a8:	6872      	ldr	r2, [r6, #4]
  4083aa:	605a      	str	r2, [r3, #4]
  4083ac:	68b2      	ldr	r2, [r6, #8]
  4083ae:	609a      	str	r2, [r3, #8]
  4083b0:	eb0a 0205 	add.w	r2, sl, r5
  4083b4:	ebc5 030c 	rsb	r3, r5, ip
  4083b8:	f043 0301 	orr.w	r3, r3, #1
  4083bc:	f8cb 2008 	str.w	r2, [fp, #8]
  4083c0:	6053      	str	r3, [r2, #4]
  4083c2:	f8da 3004 	ldr.w	r3, [sl, #4]
  4083c6:	f003 0301 	and.w	r3, r3, #1
  4083ca:	431d      	orrs	r5, r3
  4083cc:	4648      	mov	r0, r9
  4083ce:	f8ca 5004 	str.w	r5, [sl, #4]
  4083d2:	f7ff fbc5 	bl	407b60 <__malloc_unlock>
  4083d6:	4638      	mov	r0, r7
  4083d8:	e769      	b.n	4082ae <_realloc_r+0x162>
  4083da:	6833      	ldr	r3, [r6, #0]
  4083dc:	6003      	str	r3, [r0, #0]
  4083de:	6873      	ldr	r3, [r6, #4]
  4083e0:	6043      	str	r3, [r0, #4]
  4083e2:	2a1b      	cmp	r2, #27
  4083e4:	d829      	bhi.n	40843a <_realloc_r+0x2ee>
  4083e6:	f100 0308 	add.w	r3, r0, #8
  4083ea:	f106 0208 	add.w	r2, r6, #8
  4083ee:	e78b      	b.n	408308 <_realloc_r+0x1bc>
  4083f0:	463b      	mov	r3, r7
  4083f2:	6832      	ldr	r2, [r6, #0]
  4083f4:	601a      	str	r2, [r3, #0]
  4083f6:	6872      	ldr	r2, [r6, #4]
  4083f8:	605a      	str	r2, [r3, #4]
  4083fa:	68b2      	ldr	r2, [r6, #8]
  4083fc:	609a      	str	r2, [r3, #8]
  4083fe:	463e      	mov	r6, r7
  408400:	4674      	mov	r4, lr
  408402:	f8da 3004 	ldr.w	r3, [sl, #4]
  408406:	46d0      	mov	r8, sl
  408408:	e740      	b.n	40828c <_realloc_r+0x140>
  40840a:	eb08 0205 	add.w	r2, r8, r5
  40840e:	1b4b      	subs	r3, r1, r5
  408410:	f043 0301 	orr.w	r3, r3, #1
  408414:	f8cb 2008 	str.w	r2, [fp, #8]
  408418:	6053      	str	r3, [r2, #4]
  40841a:	f856 3c04 	ldr.w	r3, [r6, #-4]
  40841e:	f003 0301 	and.w	r3, r3, #1
  408422:	431d      	orrs	r5, r3
  408424:	4648      	mov	r0, r9
  408426:	f846 5c04 	str.w	r5, [r6, #-4]
  40842a:	f7ff fb99 	bl	407b60 <__malloc_unlock>
  40842e:	4630      	mov	r0, r6
  408430:	e73d      	b.n	4082ae <_realloc_r+0x162>
  408432:	4631      	mov	r1, r6
  408434:	f7ff fb2e 	bl	407a94 <memmove>
  408438:	e76c      	b.n	408314 <_realloc_r+0x1c8>
  40843a:	68b3      	ldr	r3, [r6, #8]
  40843c:	6083      	str	r3, [r0, #8]
  40843e:	68f3      	ldr	r3, [r6, #12]
  408440:	60c3      	str	r3, [r0, #12]
  408442:	2a24      	cmp	r2, #36	; 0x24
  408444:	d02c      	beq.n	4084a0 <_realloc_r+0x354>
  408446:	f100 0310 	add.w	r3, r0, #16
  40844a:	f106 0210 	add.w	r2, r6, #16
  40844e:	e75b      	b.n	408308 <_realloc_r+0x1bc>
  408450:	f850 2c04 	ldr.w	r2, [r0, #-4]
  408454:	f022 0203 	bic.w	r2, r2, #3
  408458:	4414      	add	r4, r2
  40845a:	e717      	b.n	40828c <_realloc_r+0x140>
  40845c:	4631      	mov	r1, r6
  40845e:	4638      	mov	r0, r7
  408460:	4674      	mov	r4, lr
  408462:	463e      	mov	r6, r7
  408464:	f7ff fb16 	bl	407a94 <memmove>
  408468:	46d0      	mov	r8, sl
  40846a:	f8da 3004 	ldr.w	r3, [sl, #4]
  40846e:	e70d      	b.n	40828c <_realloc_r+0x140>
  408470:	463a      	mov	r2, r7
  408472:	e700      	b.n	408276 <_realloc_r+0x12a>
  408474:	4631      	mov	r1, r6
  408476:	4638      	mov	r0, r7
  408478:	461c      	mov	r4, r3
  40847a:	463e      	mov	r6, r7
  40847c:	f7ff fb0a 	bl	407a94 <memmove>
  408480:	46d0      	mov	r8, sl
  408482:	f8da 3004 	ldr.w	r3, [sl, #4]
  408486:	e701      	b.n	40828c <_realloc_r+0x140>
  408488:	68b3      	ldr	r3, [r6, #8]
  40848a:	f8ca 3010 	str.w	r3, [sl, #16]
  40848e:	68f3      	ldr	r3, [r6, #12]
  408490:	f8ca 3014 	str.w	r3, [sl, #20]
  408494:	2a24      	cmp	r2, #36	; 0x24
  408496:	d018      	beq.n	4084ca <_realloc_r+0x37e>
  408498:	3610      	adds	r6, #16
  40849a:	f10a 0318 	add.w	r3, sl, #24
  40849e:	e7a8      	b.n	4083f2 <_realloc_r+0x2a6>
  4084a0:	6933      	ldr	r3, [r6, #16]
  4084a2:	6103      	str	r3, [r0, #16]
  4084a4:	6973      	ldr	r3, [r6, #20]
  4084a6:	6143      	str	r3, [r0, #20]
  4084a8:	f106 0218 	add.w	r2, r6, #24
  4084ac:	f100 0318 	add.w	r3, r0, #24
  4084b0:	e72a      	b.n	408308 <_realloc_r+0x1bc>
  4084b2:	68b1      	ldr	r1, [r6, #8]
  4084b4:	f8ca 1010 	str.w	r1, [sl, #16]
  4084b8:	68f1      	ldr	r1, [r6, #12]
  4084ba:	f8ca 1014 	str.w	r1, [sl, #20]
  4084be:	2a24      	cmp	r2, #36	; 0x24
  4084c0:	d00f      	beq.n	4084e2 <_realloc_r+0x396>
  4084c2:	3610      	adds	r6, #16
  4084c4:	f10a 0218 	add.w	r2, sl, #24
  4084c8:	e6d5      	b.n	408276 <_realloc_r+0x12a>
  4084ca:	6933      	ldr	r3, [r6, #16]
  4084cc:	f8ca 3018 	str.w	r3, [sl, #24]
  4084d0:	6973      	ldr	r3, [r6, #20]
  4084d2:	f8ca 301c 	str.w	r3, [sl, #28]
  4084d6:	3618      	adds	r6, #24
  4084d8:	f10a 0320 	add.w	r3, sl, #32
  4084dc:	e789      	b.n	4083f2 <_realloc_r+0x2a6>
  4084de:	463b      	mov	r3, r7
  4084e0:	e760      	b.n	4083a4 <_realloc_r+0x258>
  4084e2:	6932      	ldr	r2, [r6, #16]
  4084e4:	f8ca 2018 	str.w	r2, [sl, #24]
  4084e8:	6972      	ldr	r2, [r6, #20]
  4084ea:	f8ca 201c 	str.w	r2, [sl, #28]
  4084ee:	3618      	adds	r6, #24
  4084f0:	f10a 0220 	add.w	r2, sl, #32
  4084f4:	e6bf      	b.n	408276 <_realloc_r+0x12a>
  4084f6:	4631      	mov	r1, r6
  4084f8:	4638      	mov	r0, r7
  4084fa:	f8cd c004 	str.w	ip, [sp, #4]
  4084fe:	f7ff fac9 	bl	407a94 <memmove>
  408502:	f8dd c004 	ldr.w	ip, [sp, #4]
  408506:	e753      	b.n	4083b0 <_realloc_r+0x264>
  408508:	68b3      	ldr	r3, [r6, #8]
  40850a:	f8ca 3010 	str.w	r3, [sl, #16]
  40850e:	68f3      	ldr	r3, [r6, #12]
  408510:	f8ca 3014 	str.w	r3, [sl, #20]
  408514:	2a24      	cmp	r2, #36	; 0x24
  408516:	d003      	beq.n	408520 <_realloc_r+0x3d4>
  408518:	3610      	adds	r6, #16
  40851a:	f10a 0318 	add.w	r3, sl, #24
  40851e:	e741      	b.n	4083a4 <_realloc_r+0x258>
  408520:	6933      	ldr	r3, [r6, #16]
  408522:	f8ca 3018 	str.w	r3, [sl, #24]
  408526:	6973      	ldr	r3, [r6, #20]
  408528:	f8ca 301c 	str.w	r3, [sl, #28]
  40852c:	3618      	adds	r6, #24
  40852e:	f10a 0320 	add.w	r3, sl, #32
  408532:	e737      	b.n	4083a4 <_realloc_r+0x258>
  408534:	20000660 	.word	0x20000660

00408538 <__fpclassifyd>:
  408538:	b410      	push	{r4}
  40853a:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
  40853e:	d008      	beq.n	408552 <__fpclassifyd+0x1a>
  408540:	4b11      	ldr	r3, [pc, #68]	; (408588 <__fpclassifyd+0x50>)
  408542:	f5a1 1280 	sub.w	r2, r1, #1048576	; 0x100000
  408546:	429a      	cmp	r2, r3
  408548:	d808      	bhi.n	40855c <__fpclassifyd+0x24>
  40854a:	2004      	movs	r0, #4
  40854c:	f85d 4b04 	ldr.w	r4, [sp], #4
  408550:	4770      	bx	lr
  408552:	b918      	cbnz	r0, 40855c <__fpclassifyd+0x24>
  408554:	2002      	movs	r0, #2
  408556:	f85d 4b04 	ldr.w	r4, [sp], #4
  40855a:	4770      	bx	lr
  40855c:	f101 41ff 	add.w	r1, r1, #2139095040	; 0x7f800000
  408560:	4b09      	ldr	r3, [pc, #36]	; (408588 <__fpclassifyd+0x50>)
  408562:	f501 01e0 	add.w	r1, r1, #7340032	; 0x700000
  408566:	4299      	cmp	r1, r3
  408568:	d9ef      	bls.n	40854a <__fpclassifyd+0x12>
  40856a:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  40856e:	d201      	bcs.n	408574 <__fpclassifyd+0x3c>
  408570:	2003      	movs	r0, #3
  408572:	e7eb      	b.n	40854c <__fpclassifyd+0x14>
  408574:	4b05      	ldr	r3, [pc, #20]	; (40858c <__fpclassifyd+0x54>)
  408576:	429c      	cmp	r4, r3
  408578:	d001      	beq.n	40857e <__fpclassifyd+0x46>
  40857a:	2000      	movs	r0, #0
  40857c:	e7e6      	b.n	40854c <__fpclassifyd+0x14>
  40857e:	fab0 f080 	clz	r0, r0
  408582:	0940      	lsrs	r0, r0, #5
  408584:	e7e2      	b.n	40854c <__fpclassifyd+0x14>
  408586:	bf00      	nop
  408588:	7fdfffff 	.word	0x7fdfffff
  40858c:	7ff00000 	.word	0x7ff00000

00408590 <_sbrk_r>:
  408590:	b538      	push	{r3, r4, r5, lr}
  408592:	4c07      	ldr	r4, [pc, #28]	; (4085b0 <_sbrk_r+0x20>)
  408594:	2300      	movs	r3, #0
  408596:	4605      	mov	r5, r0
  408598:	4608      	mov	r0, r1
  40859a:	6023      	str	r3, [r4, #0]
  40859c:	f7f9 f9d6 	bl	40194c <_sbrk>
  4085a0:	1c43      	adds	r3, r0, #1
  4085a2:	d000      	beq.n	4085a6 <_sbrk_r+0x16>
  4085a4:	bd38      	pop	{r3, r4, r5, pc}
  4085a6:	6823      	ldr	r3, [r4, #0]
  4085a8:	2b00      	cmp	r3, #0
  4085aa:	d0fb      	beq.n	4085a4 <_sbrk_r+0x14>
  4085ac:	602b      	str	r3, [r5, #0]
  4085ae:	bd38      	pop	{r3, r4, r5, pc}
  4085b0:	20005214 	.word	0x20005214

004085b4 <__ssprint_r>:
  4085b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4085b8:	6893      	ldr	r3, [r2, #8]
  4085ba:	f8d2 8000 	ldr.w	r8, [r2]
  4085be:	b083      	sub	sp, #12
  4085c0:	4691      	mov	r9, r2
  4085c2:	2b00      	cmp	r3, #0
  4085c4:	d072      	beq.n	4086ac <__ssprint_r+0xf8>
  4085c6:	4607      	mov	r7, r0
  4085c8:	f04f 0b00 	mov.w	fp, #0
  4085cc:	6808      	ldr	r0, [r1, #0]
  4085ce:	688b      	ldr	r3, [r1, #8]
  4085d0:	460d      	mov	r5, r1
  4085d2:	465c      	mov	r4, fp
  4085d4:	2c00      	cmp	r4, #0
  4085d6:	d045      	beq.n	408664 <__ssprint_r+0xb0>
  4085d8:	429c      	cmp	r4, r3
  4085da:	461e      	mov	r6, r3
  4085dc:	469a      	mov	sl, r3
  4085de:	d348      	bcc.n	408672 <__ssprint_r+0xbe>
  4085e0:	89ab      	ldrh	r3, [r5, #12]
  4085e2:	f413 6f90 	tst.w	r3, #1152	; 0x480
  4085e6:	d02d      	beq.n	408644 <__ssprint_r+0x90>
  4085e8:	696e      	ldr	r6, [r5, #20]
  4085ea:	6929      	ldr	r1, [r5, #16]
  4085ec:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  4085f0:	ebc1 0a00 	rsb	sl, r1, r0
  4085f4:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
  4085f8:	1c60      	adds	r0, r4, #1
  4085fa:	1076      	asrs	r6, r6, #1
  4085fc:	4450      	add	r0, sl
  4085fe:	4286      	cmp	r6, r0
  408600:	4632      	mov	r2, r6
  408602:	bf3c      	itt	cc
  408604:	4606      	movcc	r6, r0
  408606:	4632      	movcc	r2, r6
  408608:	055b      	lsls	r3, r3, #21
  40860a:	d535      	bpl.n	408678 <__ssprint_r+0xc4>
  40860c:	4611      	mov	r1, r2
  40860e:	4638      	mov	r0, r7
  408610:	f7fe ff64 	bl	4074dc <_malloc_r>
  408614:	2800      	cmp	r0, #0
  408616:	d039      	beq.n	40868c <__ssprint_r+0xd8>
  408618:	4652      	mov	r2, sl
  40861a:	6929      	ldr	r1, [r5, #16]
  40861c:	9001      	str	r0, [sp, #4]
  40861e:	f7fb ff65 	bl	4044ec <memcpy>
  408622:	89aa      	ldrh	r2, [r5, #12]
  408624:	9b01      	ldr	r3, [sp, #4]
  408626:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  40862a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  40862e:	81aa      	strh	r2, [r5, #12]
  408630:	ebca 0206 	rsb	r2, sl, r6
  408634:	eb03 000a 	add.w	r0, r3, sl
  408638:	616e      	str	r6, [r5, #20]
  40863a:	612b      	str	r3, [r5, #16]
  40863c:	6028      	str	r0, [r5, #0]
  40863e:	60aa      	str	r2, [r5, #8]
  408640:	4626      	mov	r6, r4
  408642:	46a2      	mov	sl, r4
  408644:	4652      	mov	r2, sl
  408646:	4659      	mov	r1, fp
  408648:	f7ff fa24 	bl	407a94 <memmove>
  40864c:	f8d9 2008 	ldr.w	r2, [r9, #8]
  408650:	68ab      	ldr	r3, [r5, #8]
  408652:	6828      	ldr	r0, [r5, #0]
  408654:	1b9b      	subs	r3, r3, r6
  408656:	4450      	add	r0, sl
  408658:	1b14      	subs	r4, r2, r4
  40865a:	60ab      	str	r3, [r5, #8]
  40865c:	6028      	str	r0, [r5, #0]
  40865e:	f8c9 4008 	str.w	r4, [r9, #8]
  408662:	b31c      	cbz	r4, 4086ac <__ssprint_r+0xf8>
  408664:	f8d8 b000 	ldr.w	fp, [r8]
  408668:	f8d8 4004 	ldr.w	r4, [r8, #4]
  40866c:	f108 0808 	add.w	r8, r8, #8
  408670:	e7b0      	b.n	4085d4 <__ssprint_r+0x20>
  408672:	4626      	mov	r6, r4
  408674:	46a2      	mov	sl, r4
  408676:	e7e5      	b.n	408644 <__ssprint_r+0x90>
  408678:	4638      	mov	r0, r7
  40867a:	f7ff fd67 	bl	40814c <_realloc_r>
  40867e:	4603      	mov	r3, r0
  408680:	2800      	cmp	r0, #0
  408682:	d1d5      	bne.n	408630 <__ssprint_r+0x7c>
  408684:	4638      	mov	r0, r7
  408686:	6929      	ldr	r1, [r5, #16]
  408688:	f7fe fe4c 	bl	407324 <_free_r>
  40868c:	230c      	movs	r3, #12
  40868e:	603b      	str	r3, [r7, #0]
  408690:	89ab      	ldrh	r3, [r5, #12]
  408692:	2200      	movs	r2, #0
  408694:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408698:	f04f 30ff 	mov.w	r0, #4294967295
  40869c:	81ab      	strh	r3, [r5, #12]
  40869e:	f8c9 2008 	str.w	r2, [r9, #8]
  4086a2:	f8c9 2004 	str.w	r2, [r9, #4]
  4086a6:	b003      	add	sp, #12
  4086a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4086ac:	2000      	movs	r0, #0
  4086ae:	f8c9 0004 	str.w	r0, [r9, #4]
  4086b2:	b003      	add	sp, #12
  4086b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

004086b8 <__register_exitproc>:
  4086b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4086bc:	4c25      	ldr	r4, [pc, #148]	; (408754 <__register_exitproc+0x9c>)
  4086be:	6825      	ldr	r5, [r4, #0]
  4086c0:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
  4086c4:	4606      	mov	r6, r0
  4086c6:	4688      	mov	r8, r1
  4086c8:	4692      	mov	sl, r2
  4086ca:	4699      	mov	r9, r3
  4086cc:	b3cc      	cbz	r4, 408742 <__register_exitproc+0x8a>
  4086ce:	6860      	ldr	r0, [r4, #4]
  4086d0:	281f      	cmp	r0, #31
  4086d2:	dc18      	bgt.n	408706 <__register_exitproc+0x4e>
  4086d4:	1c43      	adds	r3, r0, #1
  4086d6:	b17e      	cbz	r6, 4086f8 <__register_exitproc+0x40>
  4086d8:	eb04 0580 	add.w	r5, r4, r0, lsl #2
  4086dc:	2101      	movs	r1, #1
  4086de:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
  4086e2:	f8d4 7188 	ldr.w	r7, [r4, #392]	; 0x188
  4086e6:	fa01 f200 	lsl.w	r2, r1, r0
  4086ea:	4317      	orrs	r7, r2
  4086ec:	2e02      	cmp	r6, #2
  4086ee:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  4086f2:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
  4086f6:	d01e      	beq.n	408736 <__register_exitproc+0x7e>
  4086f8:	3002      	adds	r0, #2
  4086fa:	6063      	str	r3, [r4, #4]
  4086fc:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
  408700:	2000      	movs	r0, #0
  408702:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408706:	4b14      	ldr	r3, [pc, #80]	; (408758 <__register_exitproc+0xa0>)
  408708:	b303      	cbz	r3, 40874c <__register_exitproc+0x94>
  40870a:	f44f 70c8 	mov.w	r0, #400	; 0x190
  40870e:	f3af 8000 	nop.w
  408712:	4604      	mov	r4, r0
  408714:	b1d0      	cbz	r0, 40874c <__register_exitproc+0x94>
  408716:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
  40871a:	2700      	movs	r7, #0
  40871c:	e880 0088 	stmia.w	r0, {r3, r7}
  408720:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  408724:	4638      	mov	r0, r7
  408726:	2301      	movs	r3, #1
  408728:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
  40872c:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
  408730:	2e00      	cmp	r6, #0
  408732:	d0e1      	beq.n	4086f8 <__register_exitproc+0x40>
  408734:	e7d0      	b.n	4086d8 <__register_exitproc+0x20>
  408736:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
  40873a:	430a      	orrs	r2, r1
  40873c:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  408740:	e7da      	b.n	4086f8 <__register_exitproc+0x40>
  408742:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
  408746:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
  40874a:	e7c0      	b.n	4086ce <__register_exitproc+0x16>
  40874c:	f04f 30ff 	mov.w	r0, #4294967295
  408750:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  408754:	0040b0e0 	.word	0x0040b0e0
  408758:	00000000 	.word	0x00000000

0040875c <_calloc_r>:
  40875c:	b510      	push	{r4, lr}
  40875e:	fb02 f101 	mul.w	r1, r2, r1
  408762:	f7fe febb 	bl	4074dc <_malloc_r>
  408766:	4604      	mov	r4, r0
  408768:	b168      	cbz	r0, 408786 <_calloc_r+0x2a>
  40876a:	f850 2c04 	ldr.w	r2, [r0, #-4]
  40876e:	f022 0203 	bic.w	r2, r2, #3
  408772:	3a04      	subs	r2, #4
  408774:	2a24      	cmp	r2, #36	; 0x24
  408776:	d818      	bhi.n	4087aa <_calloc_r+0x4e>
  408778:	2a13      	cmp	r2, #19
  40877a:	d806      	bhi.n	40878a <_calloc_r+0x2e>
  40877c:	4603      	mov	r3, r0
  40877e:	2200      	movs	r2, #0
  408780:	601a      	str	r2, [r3, #0]
  408782:	605a      	str	r2, [r3, #4]
  408784:	609a      	str	r2, [r3, #8]
  408786:	4620      	mov	r0, r4
  408788:	bd10      	pop	{r4, pc}
  40878a:	2300      	movs	r3, #0
  40878c:	2a1b      	cmp	r2, #27
  40878e:	6003      	str	r3, [r0, #0]
  408790:	6043      	str	r3, [r0, #4]
  408792:	d90f      	bls.n	4087b4 <_calloc_r+0x58>
  408794:	2a24      	cmp	r2, #36	; 0x24
  408796:	6083      	str	r3, [r0, #8]
  408798:	60c3      	str	r3, [r0, #12]
  40879a:	bf05      	ittet	eq
  40879c:	6103      	streq	r3, [r0, #16]
  40879e:	6143      	streq	r3, [r0, #20]
  4087a0:	f100 0310 	addne.w	r3, r0, #16
  4087a4:	f100 0318 	addeq.w	r3, r0, #24
  4087a8:	e7e9      	b.n	40877e <_calloc_r+0x22>
  4087aa:	2100      	movs	r1, #0
  4087ac:	f7fb ff38 	bl	404620 <memset>
  4087b0:	4620      	mov	r0, r4
  4087b2:	bd10      	pop	{r4, pc}
  4087b4:	f100 0308 	add.w	r3, r0, #8
  4087b8:	e7e1      	b.n	40877e <_calloc_r+0x22>
  4087ba:	bf00      	nop

004087bc <__aeabi_drsub>:
  4087bc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  4087c0:	e002      	b.n	4087c8 <__adddf3>
  4087c2:	bf00      	nop

004087c4 <__aeabi_dsub>:
  4087c4:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

004087c8 <__adddf3>:
  4087c8:	b530      	push	{r4, r5, lr}
  4087ca:	ea4f 0441 	mov.w	r4, r1, lsl #1
  4087ce:	ea4f 0543 	mov.w	r5, r3, lsl #1
  4087d2:	ea94 0f05 	teq	r4, r5
  4087d6:	bf08      	it	eq
  4087d8:	ea90 0f02 	teqeq	r0, r2
  4087dc:	bf1f      	itttt	ne
  4087de:	ea54 0c00 	orrsne.w	ip, r4, r0
  4087e2:	ea55 0c02 	orrsne.w	ip, r5, r2
  4087e6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  4087ea:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4087ee:	f000 80e2 	beq.w	4089b6 <__adddf3+0x1ee>
  4087f2:	ea4f 5454 	mov.w	r4, r4, lsr #21
  4087f6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  4087fa:	bfb8      	it	lt
  4087fc:	426d      	neglt	r5, r5
  4087fe:	dd0c      	ble.n	40881a <__adddf3+0x52>
  408800:	442c      	add	r4, r5
  408802:	ea80 0202 	eor.w	r2, r0, r2
  408806:	ea81 0303 	eor.w	r3, r1, r3
  40880a:	ea82 0000 	eor.w	r0, r2, r0
  40880e:	ea83 0101 	eor.w	r1, r3, r1
  408812:	ea80 0202 	eor.w	r2, r0, r2
  408816:	ea81 0303 	eor.w	r3, r1, r3
  40881a:	2d36      	cmp	r5, #54	; 0x36
  40881c:	bf88      	it	hi
  40881e:	bd30      	pophi	{r4, r5, pc}
  408820:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  408824:	ea4f 3101 	mov.w	r1, r1, lsl #12
  408828:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  40882c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  408830:	d002      	beq.n	408838 <__adddf3+0x70>
  408832:	4240      	negs	r0, r0
  408834:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  408838:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  40883c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  408840:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  408844:	d002      	beq.n	40884c <__adddf3+0x84>
  408846:	4252      	negs	r2, r2
  408848:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  40884c:	ea94 0f05 	teq	r4, r5
  408850:	f000 80a7 	beq.w	4089a2 <__adddf3+0x1da>
  408854:	f1a4 0401 	sub.w	r4, r4, #1
  408858:	f1d5 0e20 	rsbs	lr, r5, #32
  40885c:	db0d      	blt.n	40887a <__adddf3+0xb2>
  40885e:	fa02 fc0e 	lsl.w	ip, r2, lr
  408862:	fa22 f205 	lsr.w	r2, r2, r5
  408866:	1880      	adds	r0, r0, r2
  408868:	f141 0100 	adc.w	r1, r1, #0
  40886c:	fa03 f20e 	lsl.w	r2, r3, lr
  408870:	1880      	adds	r0, r0, r2
  408872:	fa43 f305 	asr.w	r3, r3, r5
  408876:	4159      	adcs	r1, r3
  408878:	e00e      	b.n	408898 <__adddf3+0xd0>
  40887a:	f1a5 0520 	sub.w	r5, r5, #32
  40887e:	f10e 0e20 	add.w	lr, lr, #32
  408882:	2a01      	cmp	r2, #1
  408884:	fa03 fc0e 	lsl.w	ip, r3, lr
  408888:	bf28      	it	cs
  40888a:	f04c 0c02 	orrcs.w	ip, ip, #2
  40888e:	fa43 f305 	asr.w	r3, r3, r5
  408892:	18c0      	adds	r0, r0, r3
  408894:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  408898:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  40889c:	d507      	bpl.n	4088ae <__adddf3+0xe6>
  40889e:	f04f 0e00 	mov.w	lr, #0
  4088a2:	f1dc 0c00 	rsbs	ip, ip, #0
  4088a6:	eb7e 0000 	sbcs.w	r0, lr, r0
  4088aa:	eb6e 0101 	sbc.w	r1, lr, r1
  4088ae:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  4088b2:	d31b      	bcc.n	4088ec <__adddf3+0x124>
  4088b4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  4088b8:	d30c      	bcc.n	4088d4 <__adddf3+0x10c>
  4088ba:	0849      	lsrs	r1, r1, #1
  4088bc:	ea5f 0030 	movs.w	r0, r0, rrx
  4088c0:	ea4f 0c3c 	mov.w	ip, ip, rrx
  4088c4:	f104 0401 	add.w	r4, r4, #1
  4088c8:	ea4f 5244 	mov.w	r2, r4, lsl #21
  4088cc:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  4088d0:	f080 809a 	bcs.w	408a08 <__adddf3+0x240>
  4088d4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  4088d8:	bf08      	it	eq
  4088da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  4088de:	f150 0000 	adcs.w	r0, r0, #0
  4088e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4088e6:	ea41 0105 	orr.w	r1, r1, r5
  4088ea:	bd30      	pop	{r4, r5, pc}
  4088ec:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  4088f0:	4140      	adcs	r0, r0
  4088f2:	eb41 0101 	adc.w	r1, r1, r1
  4088f6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4088fa:	f1a4 0401 	sub.w	r4, r4, #1
  4088fe:	d1e9      	bne.n	4088d4 <__adddf3+0x10c>
  408900:	f091 0f00 	teq	r1, #0
  408904:	bf04      	itt	eq
  408906:	4601      	moveq	r1, r0
  408908:	2000      	moveq	r0, #0
  40890a:	fab1 f381 	clz	r3, r1
  40890e:	bf08      	it	eq
  408910:	3320      	addeq	r3, #32
  408912:	f1a3 030b 	sub.w	r3, r3, #11
  408916:	f1b3 0220 	subs.w	r2, r3, #32
  40891a:	da0c      	bge.n	408936 <__adddf3+0x16e>
  40891c:	320c      	adds	r2, #12
  40891e:	dd08      	ble.n	408932 <__adddf3+0x16a>
  408920:	f102 0c14 	add.w	ip, r2, #20
  408924:	f1c2 020c 	rsb	r2, r2, #12
  408928:	fa01 f00c 	lsl.w	r0, r1, ip
  40892c:	fa21 f102 	lsr.w	r1, r1, r2
  408930:	e00c      	b.n	40894c <__adddf3+0x184>
  408932:	f102 0214 	add.w	r2, r2, #20
  408936:	bfd8      	it	le
  408938:	f1c2 0c20 	rsble	ip, r2, #32
  40893c:	fa01 f102 	lsl.w	r1, r1, r2
  408940:	fa20 fc0c 	lsr.w	ip, r0, ip
  408944:	bfdc      	itt	le
  408946:	ea41 010c 	orrle.w	r1, r1, ip
  40894a:	4090      	lslle	r0, r2
  40894c:	1ae4      	subs	r4, r4, r3
  40894e:	bfa2      	ittt	ge
  408950:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  408954:	4329      	orrge	r1, r5
  408956:	bd30      	popge	{r4, r5, pc}
  408958:	ea6f 0404 	mvn.w	r4, r4
  40895c:	3c1f      	subs	r4, #31
  40895e:	da1c      	bge.n	40899a <__adddf3+0x1d2>
  408960:	340c      	adds	r4, #12
  408962:	dc0e      	bgt.n	408982 <__adddf3+0x1ba>
  408964:	f104 0414 	add.w	r4, r4, #20
  408968:	f1c4 0220 	rsb	r2, r4, #32
  40896c:	fa20 f004 	lsr.w	r0, r0, r4
  408970:	fa01 f302 	lsl.w	r3, r1, r2
  408974:	ea40 0003 	orr.w	r0, r0, r3
  408978:	fa21 f304 	lsr.w	r3, r1, r4
  40897c:	ea45 0103 	orr.w	r1, r5, r3
  408980:	bd30      	pop	{r4, r5, pc}
  408982:	f1c4 040c 	rsb	r4, r4, #12
  408986:	f1c4 0220 	rsb	r2, r4, #32
  40898a:	fa20 f002 	lsr.w	r0, r0, r2
  40898e:	fa01 f304 	lsl.w	r3, r1, r4
  408992:	ea40 0003 	orr.w	r0, r0, r3
  408996:	4629      	mov	r1, r5
  408998:	bd30      	pop	{r4, r5, pc}
  40899a:	fa21 f004 	lsr.w	r0, r1, r4
  40899e:	4629      	mov	r1, r5
  4089a0:	bd30      	pop	{r4, r5, pc}
  4089a2:	f094 0f00 	teq	r4, #0
  4089a6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  4089aa:	bf06      	itte	eq
  4089ac:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  4089b0:	3401      	addeq	r4, #1
  4089b2:	3d01      	subne	r5, #1
  4089b4:	e74e      	b.n	408854 <__adddf3+0x8c>
  4089b6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4089ba:	bf18      	it	ne
  4089bc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4089c0:	d029      	beq.n	408a16 <__adddf3+0x24e>
  4089c2:	ea94 0f05 	teq	r4, r5
  4089c6:	bf08      	it	eq
  4089c8:	ea90 0f02 	teqeq	r0, r2
  4089cc:	d005      	beq.n	4089da <__adddf3+0x212>
  4089ce:	ea54 0c00 	orrs.w	ip, r4, r0
  4089d2:	bf04      	itt	eq
  4089d4:	4619      	moveq	r1, r3
  4089d6:	4610      	moveq	r0, r2
  4089d8:	bd30      	pop	{r4, r5, pc}
  4089da:	ea91 0f03 	teq	r1, r3
  4089de:	bf1e      	ittt	ne
  4089e0:	2100      	movne	r1, #0
  4089e2:	2000      	movne	r0, #0
  4089e4:	bd30      	popne	{r4, r5, pc}
  4089e6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  4089ea:	d105      	bne.n	4089f8 <__adddf3+0x230>
  4089ec:	0040      	lsls	r0, r0, #1
  4089ee:	4149      	adcs	r1, r1
  4089f0:	bf28      	it	cs
  4089f2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  4089f6:	bd30      	pop	{r4, r5, pc}
  4089f8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4089fc:	bf3c      	itt	cc
  4089fe:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  408a02:	bd30      	popcc	{r4, r5, pc}
  408a04:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  408a08:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  408a0c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  408a10:	f04f 0000 	mov.w	r0, #0
  408a14:	bd30      	pop	{r4, r5, pc}
  408a16:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  408a1a:	bf1a      	itte	ne
  408a1c:	4619      	movne	r1, r3
  408a1e:	4610      	movne	r0, r2
  408a20:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  408a24:	bf1c      	itt	ne
  408a26:	460b      	movne	r3, r1
  408a28:	4602      	movne	r2, r0
  408a2a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  408a2e:	bf06      	itte	eq
  408a30:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  408a34:	ea91 0f03 	teqeq	r1, r3
  408a38:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  408a3c:	bd30      	pop	{r4, r5, pc}
  408a3e:	bf00      	nop

00408a40 <__aeabi_ui2d>:
  408a40:	f090 0f00 	teq	r0, #0
  408a44:	bf04      	itt	eq
  408a46:	2100      	moveq	r1, #0
  408a48:	4770      	bxeq	lr
  408a4a:	b530      	push	{r4, r5, lr}
  408a4c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  408a50:	f104 0432 	add.w	r4, r4, #50	; 0x32
  408a54:	f04f 0500 	mov.w	r5, #0
  408a58:	f04f 0100 	mov.w	r1, #0
  408a5c:	e750      	b.n	408900 <__adddf3+0x138>
  408a5e:	bf00      	nop

00408a60 <__aeabi_i2d>:
  408a60:	f090 0f00 	teq	r0, #0
  408a64:	bf04      	itt	eq
  408a66:	2100      	moveq	r1, #0
  408a68:	4770      	bxeq	lr
  408a6a:	b530      	push	{r4, r5, lr}
  408a6c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  408a70:	f104 0432 	add.w	r4, r4, #50	; 0x32
  408a74:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  408a78:	bf48      	it	mi
  408a7a:	4240      	negmi	r0, r0
  408a7c:	f04f 0100 	mov.w	r1, #0
  408a80:	e73e      	b.n	408900 <__adddf3+0x138>
  408a82:	bf00      	nop

00408a84 <__aeabi_f2d>:
  408a84:	0042      	lsls	r2, r0, #1
  408a86:	ea4f 01e2 	mov.w	r1, r2, asr #3
  408a8a:	ea4f 0131 	mov.w	r1, r1, rrx
  408a8e:	ea4f 7002 	mov.w	r0, r2, lsl #28
  408a92:	bf1f      	itttt	ne
  408a94:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  408a98:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  408a9c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  408aa0:	4770      	bxne	lr
  408aa2:	f092 0f00 	teq	r2, #0
  408aa6:	bf14      	ite	ne
  408aa8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  408aac:	4770      	bxeq	lr
  408aae:	b530      	push	{r4, r5, lr}
  408ab0:	f44f 7460 	mov.w	r4, #896	; 0x380
  408ab4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  408ab8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  408abc:	e720      	b.n	408900 <__adddf3+0x138>
  408abe:	bf00      	nop

00408ac0 <__aeabi_ul2d>:
  408ac0:	ea50 0201 	orrs.w	r2, r0, r1
  408ac4:	bf08      	it	eq
  408ac6:	4770      	bxeq	lr
  408ac8:	b530      	push	{r4, r5, lr}
  408aca:	f04f 0500 	mov.w	r5, #0
  408ace:	e00a      	b.n	408ae6 <__aeabi_l2d+0x16>

00408ad0 <__aeabi_l2d>:
  408ad0:	ea50 0201 	orrs.w	r2, r0, r1
  408ad4:	bf08      	it	eq
  408ad6:	4770      	bxeq	lr
  408ad8:	b530      	push	{r4, r5, lr}
  408ada:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  408ade:	d502      	bpl.n	408ae6 <__aeabi_l2d+0x16>
  408ae0:	4240      	negs	r0, r0
  408ae2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  408ae6:	f44f 6480 	mov.w	r4, #1024	; 0x400
  408aea:	f104 0432 	add.w	r4, r4, #50	; 0x32
  408aee:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  408af2:	f43f aedc 	beq.w	4088ae <__adddf3+0xe6>
  408af6:	f04f 0203 	mov.w	r2, #3
  408afa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  408afe:	bf18      	it	ne
  408b00:	3203      	addne	r2, #3
  408b02:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  408b06:	bf18      	it	ne
  408b08:	3203      	addne	r2, #3
  408b0a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  408b0e:	f1c2 0320 	rsb	r3, r2, #32
  408b12:	fa00 fc03 	lsl.w	ip, r0, r3
  408b16:	fa20 f002 	lsr.w	r0, r0, r2
  408b1a:	fa01 fe03 	lsl.w	lr, r1, r3
  408b1e:	ea40 000e 	orr.w	r0, r0, lr
  408b22:	fa21 f102 	lsr.w	r1, r1, r2
  408b26:	4414      	add	r4, r2
  408b28:	e6c1      	b.n	4088ae <__adddf3+0xe6>
  408b2a:	bf00      	nop

00408b2c <__aeabi_dmul>:
  408b2c:	b570      	push	{r4, r5, r6, lr}
  408b2e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  408b32:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  408b36:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  408b3a:	bf1d      	ittte	ne
  408b3c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  408b40:	ea94 0f0c 	teqne	r4, ip
  408b44:	ea95 0f0c 	teqne	r5, ip
  408b48:	f000 f8de 	bleq	408d08 <__aeabi_dmul+0x1dc>
  408b4c:	442c      	add	r4, r5
  408b4e:	ea81 0603 	eor.w	r6, r1, r3
  408b52:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  408b56:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  408b5a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  408b5e:	bf18      	it	ne
  408b60:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  408b64:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  408b68:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  408b6c:	d038      	beq.n	408be0 <__aeabi_dmul+0xb4>
  408b6e:	fba0 ce02 	umull	ip, lr, r0, r2
  408b72:	f04f 0500 	mov.w	r5, #0
  408b76:	fbe1 e502 	umlal	lr, r5, r1, r2
  408b7a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  408b7e:	fbe0 e503 	umlal	lr, r5, r0, r3
  408b82:	f04f 0600 	mov.w	r6, #0
  408b86:	fbe1 5603 	umlal	r5, r6, r1, r3
  408b8a:	f09c 0f00 	teq	ip, #0
  408b8e:	bf18      	it	ne
  408b90:	f04e 0e01 	orrne.w	lr, lr, #1
  408b94:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  408b98:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  408b9c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  408ba0:	d204      	bcs.n	408bac <__aeabi_dmul+0x80>
  408ba2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  408ba6:	416d      	adcs	r5, r5
  408ba8:	eb46 0606 	adc.w	r6, r6, r6
  408bac:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  408bb0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  408bb4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  408bb8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  408bbc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  408bc0:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  408bc4:	bf88      	it	hi
  408bc6:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  408bca:	d81e      	bhi.n	408c0a <__aeabi_dmul+0xde>
  408bcc:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  408bd0:	bf08      	it	eq
  408bd2:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  408bd6:	f150 0000 	adcs.w	r0, r0, #0
  408bda:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  408bde:	bd70      	pop	{r4, r5, r6, pc}
  408be0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  408be4:	ea46 0101 	orr.w	r1, r6, r1
  408be8:	ea40 0002 	orr.w	r0, r0, r2
  408bec:	ea81 0103 	eor.w	r1, r1, r3
  408bf0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  408bf4:	bfc2      	ittt	gt
  408bf6:	ebd4 050c 	rsbsgt	r5, r4, ip
  408bfa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  408bfe:	bd70      	popgt	{r4, r5, r6, pc}
  408c00:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  408c04:	f04f 0e00 	mov.w	lr, #0
  408c08:	3c01      	subs	r4, #1
  408c0a:	f300 80ab 	bgt.w	408d64 <__aeabi_dmul+0x238>
  408c0e:	f114 0f36 	cmn.w	r4, #54	; 0x36
  408c12:	bfde      	ittt	le
  408c14:	2000      	movle	r0, #0
  408c16:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  408c1a:	bd70      	pople	{r4, r5, r6, pc}
  408c1c:	f1c4 0400 	rsb	r4, r4, #0
  408c20:	3c20      	subs	r4, #32
  408c22:	da35      	bge.n	408c90 <__aeabi_dmul+0x164>
  408c24:	340c      	adds	r4, #12
  408c26:	dc1b      	bgt.n	408c60 <__aeabi_dmul+0x134>
  408c28:	f104 0414 	add.w	r4, r4, #20
  408c2c:	f1c4 0520 	rsb	r5, r4, #32
  408c30:	fa00 f305 	lsl.w	r3, r0, r5
  408c34:	fa20 f004 	lsr.w	r0, r0, r4
  408c38:	fa01 f205 	lsl.w	r2, r1, r5
  408c3c:	ea40 0002 	orr.w	r0, r0, r2
  408c40:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  408c44:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  408c48:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  408c4c:	fa21 f604 	lsr.w	r6, r1, r4
  408c50:	eb42 0106 	adc.w	r1, r2, r6
  408c54:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408c58:	bf08      	it	eq
  408c5a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408c5e:	bd70      	pop	{r4, r5, r6, pc}
  408c60:	f1c4 040c 	rsb	r4, r4, #12
  408c64:	f1c4 0520 	rsb	r5, r4, #32
  408c68:	fa00 f304 	lsl.w	r3, r0, r4
  408c6c:	fa20 f005 	lsr.w	r0, r0, r5
  408c70:	fa01 f204 	lsl.w	r2, r1, r4
  408c74:	ea40 0002 	orr.w	r0, r0, r2
  408c78:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408c7c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  408c80:	f141 0100 	adc.w	r1, r1, #0
  408c84:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408c88:	bf08      	it	eq
  408c8a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408c8e:	bd70      	pop	{r4, r5, r6, pc}
  408c90:	f1c4 0520 	rsb	r5, r4, #32
  408c94:	fa00 f205 	lsl.w	r2, r0, r5
  408c98:	ea4e 0e02 	orr.w	lr, lr, r2
  408c9c:	fa20 f304 	lsr.w	r3, r0, r4
  408ca0:	fa01 f205 	lsl.w	r2, r1, r5
  408ca4:	ea43 0302 	orr.w	r3, r3, r2
  408ca8:	fa21 f004 	lsr.w	r0, r1, r4
  408cac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408cb0:	fa21 f204 	lsr.w	r2, r1, r4
  408cb4:	ea20 0002 	bic.w	r0, r0, r2
  408cb8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  408cbc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  408cc0:	bf08      	it	eq
  408cc2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  408cc6:	bd70      	pop	{r4, r5, r6, pc}
  408cc8:	f094 0f00 	teq	r4, #0
  408ccc:	d10f      	bne.n	408cee <__aeabi_dmul+0x1c2>
  408cce:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  408cd2:	0040      	lsls	r0, r0, #1
  408cd4:	eb41 0101 	adc.w	r1, r1, r1
  408cd8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408cdc:	bf08      	it	eq
  408cde:	3c01      	subeq	r4, #1
  408ce0:	d0f7      	beq.n	408cd2 <__aeabi_dmul+0x1a6>
  408ce2:	ea41 0106 	orr.w	r1, r1, r6
  408ce6:	f095 0f00 	teq	r5, #0
  408cea:	bf18      	it	ne
  408cec:	4770      	bxne	lr
  408cee:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  408cf2:	0052      	lsls	r2, r2, #1
  408cf4:	eb43 0303 	adc.w	r3, r3, r3
  408cf8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  408cfc:	bf08      	it	eq
  408cfe:	3d01      	subeq	r5, #1
  408d00:	d0f7      	beq.n	408cf2 <__aeabi_dmul+0x1c6>
  408d02:	ea43 0306 	orr.w	r3, r3, r6
  408d06:	4770      	bx	lr
  408d08:	ea94 0f0c 	teq	r4, ip
  408d0c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  408d10:	bf18      	it	ne
  408d12:	ea95 0f0c 	teqne	r5, ip
  408d16:	d00c      	beq.n	408d32 <__aeabi_dmul+0x206>
  408d18:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408d1c:	bf18      	it	ne
  408d1e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408d22:	d1d1      	bne.n	408cc8 <__aeabi_dmul+0x19c>
  408d24:	ea81 0103 	eor.w	r1, r1, r3
  408d28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408d2c:	f04f 0000 	mov.w	r0, #0
  408d30:	bd70      	pop	{r4, r5, r6, pc}
  408d32:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408d36:	bf06      	itte	eq
  408d38:	4610      	moveq	r0, r2
  408d3a:	4619      	moveq	r1, r3
  408d3c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408d40:	d019      	beq.n	408d76 <__aeabi_dmul+0x24a>
  408d42:	ea94 0f0c 	teq	r4, ip
  408d46:	d102      	bne.n	408d4e <__aeabi_dmul+0x222>
  408d48:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  408d4c:	d113      	bne.n	408d76 <__aeabi_dmul+0x24a>
  408d4e:	ea95 0f0c 	teq	r5, ip
  408d52:	d105      	bne.n	408d60 <__aeabi_dmul+0x234>
  408d54:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  408d58:	bf1c      	itt	ne
  408d5a:	4610      	movne	r0, r2
  408d5c:	4619      	movne	r1, r3
  408d5e:	d10a      	bne.n	408d76 <__aeabi_dmul+0x24a>
  408d60:	ea81 0103 	eor.w	r1, r1, r3
  408d64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  408d68:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  408d6c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  408d70:	f04f 0000 	mov.w	r0, #0
  408d74:	bd70      	pop	{r4, r5, r6, pc}
  408d76:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  408d7a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  408d7e:	bd70      	pop	{r4, r5, r6, pc}

00408d80 <__aeabi_ddiv>:
  408d80:	b570      	push	{r4, r5, r6, lr}
  408d82:	f04f 0cff 	mov.w	ip, #255	; 0xff
  408d86:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  408d8a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  408d8e:	bf1d      	ittte	ne
  408d90:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  408d94:	ea94 0f0c 	teqne	r4, ip
  408d98:	ea95 0f0c 	teqne	r5, ip
  408d9c:	f000 f8a7 	bleq	408eee <__aeabi_ddiv+0x16e>
  408da0:	eba4 0405 	sub.w	r4, r4, r5
  408da4:	ea81 0e03 	eor.w	lr, r1, r3
  408da8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  408dac:	ea4f 3101 	mov.w	r1, r1, lsl #12
  408db0:	f000 8088 	beq.w	408ec4 <__aeabi_ddiv+0x144>
  408db4:	ea4f 3303 	mov.w	r3, r3, lsl #12
  408db8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  408dbc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  408dc0:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  408dc4:	ea4f 2202 	mov.w	r2, r2, lsl #8
  408dc8:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  408dcc:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  408dd0:	ea4f 2600 	mov.w	r6, r0, lsl #8
  408dd4:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  408dd8:	429d      	cmp	r5, r3
  408dda:	bf08      	it	eq
  408ddc:	4296      	cmpeq	r6, r2
  408dde:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  408de2:	f504 7440 	add.w	r4, r4, #768	; 0x300
  408de6:	d202      	bcs.n	408dee <__aeabi_ddiv+0x6e>
  408de8:	085b      	lsrs	r3, r3, #1
  408dea:	ea4f 0232 	mov.w	r2, r2, rrx
  408dee:	1ab6      	subs	r6, r6, r2
  408df0:	eb65 0503 	sbc.w	r5, r5, r3
  408df4:	085b      	lsrs	r3, r3, #1
  408df6:	ea4f 0232 	mov.w	r2, r2, rrx
  408dfa:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  408dfe:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  408e02:	ebb6 0e02 	subs.w	lr, r6, r2
  408e06:	eb75 0e03 	sbcs.w	lr, r5, r3
  408e0a:	bf22      	ittt	cs
  408e0c:	1ab6      	subcs	r6, r6, r2
  408e0e:	4675      	movcs	r5, lr
  408e10:	ea40 000c 	orrcs.w	r0, r0, ip
  408e14:	085b      	lsrs	r3, r3, #1
  408e16:	ea4f 0232 	mov.w	r2, r2, rrx
  408e1a:	ebb6 0e02 	subs.w	lr, r6, r2
  408e1e:	eb75 0e03 	sbcs.w	lr, r5, r3
  408e22:	bf22      	ittt	cs
  408e24:	1ab6      	subcs	r6, r6, r2
  408e26:	4675      	movcs	r5, lr
  408e28:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  408e2c:	085b      	lsrs	r3, r3, #1
  408e2e:	ea4f 0232 	mov.w	r2, r2, rrx
  408e32:	ebb6 0e02 	subs.w	lr, r6, r2
  408e36:	eb75 0e03 	sbcs.w	lr, r5, r3
  408e3a:	bf22      	ittt	cs
  408e3c:	1ab6      	subcs	r6, r6, r2
  408e3e:	4675      	movcs	r5, lr
  408e40:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  408e44:	085b      	lsrs	r3, r3, #1
  408e46:	ea4f 0232 	mov.w	r2, r2, rrx
  408e4a:	ebb6 0e02 	subs.w	lr, r6, r2
  408e4e:	eb75 0e03 	sbcs.w	lr, r5, r3
  408e52:	bf22      	ittt	cs
  408e54:	1ab6      	subcs	r6, r6, r2
  408e56:	4675      	movcs	r5, lr
  408e58:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  408e5c:	ea55 0e06 	orrs.w	lr, r5, r6
  408e60:	d018      	beq.n	408e94 <__aeabi_ddiv+0x114>
  408e62:	ea4f 1505 	mov.w	r5, r5, lsl #4
  408e66:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  408e6a:	ea4f 1606 	mov.w	r6, r6, lsl #4
  408e6e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  408e72:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  408e76:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  408e7a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  408e7e:	d1c0      	bne.n	408e02 <__aeabi_ddiv+0x82>
  408e80:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408e84:	d10b      	bne.n	408e9e <__aeabi_ddiv+0x11e>
  408e86:	ea41 0100 	orr.w	r1, r1, r0
  408e8a:	f04f 0000 	mov.w	r0, #0
  408e8e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  408e92:	e7b6      	b.n	408e02 <__aeabi_ddiv+0x82>
  408e94:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  408e98:	bf04      	itt	eq
  408e9a:	4301      	orreq	r1, r0
  408e9c:	2000      	moveq	r0, #0
  408e9e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  408ea2:	bf88      	it	hi
  408ea4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  408ea8:	f63f aeaf 	bhi.w	408c0a <__aeabi_dmul+0xde>
  408eac:	ebb5 0c03 	subs.w	ip, r5, r3
  408eb0:	bf04      	itt	eq
  408eb2:	ebb6 0c02 	subseq.w	ip, r6, r2
  408eb6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  408eba:	f150 0000 	adcs.w	r0, r0, #0
  408ebe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  408ec2:	bd70      	pop	{r4, r5, r6, pc}
  408ec4:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  408ec8:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  408ecc:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  408ed0:	bfc2      	ittt	gt
  408ed2:	ebd4 050c 	rsbsgt	r5, r4, ip
  408ed6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  408eda:	bd70      	popgt	{r4, r5, r6, pc}
  408edc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  408ee0:	f04f 0e00 	mov.w	lr, #0
  408ee4:	3c01      	subs	r4, #1
  408ee6:	e690      	b.n	408c0a <__aeabi_dmul+0xde>
  408ee8:	ea45 0e06 	orr.w	lr, r5, r6
  408eec:	e68d      	b.n	408c0a <__aeabi_dmul+0xde>
  408eee:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  408ef2:	ea94 0f0c 	teq	r4, ip
  408ef6:	bf08      	it	eq
  408ef8:	ea95 0f0c 	teqeq	r5, ip
  408efc:	f43f af3b 	beq.w	408d76 <__aeabi_dmul+0x24a>
  408f00:	ea94 0f0c 	teq	r4, ip
  408f04:	d10a      	bne.n	408f1c <__aeabi_ddiv+0x19c>
  408f06:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  408f0a:	f47f af34 	bne.w	408d76 <__aeabi_dmul+0x24a>
  408f0e:	ea95 0f0c 	teq	r5, ip
  408f12:	f47f af25 	bne.w	408d60 <__aeabi_dmul+0x234>
  408f16:	4610      	mov	r0, r2
  408f18:	4619      	mov	r1, r3
  408f1a:	e72c      	b.n	408d76 <__aeabi_dmul+0x24a>
  408f1c:	ea95 0f0c 	teq	r5, ip
  408f20:	d106      	bne.n	408f30 <__aeabi_ddiv+0x1b0>
  408f22:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  408f26:	f43f aefd 	beq.w	408d24 <__aeabi_dmul+0x1f8>
  408f2a:	4610      	mov	r0, r2
  408f2c:	4619      	mov	r1, r3
  408f2e:	e722      	b.n	408d76 <__aeabi_dmul+0x24a>
  408f30:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  408f34:	bf18      	it	ne
  408f36:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  408f3a:	f47f aec5 	bne.w	408cc8 <__aeabi_dmul+0x19c>
  408f3e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  408f42:	f47f af0d 	bne.w	408d60 <__aeabi_dmul+0x234>
  408f46:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  408f4a:	f47f aeeb 	bne.w	408d24 <__aeabi_dmul+0x1f8>
  408f4e:	e712      	b.n	408d76 <__aeabi_dmul+0x24a>

00408f50 <__gedf2>:
  408f50:	f04f 3cff 	mov.w	ip, #4294967295
  408f54:	e006      	b.n	408f64 <__cmpdf2+0x4>
  408f56:	bf00      	nop

00408f58 <__ledf2>:
  408f58:	f04f 0c01 	mov.w	ip, #1
  408f5c:	e002      	b.n	408f64 <__cmpdf2+0x4>
  408f5e:	bf00      	nop

00408f60 <__cmpdf2>:
  408f60:	f04f 0c01 	mov.w	ip, #1
  408f64:	f84d cd04 	str.w	ip, [sp, #-4]!
  408f68:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  408f6c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408f70:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  408f74:	bf18      	it	ne
  408f76:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  408f7a:	d01b      	beq.n	408fb4 <__cmpdf2+0x54>
  408f7c:	b001      	add	sp, #4
  408f7e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  408f82:	bf0c      	ite	eq
  408f84:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  408f88:	ea91 0f03 	teqne	r1, r3
  408f8c:	bf02      	ittt	eq
  408f8e:	ea90 0f02 	teqeq	r0, r2
  408f92:	2000      	moveq	r0, #0
  408f94:	4770      	bxeq	lr
  408f96:	f110 0f00 	cmn.w	r0, #0
  408f9a:	ea91 0f03 	teq	r1, r3
  408f9e:	bf58      	it	pl
  408fa0:	4299      	cmppl	r1, r3
  408fa2:	bf08      	it	eq
  408fa4:	4290      	cmpeq	r0, r2
  408fa6:	bf2c      	ite	cs
  408fa8:	17d8      	asrcs	r0, r3, #31
  408faa:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  408fae:	f040 0001 	orr.w	r0, r0, #1
  408fb2:	4770      	bx	lr
  408fb4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  408fb8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408fbc:	d102      	bne.n	408fc4 <__cmpdf2+0x64>
  408fbe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  408fc2:	d107      	bne.n	408fd4 <__cmpdf2+0x74>
  408fc4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  408fc8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  408fcc:	d1d6      	bne.n	408f7c <__cmpdf2+0x1c>
  408fce:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  408fd2:	d0d3      	beq.n	408f7c <__cmpdf2+0x1c>
  408fd4:	f85d 0b04 	ldr.w	r0, [sp], #4
  408fd8:	4770      	bx	lr
  408fda:	bf00      	nop

00408fdc <__aeabi_cdrcmple>:
  408fdc:	4684      	mov	ip, r0
  408fde:	4610      	mov	r0, r2
  408fe0:	4662      	mov	r2, ip
  408fe2:	468c      	mov	ip, r1
  408fe4:	4619      	mov	r1, r3
  408fe6:	4663      	mov	r3, ip
  408fe8:	e000      	b.n	408fec <__aeabi_cdcmpeq>
  408fea:	bf00      	nop

00408fec <__aeabi_cdcmpeq>:
  408fec:	b501      	push	{r0, lr}
  408fee:	f7ff ffb7 	bl	408f60 <__cmpdf2>
  408ff2:	2800      	cmp	r0, #0
  408ff4:	bf48      	it	mi
  408ff6:	f110 0f00 	cmnmi.w	r0, #0
  408ffa:	bd01      	pop	{r0, pc}

00408ffc <__aeabi_dcmpeq>:
  408ffc:	f84d ed08 	str.w	lr, [sp, #-8]!
  409000:	f7ff fff4 	bl	408fec <__aeabi_cdcmpeq>
  409004:	bf0c      	ite	eq
  409006:	2001      	moveq	r0, #1
  409008:	2000      	movne	r0, #0
  40900a:	f85d fb08 	ldr.w	pc, [sp], #8
  40900e:	bf00      	nop

00409010 <__aeabi_dcmplt>:
  409010:	f84d ed08 	str.w	lr, [sp, #-8]!
  409014:	f7ff ffea 	bl	408fec <__aeabi_cdcmpeq>
  409018:	bf34      	ite	cc
  40901a:	2001      	movcc	r0, #1
  40901c:	2000      	movcs	r0, #0
  40901e:	f85d fb08 	ldr.w	pc, [sp], #8
  409022:	bf00      	nop

00409024 <__aeabi_dcmple>:
  409024:	f84d ed08 	str.w	lr, [sp, #-8]!
  409028:	f7ff ffe0 	bl	408fec <__aeabi_cdcmpeq>
  40902c:	bf94      	ite	ls
  40902e:	2001      	movls	r0, #1
  409030:	2000      	movhi	r0, #0
  409032:	f85d fb08 	ldr.w	pc, [sp], #8
  409036:	bf00      	nop

00409038 <__aeabi_dcmpge>:
  409038:	f84d ed08 	str.w	lr, [sp, #-8]!
  40903c:	f7ff ffce 	bl	408fdc <__aeabi_cdrcmple>
  409040:	bf94      	ite	ls
  409042:	2001      	movls	r0, #1
  409044:	2000      	movhi	r0, #0
  409046:	f85d fb08 	ldr.w	pc, [sp], #8
  40904a:	bf00      	nop

0040904c <__aeabi_dcmpgt>:
  40904c:	f84d ed08 	str.w	lr, [sp, #-8]!
  409050:	f7ff ffc4 	bl	408fdc <__aeabi_cdrcmple>
  409054:	bf34      	ite	cc
  409056:	2001      	movcc	r0, #1
  409058:	2000      	movcs	r0, #0
  40905a:	f85d fb08 	ldr.w	pc, [sp], #8
  40905e:	bf00      	nop

00409060 <__aeabi_d2iz>:
  409060:	ea4f 0241 	mov.w	r2, r1, lsl #1
  409064:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  409068:	d215      	bcs.n	409096 <__aeabi_d2iz+0x36>
  40906a:	d511      	bpl.n	409090 <__aeabi_d2iz+0x30>
  40906c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  409070:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  409074:	d912      	bls.n	40909c <__aeabi_d2iz+0x3c>
  409076:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  40907a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  40907e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  409082:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  409086:	fa23 f002 	lsr.w	r0, r3, r2
  40908a:	bf18      	it	ne
  40908c:	4240      	negne	r0, r0
  40908e:	4770      	bx	lr
  409090:	f04f 0000 	mov.w	r0, #0
  409094:	4770      	bx	lr
  409096:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  40909a:	d105      	bne.n	4090a8 <__aeabi_d2iz+0x48>
  40909c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  4090a0:	bf08      	it	eq
  4090a2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  4090a6:	4770      	bx	lr
  4090a8:	f04f 0000 	mov.w	r0, #0
  4090ac:	4770      	bx	lr
  4090ae:	bf00      	nop

004090b0 <__aeabi_uldivmod>:
  4090b0:	b953      	cbnz	r3, 4090c8 <__aeabi_uldivmod+0x18>
  4090b2:	b94a      	cbnz	r2, 4090c8 <__aeabi_uldivmod+0x18>
  4090b4:	2900      	cmp	r1, #0
  4090b6:	bf08      	it	eq
  4090b8:	2800      	cmpeq	r0, #0
  4090ba:	bf1c      	itt	ne
  4090bc:	f04f 31ff 	movne.w	r1, #4294967295
  4090c0:	f04f 30ff 	movne.w	r0, #4294967295
  4090c4:	f000 b83c 	b.w	409140 <__aeabi_idiv0>
  4090c8:	b082      	sub	sp, #8
  4090ca:	46ec      	mov	ip, sp
  4090cc:	e92d 5000 	stmdb	sp!, {ip, lr}
  4090d0:	f000 f81e 	bl	409110 <__gnu_uldivmod_helper>
  4090d4:	f8dd e004 	ldr.w	lr, [sp, #4]
  4090d8:	b002      	add	sp, #8
  4090da:	bc0c      	pop	{r2, r3}
  4090dc:	4770      	bx	lr
  4090de:	bf00      	nop

004090e0 <__gnu_ldivmod_helper>:
  4090e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4090e4:	9c06      	ldr	r4, [sp, #24]
  4090e6:	4615      	mov	r5, r2
  4090e8:	4606      	mov	r6, r0
  4090ea:	460f      	mov	r7, r1
  4090ec:	4698      	mov	r8, r3
  4090ee:	f000 f829 	bl	409144 <__divdi3>
  4090f2:	fb05 f301 	mul.w	r3, r5, r1
  4090f6:	fb00 3808 	mla	r8, r0, r8, r3
  4090fa:	fba5 2300 	umull	r2, r3, r5, r0
  4090fe:	1ab2      	subs	r2, r6, r2
  409100:	4443      	add	r3, r8
  409102:	eb67 0303 	sbc.w	r3, r7, r3
  409106:	e9c4 2300 	strd	r2, r3, [r4]
  40910a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40910e:	bf00      	nop

00409110 <__gnu_uldivmod_helper>:
  409110:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  409114:	9c06      	ldr	r4, [sp, #24]
  409116:	4690      	mov	r8, r2
  409118:	4606      	mov	r6, r0
  40911a:	460f      	mov	r7, r1
  40911c:	461d      	mov	r5, r3
  40911e:	f000 f95f 	bl	4093e0 <__udivdi3>
  409122:	fb00 f505 	mul.w	r5, r0, r5
  409126:	fba0 2308 	umull	r2, r3, r0, r8
  40912a:	fb08 5501 	mla	r5, r8, r1, r5
  40912e:	1ab2      	subs	r2, r6, r2
  409130:	442b      	add	r3, r5
  409132:	eb67 0303 	sbc.w	r3, r7, r3
  409136:	e9c4 2300 	strd	r2, r3, [r4]
  40913a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40913e:	bf00      	nop

00409140 <__aeabi_idiv0>:
  409140:	4770      	bx	lr
  409142:	bf00      	nop

00409144 <__divdi3>:
  409144:	2900      	cmp	r1, #0
  409146:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40914a:	f2c0 80a6 	blt.w	40929a <__divdi3+0x156>
  40914e:	2600      	movs	r6, #0
  409150:	2b00      	cmp	r3, #0
  409152:	f2c0 809c 	blt.w	40928e <__divdi3+0x14a>
  409156:	4688      	mov	r8, r1
  409158:	4694      	mov	ip, r2
  40915a:	469e      	mov	lr, r3
  40915c:	4615      	mov	r5, r2
  40915e:	4604      	mov	r4, r0
  409160:	460f      	mov	r7, r1
  409162:	2b00      	cmp	r3, #0
  409164:	d13d      	bne.n	4091e2 <__divdi3+0x9e>
  409166:	428a      	cmp	r2, r1
  409168:	d959      	bls.n	40921e <__divdi3+0xda>
  40916a:	fab2 f382 	clz	r3, r2
  40916e:	b13b      	cbz	r3, 409180 <__divdi3+0x3c>
  409170:	f1c3 0220 	rsb	r2, r3, #32
  409174:	409f      	lsls	r7, r3
  409176:	fa20 f202 	lsr.w	r2, r0, r2
  40917a:	409d      	lsls	r5, r3
  40917c:	4317      	orrs	r7, r2
  40917e:	409c      	lsls	r4, r3
  409180:	0c29      	lsrs	r1, r5, #16
  409182:	0c22      	lsrs	r2, r4, #16
  409184:	fbb7 fef1 	udiv	lr, r7, r1
  409188:	b2a8      	uxth	r0, r5
  40918a:	fb01 771e 	mls	r7, r1, lr, r7
  40918e:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  409192:	fb00 f30e 	mul.w	r3, r0, lr
  409196:	42bb      	cmp	r3, r7
  409198:	d90a      	bls.n	4091b0 <__divdi3+0x6c>
  40919a:	197f      	adds	r7, r7, r5
  40919c:	f10e 32ff 	add.w	r2, lr, #4294967295
  4091a0:	f080 8105 	bcs.w	4093ae <__divdi3+0x26a>
  4091a4:	42bb      	cmp	r3, r7
  4091a6:	f240 8102 	bls.w	4093ae <__divdi3+0x26a>
  4091aa:	f1ae 0e02 	sub.w	lr, lr, #2
  4091ae:	442f      	add	r7, r5
  4091b0:	1aff      	subs	r7, r7, r3
  4091b2:	b2a4      	uxth	r4, r4
  4091b4:	fbb7 f3f1 	udiv	r3, r7, r1
  4091b8:	fb01 7713 	mls	r7, r1, r3, r7
  4091bc:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
  4091c0:	fb00 f003 	mul.w	r0, r0, r3
  4091c4:	42b8      	cmp	r0, r7
  4091c6:	d908      	bls.n	4091da <__divdi3+0x96>
  4091c8:	197f      	adds	r7, r7, r5
  4091ca:	f103 32ff 	add.w	r2, r3, #4294967295
  4091ce:	f080 80f0 	bcs.w	4093b2 <__divdi3+0x26e>
  4091d2:	42b8      	cmp	r0, r7
  4091d4:	f240 80ed 	bls.w	4093b2 <__divdi3+0x26e>
  4091d8:	3b02      	subs	r3, #2
  4091da:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
  4091de:	2200      	movs	r2, #0
  4091e0:	e003      	b.n	4091ea <__divdi3+0xa6>
  4091e2:	428b      	cmp	r3, r1
  4091e4:	d90f      	bls.n	409206 <__divdi3+0xc2>
  4091e6:	2200      	movs	r2, #0
  4091e8:	4613      	mov	r3, r2
  4091ea:	1c34      	adds	r4, r6, #0
  4091ec:	bf18      	it	ne
  4091ee:	2401      	movne	r4, #1
  4091f0:	4260      	negs	r0, r4
  4091f2:	f04f 0500 	mov.w	r5, #0
  4091f6:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
  4091fa:	4058      	eors	r0, r3
  4091fc:	4051      	eors	r1, r2
  4091fe:	1900      	adds	r0, r0, r4
  409200:	4169      	adcs	r1, r5
  409202:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  409206:	fab3 f283 	clz	r2, r3
  40920a:	2a00      	cmp	r2, #0
  40920c:	f040 8086 	bne.w	40931c <__divdi3+0x1d8>
  409210:	428b      	cmp	r3, r1
  409212:	d302      	bcc.n	40921a <__divdi3+0xd6>
  409214:	4584      	cmp	ip, r0
  409216:	f200 80db 	bhi.w	4093d0 <__divdi3+0x28c>
  40921a:	2301      	movs	r3, #1
  40921c:	e7e5      	b.n	4091ea <__divdi3+0xa6>
  40921e:	b912      	cbnz	r2, 409226 <__divdi3+0xe2>
  409220:	2301      	movs	r3, #1
  409222:	fbb3 f5f2 	udiv	r5, r3, r2
  409226:	fab5 f085 	clz	r0, r5
  40922a:	2800      	cmp	r0, #0
  40922c:	d13b      	bne.n	4092a6 <__divdi3+0x162>
  40922e:	1b78      	subs	r0, r7, r5
  409230:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409234:	fa1f fc85 	uxth.w	ip, r5
  409238:	2201      	movs	r2, #1
  40923a:	fbb0 f8fe 	udiv	r8, r0, lr
  40923e:	0c21      	lsrs	r1, r4, #16
  409240:	fb0e 0718 	mls	r7, lr, r8, r0
  409244:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
  409248:	fb0c f308 	mul.w	r3, ip, r8
  40924c:	42bb      	cmp	r3, r7
  40924e:	d907      	bls.n	409260 <__divdi3+0x11c>
  409250:	197f      	adds	r7, r7, r5
  409252:	f108 31ff 	add.w	r1, r8, #4294967295
  409256:	d202      	bcs.n	40925e <__divdi3+0x11a>
  409258:	42bb      	cmp	r3, r7
  40925a:	f200 80bd 	bhi.w	4093d8 <__divdi3+0x294>
  40925e:	4688      	mov	r8, r1
  409260:	1aff      	subs	r7, r7, r3
  409262:	b2a4      	uxth	r4, r4
  409264:	fbb7 f3fe 	udiv	r3, r7, lr
  409268:	fb0e 7713 	mls	r7, lr, r3, r7
  40926c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
  409270:	fb0c fc03 	mul.w	ip, ip, r3
  409274:	45bc      	cmp	ip, r7
  409276:	d907      	bls.n	409288 <__divdi3+0x144>
  409278:	197f      	adds	r7, r7, r5
  40927a:	f103 31ff 	add.w	r1, r3, #4294967295
  40927e:	d202      	bcs.n	409286 <__divdi3+0x142>
  409280:	45bc      	cmp	ip, r7
  409282:	f200 80a7 	bhi.w	4093d4 <__divdi3+0x290>
  409286:	460b      	mov	r3, r1
  409288:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  40928c:	e7ad      	b.n	4091ea <__divdi3+0xa6>
  40928e:	4252      	negs	r2, r2
  409290:	ea6f 0606 	mvn.w	r6, r6
  409294:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  409298:	e75d      	b.n	409156 <__divdi3+0x12>
  40929a:	4240      	negs	r0, r0
  40929c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4092a0:	f04f 36ff 	mov.w	r6, #4294967295
  4092a4:	e754      	b.n	409150 <__divdi3+0xc>
  4092a6:	f1c0 0220 	rsb	r2, r0, #32
  4092aa:	fa24 f102 	lsr.w	r1, r4, r2
  4092ae:	fa07 f300 	lsl.w	r3, r7, r0
  4092b2:	4085      	lsls	r5, r0
  4092b4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  4092b8:	40d7      	lsrs	r7, r2
  4092ba:	4319      	orrs	r1, r3
  4092bc:	fbb7 f2fe 	udiv	r2, r7, lr
  4092c0:	0c0b      	lsrs	r3, r1, #16
  4092c2:	fb0e 7712 	mls	r7, lr, r2, r7
  4092c6:	fa1f fc85 	uxth.w	ip, r5
  4092ca:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
  4092ce:	fb0c f702 	mul.w	r7, ip, r2
  4092d2:	429f      	cmp	r7, r3
  4092d4:	fa04 f400 	lsl.w	r4, r4, r0
  4092d8:	d907      	bls.n	4092ea <__divdi3+0x1a6>
  4092da:	195b      	adds	r3, r3, r5
  4092dc:	f102 30ff 	add.w	r0, r2, #4294967295
  4092e0:	d274      	bcs.n	4093cc <__divdi3+0x288>
  4092e2:	429f      	cmp	r7, r3
  4092e4:	d972      	bls.n	4093cc <__divdi3+0x288>
  4092e6:	3a02      	subs	r2, #2
  4092e8:	442b      	add	r3, r5
  4092ea:	1bdf      	subs	r7, r3, r7
  4092ec:	b289      	uxth	r1, r1
  4092ee:	fbb7 f8fe 	udiv	r8, r7, lr
  4092f2:	fb0e 7318 	mls	r3, lr, r8, r7
  4092f6:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
  4092fa:	fb0c f708 	mul.w	r7, ip, r8
  4092fe:	429f      	cmp	r7, r3
  409300:	d908      	bls.n	409314 <__divdi3+0x1d0>
  409302:	195b      	adds	r3, r3, r5
  409304:	f108 31ff 	add.w	r1, r8, #4294967295
  409308:	d25c      	bcs.n	4093c4 <__divdi3+0x280>
  40930a:	429f      	cmp	r7, r3
  40930c:	d95a      	bls.n	4093c4 <__divdi3+0x280>
  40930e:	f1a8 0802 	sub.w	r8, r8, #2
  409312:	442b      	add	r3, r5
  409314:	1bd8      	subs	r0, r3, r7
  409316:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
  40931a:	e78e      	b.n	40923a <__divdi3+0xf6>
  40931c:	f1c2 0320 	rsb	r3, r2, #32
  409320:	fa2c f103 	lsr.w	r1, ip, r3
  409324:	fa0e fe02 	lsl.w	lr, lr, r2
  409328:	fa20 f703 	lsr.w	r7, r0, r3
  40932c:	ea41 0e0e 	orr.w	lr, r1, lr
  409330:	fa08 f002 	lsl.w	r0, r8, r2
  409334:	fa28 f103 	lsr.w	r1, r8, r3
  409338:	ea4f 451e 	mov.w	r5, lr, lsr #16
  40933c:	4338      	orrs	r0, r7
  40933e:	fbb1 f8f5 	udiv	r8, r1, r5
  409342:	0c03      	lsrs	r3, r0, #16
  409344:	fb05 1118 	mls	r1, r5, r8, r1
  409348:	fa1f f78e 	uxth.w	r7, lr
  40934c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  409350:	fb07 f308 	mul.w	r3, r7, r8
  409354:	428b      	cmp	r3, r1
  409356:	fa0c fc02 	lsl.w	ip, ip, r2
  40935a:	d909      	bls.n	409370 <__divdi3+0x22c>
  40935c:	eb11 010e 	adds.w	r1, r1, lr
  409360:	f108 39ff 	add.w	r9, r8, #4294967295
  409364:	d230      	bcs.n	4093c8 <__divdi3+0x284>
  409366:	428b      	cmp	r3, r1
  409368:	d92e      	bls.n	4093c8 <__divdi3+0x284>
  40936a:	f1a8 0802 	sub.w	r8, r8, #2
  40936e:	4471      	add	r1, lr
  409370:	1ac9      	subs	r1, r1, r3
  409372:	b280      	uxth	r0, r0
  409374:	fbb1 f3f5 	udiv	r3, r1, r5
  409378:	fb05 1113 	mls	r1, r5, r3, r1
  40937c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  409380:	fb07 f703 	mul.w	r7, r7, r3
  409384:	428f      	cmp	r7, r1
  409386:	d908      	bls.n	40939a <__divdi3+0x256>
  409388:	eb11 010e 	adds.w	r1, r1, lr
  40938c:	f103 30ff 	add.w	r0, r3, #4294967295
  409390:	d216      	bcs.n	4093c0 <__divdi3+0x27c>
  409392:	428f      	cmp	r7, r1
  409394:	d914      	bls.n	4093c0 <__divdi3+0x27c>
  409396:	3b02      	subs	r3, #2
  409398:	4471      	add	r1, lr
  40939a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  40939e:	1bc9      	subs	r1, r1, r7
  4093a0:	fba3 890c 	umull	r8, r9, r3, ip
  4093a4:	4549      	cmp	r1, r9
  4093a6:	d309      	bcc.n	4093bc <__divdi3+0x278>
  4093a8:	d005      	beq.n	4093b6 <__divdi3+0x272>
  4093aa:	2200      	movs	r2, #0
  4093ac:	e71d      	b.n	4091ea <__divdi3+0xa6>
  4093ae:	4696      	mov	lr, r2
  4093b0:	e6fe      	b.n	4091b0 <__divdi3+0x6c>
  4093b2:	4613      	mov	r3, r2
  4093b4:	e711      	b.n	4091da <__divdi3+0x96>
  4093b6:	4094      	lsls	r4, r2
  4093b8:	4544      	cmp	r4, r8
  4093ba:	d2f6      	bcs.n	4093aa <__divdi3+0x266>
  4093bc:	3b01      	subs	r3, #1
  4093be:	e7f4      	b.n	4093aa <__divdi3+0x266>
  4093c0:	4603      	mov	r3, r0
  4093c2:	e7ea      	b.n	40939a <__divdi3+0x256>
  4093c4:	4688      	mov	r8, r1
  4093c6:	e7a5      	b.n	409314 <__divdi3+0x1d0>
  4093c8:	46c8      	mov	r8, r9
  4093ca:	e7d1      	b.n	409370 <__divdi3+0x22c>
  4093cc:	4602      	mov	r2, r0
  4093ce:	e78c      	b.n	4092ea <__divdi3+0x1a6>
  4093d0:	4613      	mov	r3, r2
  4093d2:	e70a      	b.n	4091ea <__divdi3+0xa6>
  4093d4:	3b02      	subs	r3, #2
  4093d6:	e757      	b.n	409288 <__divdi3+0x144>
  4093d8:	f1a8 0802 	sub.w	r8, r8, #2
  4093dc:	442f      	add	r7, r5
  4093de:	e73f      	b.n	409260 <__divdi3+0x11c>

004093e0 <__udivdi3>:
  4093e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4093e4:	2b00      	cmp	r3, #0
  4093e6:	d144      	bne.n	409472 <__udivdi3+0x92>
  4093e8:	428a      	cmp	r2, r1
  4093ea:	4615      	mov	r5, r2
  4093ec:	4604      	mov	r4, r0
  4093ee:	d94f      	bls.n	409490 <__udivdi3+0xb0>
  4093f0:	fab2 f782 	clz	r7, r2
  4093f4:	460e      	mov	r6, r1
  4093f6:	b14f      	cbz	r7, 40940c <__udivdi3+0x2c>
  4093f8:	f1c7 0320 	rsb	r3, r7, #32
  4093fc:	40b9      	lsls	r1, r7
  4093fe:	fa20 f603 	lsr.w	r6, r0, r3
  409402:	fa02 f507 	lsl.w	r5, r2, r7
  409406:	430e      	orrs	r6, r1
  409408:	fa00 f407 	lsl.w	r4, r0, r7
  40940c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  409410:	0c23      	lsrs	r3, r4, #16
  409412:	fbb6 f0fe 	udiv	r0, r6, lr
  409416:	b2af      	uxth	r7, r5
  409418:	fb0e 6110 	mls	r1, lr, r0, r6
  40941c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  409420:	fb07 f100 	mul.w	r1, r7, r0
  409424:	4299      	cmp	r1, r3
  409426:	d909      	bls.n	40943c <__udivdi3+0x5c>
  409428:	195b      	adds	r3, r3, r5
  40942a:	f100 32ff 	add.w	r2, r0, #4294967295
  40942e:	f080 80ec 	bcs.w	40960a <__udivdi3+0x22a>
  409432:	4299      	cmp	r1, r3
  409434:	f240 80e9 	bls.w	40960a <__udivdi3+0x22a>
  409438:	3802      	subs	r0, #2
  40943a:	442b      	add	r3, r5
  40943c:	1a5a      	subs	r2, r3, r1
  40943e:	b2a4      	uxth	r4, r4
  409440:	fbb2 f3fe 	udiv	r3, r2, lr
  409444:	fb0e 2213 	mls	r2, lr, r3, r2
  409448:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  40944c:	fb07 f703 	mul.w	r7, r7, r3
  409450:	4297      	cmp	r7, r2
  409452:	d908      	bls.n	409466 <__udivdi3+0x86>
  409454:	1952      	adds	r2, r2, r5
  409456:	f103 31ff 	add.w	r1, r3, #4294967295
  40945a:	f080 80d8 	bcs.w	40960e <__udivdi3+0x22e>
  40945e:	4297      	cmp	r7, r2
  409460:	f240 80d5 	bls.w	40960e <__udivdi3+0x22e>
  409464:	3b02      	subs	r3, #2
  409466:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  40946a:	2600      	movs	r6, #0
  40946c:	4631      	mov	r1, r6
  40946e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409472:	428b      	cmp	r3, r1
  409474:	d847      	bhi.n	409506 <__udivdi3+0x126>
  409476:	fab3 f683 	clz	r6, r3
  40947a:	2e00      	cmp	r6, #0
  40947c:	d148      	bne.n	409510 <__udivdi3+0x130>
  40947e:	428b      	cmp	r3, r1
  409480:	d302      	bcc.n	409488 <__udivdi3+0xa8>
  409482:	4282      	cmp	r2, r0
  409484:	f200 80cd 	bhi.w	409622 <__udivdi3+0x242>
  409488:	2001      	movs	r0, #1
  40948a:	4631      	mov	r1, r6
  40948c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409490:	b912      	cbnz	r2, 409498 <__udivdi3+0xb8>
  409492:	2501      	movs	r5, #1
  409494:	fbb5 f5f2 	udiv	r5, r5, r2
  409498:	fab5 f885 	clz	r8, r5
  40949c:	f1b8 0f00 	cmp.w	r8, #0
  4094a0:	d177      	bne.n	409592 <__udivdi3+0x1b2>
  4094a2:	1b4a      	subs	r2, r1, r5
  4094a4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  4094a8:	b2af      	uxth	r7, r5
  4094aa:	2601      	movs	r6, #1
  4094ac:	fbb2 f0fe 	udiv	r0, r2, lr
  4094b0:	0c23      	lsrs	r3, r4, #16
  4094b2:	fb0e 2110 	mls	r1, lr, r0, r2
  4094b6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  4094ba:	fb07 f300 	mul.w	r3, r7, r0
  4094be:	428b      	cmp	r3, r1
  4094c0:	d907      	bls.n	4094d2 <__udivdi3+0xf2>
  4094c2:	1949      	adds	r1, r1, r5
  4094c4:	f100 32ff 	add.w	r2, r0, #4294967295
  4094c8:	d202      	bcs.n	4094d0 <__udivdi3+0xf0>
  4094ca:	428b      	cmp	r3, r1
  4094cc:	f200 80ba 	bhi.w	409644 <__udivdi3+0x264>
  4094d0:	4610      	mov	r0, r2
  4094d2:	1ac9      	subs	r1, r1, r3
  4094d4:	b2a4      	uxth	r4, r4
  4094d6:	fbb1 f3fe 	udiv	r3, r1, lr
  4094da:	fb0e 1113 	mls	r1, lr, r3, r1
  4094de:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
  4094e2:	fb07 f703 	mul.w	r7, r7, r3
  4094e6:	42a7      	cmp	r7, r4
  4094e8:	d908      	bls.n	4094fc <__udivdi3+0x11c>
  4094ea:	1964      	adds	r4, r4, r5
  4094ec:	f103 32ff 	add.w	r2, r3, #4294967295
  4094f0:	f080 808f 	bcs.w	409612 <__udivdi3+0x232>
  4094f4:	42a7      	cmp	r7, r4
  4094f6:	f240 808c 	bls.w	409612 <__udivdi3+0x232>
  4094fa:	3b02      	subs	r3, #2
  4094fc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
  409500:	4631      	mov	r1, r6
  409502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409506:	2600      	movs	r6, #0
  409508:	4630      	mov	r0, r6
  40950a:	4631      	mov	r1, r6
  40950c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409510:	f1c6 0420 	rsb	r4, r6, #32
  409514:	fa22 f504 	lsr.w	r5, r2, r4
  409518:	40b3      	lsls	r3, r6
  40951a:	432b      	orrs	r3, r5
  40951c:	fa20 fc04 	lsr.w	ip, r0, r4
  409520:	fa01 f706 	lsl.w	r7, r1, r6
  409524:	fa21 f504 	lsr.w	r5, r1, r4
  409528:	ea4f 4e13 	mov.w	lr, r3, lsr #16
  40952c:	ea4c 0707 	orr.w	r7, ip, r7
  409530:	fbb5 f8fe 	udiv	r8, r5, lr
  409534:	0c39      	lsrs	r1, r7, #16
  409536:	fb0e 5518 	mls	r5, lr, r8, r5
  40953a:	fa1f fc83 	uxth.w	ip, r3
  40953e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
  409542:	fb0c f108 	mul.w	r1, ip, r8
  409546:	42a9      	cmp	r1, r5
  409548:	fa02 f206 	lsl.w	r2, r2, r6
  40954c:	d904      	bls.n	409558 <__udivdi3+0x178>
  40954e:	18ed      	adds	r5, r5, r3
  409550:	f108 34ff 	add.w	r4, r8, #4294967295
  409554:	d367      	bcc.n	409626 <__udivdi3+0x246>
  409556:	46a0      	mov	r8, r4
  409558:	1a6d      	subs	r5, r5, r1
  40955a:	b2bf      	uxth	r7, r7
  40955c:	fbb5 f4fe 	udiv	r4, r5, lr
  409560:	fb0e 5514 	mls	r5, lr, r4, r5
  409564:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
  409568:	fb0c fc04 	mul.w	ip, ip, r4
  40956c:	458c      	cmp	ip, r1
  40956e:	d904      	bls.n	40957a <__udivdi3+0x19a>
  409570:	18c9      	adds	r1, r1, r3
  409572:	f104 35ff 	add.w	r5, r4, #4294967295
  409576:	d35c      	bcc.n	409632 <__udivdi3+0x252>
  409578:	462c      	mov	r4, r5
  40957a:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
  40957e:	ebcc 0101 	rsb	r1, ip, r1
  409582:	fba4 2302 	umull	r2, r3, r4, r2
  409586:	4299      	cmp	r1, r3
  409588:	d348      	bcc.n	40961c <__udivdi3+0x23c>
  40958a:	d044      	beq.n	409616 <__udivdi3+0x236>
  40958c:	4620      	mov	r0, r4
  40958e:	2600      	movs	r6, #0
  409590:	e76c      	b.n	40946c <__udivdi3+0x8c>
  409592:	f1c8 0420 	rsb	r4, r8, #32
  409596:	fa01 f308 	lsl.w	r3, r1, r8
  40959a:	fa05 f508 	lsl.w	r5, r5, r8
  40959e:	fa20 f704 	lsr.w	r7, r0, r4
  4095a2:	40e1      	lsrs	r1, r4
  4095a4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
  4095a8:	431f      	orrs	r7, r3
  4095aa:	fbb1 f6fe 	udiv	r6, r1, lr
  4095ae:	0c3a      	lsrs	r2, r7, #16
  4095b0:	fb0e 1116 	mls	r1, lr, r6, r1
  4095b4:	fa1f fc85 	uxth.w	ip, r5
  4095b8:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
  4095bc:	fb0c f206 	mul.w	r2, ip, r6
  4095c0:	429a      	cmp	r2, r3
  4095c2:	fa00 f408 	lsl.w	r4, r0, r8
  4095c6:	d907      	bls.n	4095d8 <__udivdi3+0x1f8>
  4095c8:	195b      	adds	r3, r3, r5
  4095ca:	f106 31ff 	add.w	r1, r6, #4294967295
  4095ce:	d237      	bcs.n	409640 <__udivdi3+0x260>
  4095d0:	429a      	cmp	r2, r3
  4095d2:	d935      	bls.n	409640 <__udivdi3+0x260>
  4095d4:	3e02      	subs	r6, #2
  4095d6:	442b      	add	r3, r5
  4095d8:	1a9b      	subs	r3, r3, r2
  4095da:	b2bf      	uxth	r7, r7
  4095dc:	fbb3 f0fe 	udiv	r0, r3, lr
  4095e0:	fb0e 3310 	mls	r3, lr, r0, r3
  4095e4:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
  4095e8:	fb0c f100 	mul.w	r1, ip, r0
  4095ec:	4299      	cmp	r1, r3
  4095ee:	d907      	bls.n	409600 <__udivdi3+0x220>
  4095f0:	195b      	adds	r3, r3, r5
  4095f2:	f100 32ff 	add.w	r2, r0, #4294967295
  4095f6:	d221      	bcs.n	40963c <__udivdi3+0x25c>
  4095f8:	4299      	cmp	r1, r3
  4095fa:	d91f      	bls.n	40963c <__udivdi3+0x25c>
  4095fc:	3802      	subs	r0, #2
  4095fe:	442b      	add	r3, r5
  409600:	1a5a      	subs	r2, r3, r1
  409602:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
  409606:	4667      	mov	r7, ip
  409608:	e750      	b.n	4094ac <__udivdi3+0xcc>
  40960a:	4610      	mov	r0, r2
  40960c:	e716      	b.n	40943c <__udivdi3+0x5c>
  40960e:	460b      	mov	r3, r1
  409610:	e729      	b.n	409466 <__udivdi3+0x86>
  409612:	4613      	mov	r3, r2
  409614:	e772      	b.n	4094fc <__udivdi3+0x11c>
  409616:	40b0      	lsls	r0, r6
  409618:	4290      	cmp	r0, r2
  40961a:	d2b7      	bcs.n	40958c <__udivdi3+0x1ac>
  40961c:	1e60      	subs	r0, r4, #1
  40961e:	2600      	movs	r6, #0
  409620:	e724      	b.n	40946c <__udivdi3+0x8c>
  409622:	4630      	mov	r0, r6
  409624:	e722      	b.n	40946c <__udivdi3+0x8c>
  409626:	42a9      	cmp	r1, r5
  409628:	d995      	bls.n	409556 <__udivdi3+0x176>
  40962a:	f1a8 0802 	sub.w	r8, r8, #2
  40962e:	441d      	add	r5, r3
  409630:	e792      	b.n	409558 <__udivdi3+0x178>
  409632:	458c      	cmp	ip, r1
  409634:	d9a0      	bls.n	409578 <__udivdi3+0x198>
  409636:	3c02      	subs	r4, #2
  409638:	4419      	add	r1, r3
  40963a:	e79e      	b.n	40957a <__udivdi3+0x19a>
  40963c:	4610      	mov	r0, r2
  40963e:	e7df      	b.n	409600 <__udivdi3+0x220>
  409640:	460e      	mov	r6, r1
  409642:	e7c9      	b.n	4095d8 <__udivdi3+0x1f8>
  409644:	3802      	subs	r0, #2
  409646:	4429      	add	r1, r5
  409648:	e743      	b.n	4094d2 <__udivdi3+0xf2>
  40964a:	bf00      	nop

0040964c <all_twi_definitions>:
  40964c:	c600 4000 c700 4000 0008 0000 0008 0000     ...@...@........
  40965c:	0600 4002 0700 4002 0009 0000 0009 0000     ...@...@........
  40966c:	4600 4002 4700 4002 000e 0000 000e 0000     .F.@.G.@........
  40967c:	8600 4001 8700 4001 0013 0000 0013 0000     ...@...@........
  40968c:	c600 4001 c700 4001 0014 0000 0014 0000     ...@...@........
  40969c:	8600 4000 8700 4000 0015 0000 0015 0000     ...@...@........
  4096ac:	0600 4004 0700 4004 0016 0000 0016 0000     ...@...@........
  4096bc:	4600 4003 4700 4003 0007 0000 0007 0000     .F.@.G.@........

004096cc <null_dma_control>:
	...
  4096d4:	2e2e 732f 6372 412f 4653 632f 6d6f 6f6d     ../src/ASF/commo
  4096e4:	2f6e 6573 7672 6369 7365 662f 6572 7265     n/services/freer
  4096f4:	6f74 2f73 6173 2f6d 7266 6565 7472 736f     tos/sam/freertos
  409704:	745f 6977 6d5f 7361 6574 2e72 0063 0000     _twi_master.c...
  409714:	2e2e 732f 6372 412f 4653 632f 6d6f 6f6d     ../src/ASF/commo
  409724:	2f6e 6573 7672 6369 7365 662f 6572 7265     n/services/freer
  409734:	6f74 2f73 6173 2f6d 7266 6565 7472 736f     tos/sam/freertos
  409744:	705f 7265 7069 6568 6172 5f6c 6f63 746e     _peripheral_cont
  409754:	6f72 2e6c 0063 0000 2e2e 732f 6372 412f     rol.c...../src/A
  409764:	4653 632f 6d6f 6f6d 2f6e 6573 7672 6369     SF/common/servic
  409774:	7365 662f 6572 7265 6f74 2f73 6173 2f6d     es/freertos/sam/
  409784:	7266 6565 7472 736f 755f 6173 7472 735f     freertos_usart_s
  409794:	7265 6169 2e6c 0063                         erial.c.

0040979c <all_usart_definitions>:
  40979c:	c200 4000 c300 4000 0008 0000 0008 0000     ...@...@........
  4097ac:	0200 4002 0300 4002 0009 0000 0009 0000     ...@...@........
  4097bc:	4200 4002 4300 4002 000e 0000 000e 0000     .B.@.C.@........
  4097cc:	8200 4001 8300 4001 0013 0000 0013 0000     ...@...@........
  4097dc:	c200 4001 c300 4001 0014 0000 0014 0000     ...@...@........
  4097ec:	8200 4000 8300 4000 0015 0000 0015 0000     ...@...@........
  4097fc:	0200 4004 0300 4004 0016 0000 0016 0000     ...@...@........
  40980c:	4200 4003 4300 4003 0007 0000 0007 0000     .B.@.C.@........
	...
  409824:	000a 0000 0f03 0000 3249 2043 6154 6b73     ........I2C Task
  409834:	5220 6e75 696e 676e 2820 6461 7264 303d      Running (addr=0
  409844:	2578 3230 2978 0a0d 0a0d 0000 2e2e 732f     x%02x)......../s
  409854:	6372 412f 4653 742f 6968 6472 6170 7472     rc/ASF/thirdpart
  409864:	2f79 7266 6565 7472 736f 642f 6d65 2f6f     y/freertos/demo/
  409874:	6570 6972 6870 7265 6c61 635f 6e6f 7274     peripheral_contr
  409884:	6c6f 642f 6d65 2d6f 6174 6b73 2f73 3249     ol/demo-tasks/I2
  409894:	2d43 4c43 2d49 6174 6b73 632e 0000 0000     C-CLI-task.c....
  4098a4:	454c 2044 6974 656d 0072 0000 3249 2043     LED timer...I2C 
  4098b4:	7250 626f 3a65 6120 6464 3d72 7830 7825     Probe: addr=0x%x
  4098c4:	7320 6174 7574 3a73 6c25 0d64 0d0a 000a      status:%ld.....
  4098d4:	3249 2043 6552 6461 5020 6361 656b 3a74     I2C Read Packet:
  4098e4:	6461 7264 303d 2578 2078 7473 7461 7375     addr=0x%x status
  4098f4:	253a 646c 0a0d 0a0d 0000 0000 3249 2043     :%ld........I2C 
  409904:	6552 6461 5020 6361 656b 3a74 6461 7264     Read Packet:addr
  409914:	303d 2578 2078 7473 7461 7375 253a 646c     =0x%x status:%ld
  409924:	202c 7562 6666 303d 2578 3230 0d78 0d0a     , buff=0x%02x...
  409934:	000a 0000 3249 5f43 4c43 0049 0cb8 2000     ....I2C_CLI.... 
  409944:	0032 0000 000a 0000 0500 0000 c200 0001     2...............
  409954:	00c0 0000 0800 0000 0000 0000 0000 0000     ................
  409964:	0000 0000 2e2e 732f 6372 412f 4653 742f     ....../src/ASF/t
  409974:	6968 6472 6170 7472 2f79 7266 6565 7472     hirdparty/freert
  409984:	736f 642f 6d65 2f6f 6570 6972 6870 7265     os/demo/peripher
  409994:	6c61 635f 6e6f 7274 6c6f 642f 6d65 2d6f     al_control/demo-
  4099a4:	6174 6b73 2f73 5355 5241 2d54 4c43 2d49     tasks/USART-CLI-
  4099b4:	6174 6b73 632e 0000 7246 6565 5452 534f     task.c..FreeRTOS
  4099c4:	6320 6d6f 616d 646e 7320 7265 6576 2e72      command server.
  4099d4:	0a0d 7954 6570 4820 6c65 2070 6f74 7620     ..Type Help to v
  4099e4:	6569 2077 2061 696c 7473 6f20 2066 6572     iew a list of re
  4099f4:	6967 7473 7265 6465 6320 6d6f 616d 646e     gistered command
  409a04:	2e73 0a0d 0a0d 003e 0a0d 505b 6572 7373     s.....>...[Press
  409a14:	4520 544e 5245 7420 206f 7865 6365 7475      ENTER to execut
  409a24:	2065 6874 2065 7270 7665 6f69 7375 6320     e the previous c
  409a34:	6d6f 616d 646e 6120 6167 6e69 0d5d 3e0a     ommand again]..>
  409a44:	0000 0000 5f55 4c43 0049 0000 0db0 2000     ....U_CLI...... 
  409a54:	004f 0000 000a 0000 0300 0000 c200 0001     O...............
  409a64:	00c0 0000 0800 0000 0000 0000 0000 0000     ................
  409a74:	0000 0000 2e2e 732f 6372 412f 4653 742f     ....../src/ASF/t
  409a84:	6968 6472 6170 7472 2f79 7266 6565 7472     hirdparty/freert
  409a94:	736f 642f 6d65 2f6f 6570 6972 6870 7265     os/demo/peripher
  409aa4:	6c61 635f 6e6f 7274 6c6f 642f 6d65 2d6f     al_control/demo-
  409ab4:	6174 6b73 2f73 5355 5241 2d54 6365 6f68     tasks/USART-echo
  409ac4:	742d 7361 736b 632e 0000 0000 7854 0000     -tasks.c....Tx..
  409ad4:	7852 0000 6362 6564 6766 6968 6b6a 6d6c     Rx..bcdefghijklm
  409ae4:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  409af4:	3534 3736 3938 4130 4342 4544 4746 4948     4567890ABCDEFGHI
  409b04:	4b4a 4d4c 4f4e 5150 5352 5554 5756 5758     JKLMNOPQRSTUVWXW
  409b14:	315a 3332 3534 3736 3938 5b30 3b5d 2327     Z1234567890[];'#
  409b24:	2b3d 0000 0061 0000 0062 0000 0064 0000     =+..a...b...d...
  409b34:	0065 0000 0067 0000 0068 0000 0069 0000     e...g...h...i...
  409b44:	006b 0000 006c 0000 006d 0000 006f 0000     k...l...m...o...
  409b54:	0070 0000 0071 0000 0074 0000 0075 0000     p...q...t...u...
  409b64:	0077 0000 0078 0000 6261 0000 6261 0063     w...x...ab..abc.
  409b74:	6362 6564 0000 0000 6362 6564 0066 0000     bcde....bcdef...
  409b84:	6362 6564 6766 0000 6362 6564 6766 0068     bcdefg..bcdefgh.
  409b94:	6362 6564 6766 6968 0000 0000 6362 6564     bcdefghi....bcde
  409ba4:	6766 6968 006a 0000 6362 6564 6766 6968     fghij...bcdefghi
  409bb4:	6b6a 0000 6362 6564 6766 6968 6b6a 006c     jk..bcdefghijkl.
  409bc4:	6362 6564 6766 6968 6b6a 6d6c 0000 0000     bcdefghijklm....
  409bd4:	6362 6564 6766 6968 6b6a 6d6c 006e 0000     bcdefghijklmn...
  409be4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 0000     bcdefghijklmno..
  409bf4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 0070     bcdefghijklmnop.
  409c04:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409c14:	0000 0000 6362 6564 6766 6968 6b6a 6d6c     ....bcdefghijklm
  409c24:	6f6e 7170 0072 0000 6362 6564 6766 6968     nopqr...bcdefghi
  409c34:	6b6a 6d6c 6f6e 7170 7372 0000 6362 6564     jklmnopqrs..bcde
  409c44:	6766 6968 6b6a 6d6c 6f6e 7170 7372 0074     fghijklmnopqrst.
  409c54:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409c64:	7372 7574 0000 0000 6362 6564 6766 6968     rstu....bcdefghi
  409c74:	6b6a 6d6c 6f6e 7170 7372 7574 0076 0000     jklmnopqrstuv...
  409c84:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409c94:	7372 7574 7776 0000 6362 6564 6766 6968     rstuvw..bcdefghi
  409ca4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 0078     jklmnopqrstuvwx.
  409cb4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409cc4:	7372 7574 7776 7978 0000 0000 6362 6564     rstuvwxy....bcde
  409cd4:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  409ce4:	7776 7978 007a 0000 6362 6564 6766 6968     vwxyz...bcdefghi
  409cf4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  409d04:	317a 0000 6362 6564 6766 6968 6b6a 6d6c     z1..bcdefghijklm
  409d14:	6f6e 7170 7372 7574 7776 7978 317a 0032     nopqrstuvwxyz12.
  409d24:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409d34:	7372 7574 7776 7978 317a 3332 0000 0000     rstuvwxyz123....
  409d44:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409d54:	7372 7574 7776 7978 317a 3332 0034 0000     rstuvwxyz1234...
  409d64:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409d74:	7372 7574 7776 7978 317a 3332 3534 0000     rstuvwxyz12345..
  409d84:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409d94:	7372 7574 7776 7978 317a 3332 3534 0036     rstuvwxyz123456.
  409da4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409db4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409dc4:	0000 0000 6362 6564 6766 6968 6b6a 6d6c     ....bcdefghijklm
  409dd4:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  409de4:	3534 3736 0038 0000 6362 6564 6766 6968     45678...bcdefghi
  409df4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  409e04:	317a 3332 3534 3736 3938 0000 6362 6564     z123456789..bcde
  409e14:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  409e24:	7776 7978 317a 3332 3534 3736 3938 0030     vwxyz1234567890.
  409e34:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409e44:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409e54:	3938 4130 0000 0000 6362 6564 6766 6968     890A....bcdefghi
  409e64:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  409e74:	317a 3332 3534 3736 3938 4130 0042 0000     z1234567890AB...
  409e84:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409e94:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409ea4:	3938 4130 4342 0000 6362 6564 6766 6968     890ABC..bcdefghi
  409eb4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  409ec4:	317a 3332 3534 3736 3938 4130 4342 0044     z1234567890ABCD.
  409ed4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409ee4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409ef4:	3938 4130 4342 4544 0000 0000 6362 6564     890ABCDE....bcde
  409f04:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  409f14:	7776 7978 317a 3332 3534 3736 3938 4130     vwxyz1234567890A
  409f24:	4342 4544 0046 0000 6362 6564 6766 6968     BCDEF...bcdefghi
  409f34:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  409f44:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  409f54:	4746 0000 6362 6564 6766 6968 6b6a 6d6c     FG..bcdefghijklm
  409f64:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  409f74:	3534 3736 3938 4130 4342 4544 4746 0048     4567890ABCDEFGH.
  409f84:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409f94:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409fa4:	3938 4130 4342 4544 4746 4948 0000 0000     890ABCDEFGHI....
  409fb4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409fc4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  409fd4:	3938 4130 4342 4544 4746 4948 004a 0000     890ABCDEFGHIJ...
  409fe4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  409ff4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a004:	3938 4130 4342 4544 4746 4948 4b4a 0000     890ABCDEFGHIJK..
  40a014:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a024:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a034:	3938 4130 4342 4544 4746 4948 4b4a 004c     890ABCDEFGHIJKL.
  40a044:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a054:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a064:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a074:	0000 0000 6362 6564 6766 6968 6b6a 6d6c     ....bcdefghijklm
  40a084:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  40a094:	3534 3736 3938 4130 4342 4544 4746 4948     4567890ABCDEFGHI
  40a0a4:	4b4a 4d4c 004e 0000 6362 6564 6766 6968     JKLMN...bcdefghi
  40a0b4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a0c4:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a0d4:	4746 4948 4b4a 4d4c 4f4e 0000 6362 6564     FGHIJKLMNO..bcde
  40a0e4:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  40a0f4:	7776 7978 317a 3332 3534 3736 3938 4130     vwxyz1234567890A
  40a104:	4342 4544 4746 4948 4b4a 4d4c 4f4e 0050     BCDEFGHIJKLMNOP.
  40a114:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a124:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a134:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a144:	4f4e 5150 0000 0000 6362 6564 6766 6968     NOPQ....bcdefghi
  40a154:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a164:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a174:	4746 4948 4b4a 4d4c 4f4e 5150 0052 0000     FGHIJKLMNOPQR...
  40a184:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a194:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a1a4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a1b4:	4f4e 5150 5352 0000 6362 6564 6766 6968     NOPQRS..bcdefghi
  40a1c4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a1d4:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a1e4:	4746 4948 4b4a 4d4c 4f4e 5150 5352 0054     FGHIJKLMNOPQRST.
  40a1f4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a204:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a214:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a224:	4f4e 5150 5352 5554 0000 0000 6362 6564     NOPQRSTU....bcde
  40a234:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  40a244:	7776 7978 317a 3332 3534 3736 3938 4130     vwxyz1234567890A
  40a254:	4342 4544 4746 4948 4b4a 4d4c 4f4e 5150     BCDEFGHIJKLMNOPQ
  40a264:	5352 5554 0056 0000 6362 6564 6766 6968     RSTUV...bcdefghi
  40a274:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a284:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a294:	4746 4948 4b4a 4d4c 4f4e 5150 5352 5554     FGHIJKLMNOPQRSTU
  40a2a4:	5756 0000 6362 6564 6766 6968 6b6a 6d6c     VW..bcdefghijklm
  40a2b4:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  40a2c4:	3534 3736 3938 4130 4342 4544 4746 4948     4567890ABCDEFGHI
  40a2d4:	4b4a 4d4c 4f4e 5150 5352 5554 5756 0058     JKLMNOPQRSTUVWX.
  40a2e4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a2f4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a304:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a314:	4f4e 5150 5352 5554 5756 5758 0000 0000     NOPQRSTUVWXW....
  40a324:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a334:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a344:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a354:	4f4e 5150 5352 5554 5756 5758 005a 0000     NOPQRSTUVWXWZ...
  40a364:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a374:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a384:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a394:	4f4e 5150 5352 5554 5756 5758 315a 0000     NOPQRSTUVWXWZ1..
  40a3a4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a3b4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a3c4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a3d4:	4f4e 5150 5352 5554 5756 5758 315a 0032     NOPQRSTUVWXWZ12.
  40a3e4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a3f4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a404:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a414:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a424:	0000 0000 6362 6564 6766 6968 6b6a 6d6c     ....bcdefghijklm
  40a434:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  40a444:	3534 3736 3938 4130 4342 4544 4746 4948     4567890ABCDEFGHI
  40a454:	4b4a 4d4c 4f4e 5150 5352 5554 5756 5758     JKLMNOPQRSTUVWXW
  40a464:	315a 3332 0034 0000 6362 6564 6766 6968     Z1234...bcdefghi
  40a474:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a484:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a494:	4746 4948 4b4a 4d4c 4f4e 5150 5352 5554     FGHIJKLMNOPQRSTU
  40a4a4:	5756 5758 315a 3332 3534 0000 6362 6564     VWXWZ12345..bcde
  40a4b4:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  40a4c4:	7776 7978 317a 3332 3534 3736 3938 4130     vwxyz1234567890A
  40a4d4:	4342 4544 4746 4948 4b4a 4d4c 4f4e 5150     BCDEFGHIJKLMNOPQ
  40a4e4:	5352 5554 5756 5758 315a 3332 3534 0036     RSTUVWXWZ123456.
  40a4f4:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a504:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a514:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a524:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a534:	3534 3736 0000 0000 6362 6564 6766 6968     4567....bcdefghi
  40a544:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a554:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a564:	4746 4948 4b4a 4d4c 4f4e 5150 5352 5554     FGHIJKLMNOPQRSTU
  40a574:	5756 5758 315a 3332 3534 3736 0038 0000     VWXWZ12345678...
  40a584:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a594:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a5a4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a5b4:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a5c4:	3534 3736 3938 0000 6362 6564 6766 6968     456789..bcdefghi
  40a5d4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a5e4:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a5f4:	4746 4948 4b4a 4d4c 4f4e 5150 5352 5554     FGHIJKLMNOPQRSTU
  40a604:	5756 5758 315a 3332 3534 3736 3938 0030     VWXWZ1234567890.
  40a614:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a624:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a634:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a644:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a654:	3534 3736 3938 5b30 0000 0000 6362 6564     4567890[....bcde
  40a664:	6766 6968 6b6a 6d6c 6f6e 7170 7372 7574     fghijklmnopqrstu
  40a674:	7776 7978 317a 3332 3534 3736 3938 4130     vwxyz1234567890A
  40a684:	4342 4544 4746 4948 4b4a 4d4c 4f4e 5150     BCDEFGHIJKLMNOPQ
  40a694:	5352 5554 5756 5758 315a 3332 3534 3736     RSTUVWXWZ1234567
  40a6a4:	3938 5b30 005d 0000 6362 6564 6766 6968     890[]...bcdefghi
  40a6b4:	6b6a 6d6c 6f6e 7170 7372 7574 7776 7978     jklmnopqrstuvwxy
  40a6c4:	317a 3332 3534 3736 3938 4130 4342 4544     z1234567890ABCDE
  40a6d4:	4746 4948 4b4a 4d4c 4f4e 5150 5352 5554     FGHIJKLMNOPQRSTU
  40a6e4:	5756 5758 315a 3332 3534 3736 3938 5b30     VWXWZ1234567890[
  40a6f4:	3b5d 0000 6362 6564 6766 6968 6b6a 6d6c     ];..bcdefghijklm
  40a704:	6f6e 7170 7372 7574 7776 7978 317a 3332     nopqrstuvwxyz123
  40a714:	3534 3736 3938 4130 4342 4544 4746 4948     4567890ABCDEFGHI
  40a724:	4b4a 4d4c 4f4e 5150 5352 5554 5756 5758     JKLMNOPQRSTUVWXW
  40a734:	315a 3332 3534 3736 3938 5b30 3b5d 0027     Z1234567890[];'.
  40a744:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a754:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a764:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a774:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a784:	3534 3736 3938 5b30 3b5d 2327 0000 0000     4567890[];'#....
  40a794:	6362 6564 6766 6968 6b6a 6d6c 6f6e 7170     bcdefghijklmnopq
  40a7a4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a7b4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a7c4:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a7d4:	3534 3736 3938 5b30 3b5d 2327 003d 0000     4567890[];'#=...
  40a7e4:	635f 6564 6766 6968 6b6a 6d6c 6f6e 7170     _cdefghijklmnopq
  40a7f4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a804:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a814:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a824:	3534 3736 3938 5b30 3b5d 2327 2b3d 0000     4567890[];'#=+..
  40a834:	5f5f 6564 6766 6968 6b6a 6d6c 6f6e 7170     __defghijklmnopq
  40a844:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a854:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a864:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a874:	3534 3736 3938 5b30 3b5d 2327 2b3d 0000     4567890[];'#=+..
  40a884:	5f5f 655f 6766 6968 6b6a 6d6c 6f6e 7170     ___efghijklmnopq
  40a894:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a8a4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a8b4:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a8c4:	3534 3736 3938 5b30 3b5d 2327 2b3d 0000     4567890[];'#=+..
  40a8d4:	5f5f 5f5f 6766 6968 6b6a 6d6c 6f6e 7170     ____fghijklmnopq
  40a8e4:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a8f4:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a904:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a914:	3534 3736 3938 5b30 3b5d 2327 2b3d 0000     4567890[];'#=+..
  40a924:	5f5f 5f5f 675f 6968 6b6a 6d6c 6f6e 7170     _____ghijklmnopq
  40a934:	7372 7574 7776 7978 317a 3332 3534 3736     rstuvwxyz1234567
  40a944:	3938 4130 4342 4544 4746 4948 4b4a 4d4c     890ABCDEFGHIJKLM
  40a954:	4f4e 5150 5352 5554 5756 5758 315a 3332     NOPQRSTUVWXWZ123
  40a964:	3534 3736 3938 5b30 3b5d 2327 2b3d 0000     4567890[];'#=+..

0040a974 <xHelpCommand>:
  40a974:	aa70 0040 aa78 0040 2001 0040 0000 0000     p.@.x.@.. @.....
  40a984:	2e2e 732f 6372 412f 4653 742f 6968 6472     ../src/ASF/third
  40a994:	6170 7472 2f79 7266 6565 7472 736f 662f     party/freertos/f
  40a9a4:	6572 7265 6f74 2d73 2e37 2e33 2f30 6f73     reertos-7.3.0/so
  40a9b4:	7275 6563 462f 6572 5265 4f54 5f53 4c43     urce/FreeRTOS_CL
  40a9c4:	2e49 0063 6e49 6f63 7272 6365 2074 6f63     I.c.Incorrect co
  40a9d4:	6d6d 6e61 2064 6170 6172 656d 6574 2872     mmand parameter(
  40a9e4:	2973 202e 4520 746e 7265 2220 6568 706c     s).  Enter "help
  40a9f4:	2022 6f74 7620 6569 2077 2061 696c 7473     " to view a list
  40aa04:	6f20 2066 7661 6961 616c 6c62 2065 6f63      of available co
  40aa14:	6d6d 6e61 7364 0d2e 0d0a 000a 6f43 6d6d     mmands......Comm
  40aa24:	6e61 2064 6f6e 2074 6572 6f63 6e67 7369     and not recognis
  40aa34:	6465 202e 4520 746e 7265 2220 6568 706c     ed.  Enter "help
  40aa44:	2022 6f74 7620 6569 2077 2061 696c 7473     " to view a list
  40aa54:	6f20 2066 7661 6961 616c 6c62 2065 6f63      of available co
  40aa64:	6d6d 6e61 7364 0d2e 0d0a 000a 6568 706c     mmands......help
  40aa74:	0000 0000 0a0d 6568 706c 0d3a 200a 694c     ......help:.. Li
  40aa84:	7473 2073 6c61 206c 6874 2065 6572 6967     sts all the regi
  40aa94:	7473 7265 6465 6320 6d6f 616d 646e 0d73     stered commands.
  40aaa4:	0d0a 000a 2e2e 732f 6372 412f 4653 742f     ....../src/ASF/t
  40aab4:	6968 6472 6170 7472 2f79 7266 6565 7472     hirdparty/freert
  40aac4:	736f 662f 6572 7265 6f74 2d73 2e37 2e33     os/freertos-7.3.
  40aad4:	2f30 6f73 7275 6563 712f 6575 6575 632e     0/source/queue.c
  40aae4:	0000 0000                                   ....

0040aae8 <ucExpectedStackBytes.6040>:
  40aae8:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
  40aaf8:	a5a5 a5a5 7325 0909 6325 2509 0975 7525     ....%s..%c.%u.%u
  40ab08:	2509 0d75 000a 0000 7325 0909 0930 3009     .%u.....%s..0..0
  40ab18:	2525 0a0d 0000 0000 7325 0909 7525 0909     %%......%s..%u..
  40ab28:	7525 2525 0a0d 0000 7325 0909 7525 0909     %u%%....%s..%u..
  40ab38:	313c 2525 0a0d 0000 2e2e 732f 6372 412f     <1%%....../src/A
  40ab48:	4653 742f 6968 6472 6170 7472 2f79 7266     SF/thirdparty/fr
  40ab58:	6565 7472 736f 662f 6572 7265 6f74 2d73     eertos/freertos-
  40ab68:	2e37 2e33 2f30 6f73 7275 6563 742f 7361     7.3.0/source/tas
  40ab78:	736b 632e 0000 0000 4449 454c 0000 0000     ks.c....IDLE....
  40ab88:	6d54 2072 7653 0063 2e2e 732f 6372 412f     Tmr Svc.../src/A
  40ab98:	4653 742f 6968 6472 6170 7472 2f79 7266     SF/thirdparty/fr
  40aba8:	6565 7472 736f 662f 6572 7265 6f74 2d73     eertos/freertos-
  40abb8:	2e37 2e33 2f30 6f73 7275 6563 742f 6d69     7.3.0/source/tim
  40abc8:	7265 2e73 0063 0000                         ers.c...

0040abd0 <create_task_command_definition>:
  40abd0:	ae78 0040 ae84 0040 3e41 0040 0001 0000     x.@...@.A>@.....

0040abe0 <multi_parameter_echo_command_definition>:
  40abe0:	aeec 0040 aefc 0040 3ef1 0040 00ff 0000     ..@...@..>@.....

0040abf0 <delete_task_command_definition>:
  40abf0:	ae24 0040 ae30 0040 3de1 0040 0000 0000     $.@.0.@..=@.....

0040ac00 <run_time_stats_command_definition>:
  40ac00:	b020 0040 b030 0040 4075 0040 0000 0000      .@.0.@.u@@.....
  40ac10:	2e2e 732f 6372 642f 6d65 2d6f 6174 6b73     ../src/demo-task
  40ac20:	2f73 4c43 2d49 6f63 6d6d 6e61 7364 632e     s/CLI-commands.c
  40ac30:	0000 0000 6154 6b73 6420 6c65 7465 6465     ....Task deleted
  40ac40:	0a0d 0000 6854 2065 6174 6b73 7720 7361     ....The task was
  40ac50:	6e20 746f 7220 6e75 696e 676e 202e 4520      not running.  E
  40ac60:	6578 7563 6574 7420 6568 6320 6572 7461     xecute the creat
  40ac70:	2d65 6174 6b73 6320 6d6f 616d 646e 6620     e-task command f
  40ac80:	7269 7473 0d2e 000a 6854 2065 6174 6b73     irst....The task
  40ac90:	6820 7361 6120 726c 6165 7964 6220 6565      has already bee
  40aca0:	206e 7263 6165 6574 2e64 4520 6578 7563     n created. Execu
  40acb0:	6574 7420 6568 6420 6c65 7465 2d65 6174     te the delete-ta
  40acc0:	6b73 6320 6d6f 616d 646e 6620 7269 7473     sk command first
  40acd0:	0d2e 000a 7243 6165 6574 0064 6154 6b73     ....Created.Task
  40ace0:	6320 6572 7461 6465 0a0d 0000 6154 6b73      created....Task
  40acf0:	6e20 746f 6320 6572 7461 6465 0a0d 0000      not created....
  40ad00:	6854 2065 6170 6172 656d 6574 7372 7720     The parameters w
  40ad10:	7265 3a65 0a0d 0000 6c25 3a64 0020 0000     ere:....%ld: ...
  40ad20:	6854 2065 6874 6572 2065 6170 6172 656d     The three parame
  40ad30:	6574 7372 7720 7265 3a65 0a0d 0000 0000     ters were:......
  40ad40:	6154 6b73 2020 2020 2020 2020 2020 2020     Task            
  40ad50:	6241 2073 6954 656d 2020 2020 2020 2025     Abs Time      % 
  40ad60:	6954 656d 0a0d 2a2a 2a2a 2a2a 2a2a 2a2a     Time..**********
  40ad70:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  40ad80:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 0a0d     **************..
  40ad90:	0000 0000 6154 6b73 2020 2020 2020 2020     ....Task        
  40ada0:	2020 7453 7461 2065 5020 6972 726f 7469       State  Priorit
  40adb0:	2079 5320 6174 6b63 2309 0a0d 2a2a 2a2a     y  Stack.#..****
  40adc0:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  40add0:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a     ****************
  40ade0:	2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 0a0d 0000     ************....
  40adf0:	7243 6165 6574 2064 6174 6b73 7220 6e75     Created task run
  40ae00:	696e 676e 202e 5220 6365 6965 6576 2064     ning.  Received 
  40ae10:	6170 6172 656d 6574 2072 6c25 0d64 0d0a     parameter %ld...
  40ae20:	000a 0000 6564 656c 6574 742d 7361 006b     ....delete-task.
  40ae30:	6564 656c 6574 742d 7361 3a6b 0a0d 4420     delete-task:.. D
  40ae40:	6c65 7465 7365 7420 6568 7420 7361 206b     eletes the task 
  40ae50:	7263 6165 6574 2064 7962 7420 6568 6320     created by the c
  40ae60:	6572 7461 2d65 6174 6b73 6320 6d6f 616d     reate-task comma
  40ae70:	646e 0a0d 0a0d 0000 7263 6165 6574 742d     nd......create-t
  40ae80:	7361 006b 7263 6165 6574 742d 7361 206b     ask.create-task 
  40ae90:	703c 7261 6d61 3a3e 0a0d 4320 6572 7461     <param>:.. Creat
  40aea0:	7365 6120 6e20 7765 7420 7361 206b 6874     es a new task th
  40aeb0:	7461 7020 7265 6f69 6964 6163 6c6c 2079     at periodically 
  40aec0:	7277 7469 7365 7420 6568 7020 7261 6d61     writes the param
  40aed0:	7465 7265 7420 206f 6874 2065 4c43 2049     eter to the CLI 
  40aee0:	756f 7074 7475 0a0d 0a0d 0000 6365 6f68     output......echo
  40aef0:	702d 7261 6d61 7465 7265 0073 6365 6f68     -parameters.echo
  40af00:	702d 7261 6d61 7465 7265 2073 2e3c 2e2e     -parameters <...
  40af10:	3a3e 0a0d 5420 6b61 2065 6176 6972 6261     >:.. Take variab
  40af20:	656c 6e20 6d75 6562 2072 666f 7020 7261     le number of par
  40af30:	6d61 7465 7265 2c73 6520 6863 736f 6520     ameters, echos e
  40af40:	6361 2068 6e69 7420 7275 0d6e 0d0a 000a     ach in turn.....
  40af50:	6365 6f68 332d 702d 7261 6d61 7465 7265     echo-3-parameter
  40af60:	0073 0000 6365 6f68 332d 702d 7261 6d61     s...echo-3-param
  40af70:	7465 7265 2073 703c 7261 6d61 3e31 3c20     eters <param1> <
  40af80:	6170 6172 326d 203e 703c 7261 6d61 3e33     param2> <param3>
  40af90:	0d3a 200a 7845 6570 7463 2073 6874 6572     :.. Expects thre
  40afa0:	2065 6170 6172 656d 6574 7372 202c 6365     e parameters, ec
  40afb0:	6f68 2073 6165 6863 6920 206e 7574 6e72     hos each in turn
  40afc0:	0a0d 0a0d 0000 0000 6174 6b73 732d 6174     ........task-sta
  40afd0:	7374 0000 6174 6b73 732d 6174 7374 0d3a     ts..task-stats:.
  40afe0:	200a 6944 7073 616c 7379 6120 7420 6261     . Displays a tab
  40aff0:	656c 7320 6f68 6977 676e 7420 6568 7320     le showing the s
  40b000:	6174 6574 6f20 2066 6165 6863 4620 6572     tate of each Fre
  40b010:	5265 4f54 2053 6174 6b73 0a0d 0a0d 0000     eRTOS task......
  40b020:	7572 2d6e 6974 656d 732d 6174 7374 0000     run-time-stats..
  40b030:	7572 2d6e 6974 656d 732d 6174 7374 0d3a     run-time-stats:.
  40b040:	200a 6944 7073 616c 7379 6120 7420 6261     . Displays a tab
  40b050:	656c 7320 6f68 6977 676e 6820 776f 6d20     le showing how m
  40b060:	6375 2068 7270 636f 7365 6973 676e 7420     uch processing t
  40b070:	6d69 2065 6165 6863 4620 6572 5265 4f54     ime each FreeRTO
  40b080:	2053 6174 6b73 6820 7361 7520 6573 0d64     S task has used.
  40b090:	0d0a 000a                                   ....

0040b094 <task_stats_command_definition>:
  40b094:	afc8 0040 afd4 0040 40ad 0040 0000 0000     ..@...@..@@.....

0040b0a4 <three_parameter_echo_command_definition>:
  40b0a4:	af50 0040 af64 0040 3fad 0040 0003 0000     P.@.d.@..?@.....
  40b0b4:	2e2e 732f 6372 6d2f 6961 2e6e 0063 0000     ../src/main.c...

0040b0c4 <xActiveStates>:
	...

0040b0d0 <ulLED>:
  40b0d0:	0006 0000 0000 0000 0000 0000 0043 0000     ............C...

0040b0e0 <_global_impure_ptr>:
  40b0e0:	01f8 2000                                   ... 

0040b0e4 <zeroes.6911>:
  40b0e4:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

0040b0f4 <blanks.6910>:
  40b0f4:	2020 2020 2020 2020 2020 2020 2020 2020                     
  40b104:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
  40b114:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
  40b124:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
  40b134:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..
  40b144:	0030 0000                                   0...

0040b148 <_ctype_>:
  40b148:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
  40b158:	2020 2020 2020 2020 2020 2020 2020 2020                     
  40b168:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
  40b178:	0410 0404 0404 0404 0404 1004 1010 1010     ................
  40b188:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
  40b198:	0101 0101 0101 0101 0101 0101 1010 1010     ................
  40b1a8:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
  40b1b8:	0202 0202 0202 0202 0202 0202 1010 1010     ................
  40b1c8:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
  40b24c:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
  40b25c:	4f50 4953 0058 0000 002e 0000               POSIX.......

0040b268 <__mprec_tens>:
  40b268:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
  40b278:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
  40b288:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
  40b298:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
  40b2a8:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
  40b2b8:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
  40b2c8:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
  40b2d8:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
  40b2e8:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
  40b2f8:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
  40b308:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
  40b318:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
  40b328:	9db4 79d9 7843 44ea                         ...yCx.D

0040b330 <p05.5302>:
  40b330:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

0040b340 <__mprec_bigtens>:
  40b340:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
  40b350:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
  40b360:	bf3c 7f73 4fdd 7515                         <.s..O.u

0040b368 <_init>:
  40b368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40b36a:	bf00      	nop
  40b36c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40b36e:	bc08      	pop	{r3}
  40b370:	469e      	mov	lr, r3
  40b372:	4770      	bx	lr

0040b374 <__init_array_start>:
  40b374:	00406279 	.word	0x00406279

0040b378 <__frame_dummy_init_array_entry>:
  40b378:	0040016d                                m.@.

0040b37c <_fini>:
  40b37c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40b37e:	bf00      	nop
  40b380:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40b382:	bc08      	pop	{r3}
  40b384:	469e      	mov	lr, r3
  40b386:	4770      	bx	lr

0040b388 <__fini_array_start>:
  40b388:	00400149 	.word	0x00400149
